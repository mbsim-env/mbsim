<?xml version="1.0" encoding="UTF-8"?>
<xs:schema targetNamespace="http://www.mbsim-env.de/MBSimControl"
  elementFormDefault="qualified"
  attributeFormDefault="unqualified"
  xmlns="http://www.mbsim-env.de/MBSimControl"
  xmlns:mbsim="http://www.mbsim-env.de/MBSim"
  xmlns:pv="http://www.mbsim-env.de/MBXMLUtils"
  xmlns:ombv="http://www.mbsim-env.de/OpenMBV"
  xmlns:xs="http://www.w3.org/2001/XMLSchema">

  <xs:annotation>
    <xs:documentation xml:lang="de" xmlns="">
      Mit dem Modul MBSimControl können einfache Regelungsstrukturen aufgebaut werden. 
      <p>
        Zum Auswerten von Systemzuständen oder Funktionen stehen verschiedene Sensoren zur Verfügung, die die entsprechenden Größen zur Verfügung stellen.
        Ebenso stehen Pseude-Sensoren zur Verfügung, welche Funktionen auswerten, um beispielsweise zeitabhängige Eingabegrößen zu generieren.
      </p>
      <p>
        Zum Aufbereiten der Sensorsignale sind Signalmanipulatoren vorhanden.
      </p>
      <p>
        In dynamischen Systemen 1. Ordnung können verschiedene Regelungskonzepte umgesetzt werden.
      </p>
      <p>
        Durch Aktoren können Stellkräfte in die Systeme zurückgespeist werden.
        Da Aktoren als Eingangsgröße ebenfalls Signale erhalten, gibt es einen speziellen Sensor, der die Systeme 1. Ordnung ausliest und deren Systemausgänge an die Aktoren überträgt.
      </p>
    </xs:documentation>
  </xs:annotation>

  <xs:import namespace="http://www.mbsim-env.de/MBXMLUtils"/>

  <xs:import namespace="http://www.mbsim-env.de/OpenMBV"/>

  <xs:import namespace="http://www.mbsim-env.de/MBSim"/>

  <xs:simpleType name="SignalReferenceType">
    <xs:restriction base="pv:stringPartialEval"/>
  </xs:simpleType>

  <xs:element name="Signal" abstract="true" substitutionGroup="mbsim:Link" type="SignalType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Signal
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="SignalType">
    <xs:complexContent>
      <xs:extension base="mbsim:LinkType"/>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="ExternSignalSource" substitutionGroup="Signal" type="ExternSignalSourceType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Dieses Signal bezieht seine Signalwerte (Vektor der dimension n) von einer externen Quelle, z.B,
        von dem Master der Cosimulation mittels MDPCosim.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="ExternSignalSourceType">
    <xs:complexContent>
      <xs:extension base="SignalType">
        <xs:sequence>
          <xs:element name="sourceSize" type="pv:integerFullEval">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Gibt die Dimension der Signalquelle an.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="ExternSignalSink" substitutionGroup="Signal" type="ExternSignalSinkType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Dummy Signal welches ein Signal einfach weiterleitet.
        Der Sinn dieses Signals ist lediglich die Markierung von Signalen als externe Signale.
        Z.b. der FMI export oder Co-Simulation suche alle Signale diese Types und
        verwendet all diese als Signal Ausgänge des Systems.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="ExternSignalSinkType">
    <xs:complexContent>
      <xs:extension base="SignalType">
        <xs:sequence>
          <xs:element name="inputSignal">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                ref=Pfad des Eingangssignals
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:attribute name="ref" type="SignalReferenceType" use="required"/>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="Sensor" abstract="true" substitutionGroup="Signal" type="SensorType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Sensor
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="SensorType">
    <xs:complexContent>
      <xs:extension base="SignalType"/>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="ObjectSensor" abstract="true" substitutionGroup="Sensor" type="ObjectSensorType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Sensor zum Auslesen der generalisierten Koordinaten eines Objekts.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="ObjectSensorType">
    <xs:complexContent>
      <xs:extension base="SensorType">
        <xs:sequence>
          <xs:element name="object">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Pfad des Objekts
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:attribute name="ref" type="mbsim:ObjectReferenceType" use="required"/>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="GeneralizedPositionSensor" substitutionGroup="ObjectSensor" type="GeneralizedPositionSensorType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Sensor zum Auslesen der generalisierten Position
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="GeneralizedPositionSensorType">
    <xs:complexContent>
      <xs:extension base="ObjectSensorType"/>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="GeneralizedVelocitySensor" substitutionGroup="ObjectSensor" type="GeneralizedVelocitySensorType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Sensor zum Auslesen der generalisierten Geschwindigkeit
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="GeneralizedVelocitySensorType">
    <xs:complexContent>
      <xs:extension base="ObjectSensorType"/>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="GeneralizedAccelerationSensor" substitutionGroup="ObjectSensor" type="GeneralizedAccelerationSensorType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Sensor zum Auslesen der generalisierten Beschleunigung
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="GeneralizedAccelerationSensorType">
    <xs:complexContent>
      <xs:extension base="ObjectSensorType"/>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="RigidBodySensor" abstract="true" substitutionGroup="ObjectSensor" type="RigidBodySensorType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Sensor zum Auslesen von Daten eines Starrkörpers.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="RigidBodySensorType">
    <xs:complexContent>
      <xs:extension base="ObjectSensorType"/>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="RigidBodyJointForceSensor" substitutionGroup="RigidBodySensor" type="RigidBodyJointForceSensorType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Sensor zum Auslesen der kartesischen Gelenkkraft eines Starrkörpers.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="RigidBodyJointForceSensorType">
    <xs:complexContent>
      <xs:extension base="RigidBodySensorType">
        <xs:sequence>
          <xs:element name="jointForceNumber" type="pv:indexFullEval" minOccurs="0"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="RigidBodyJointMomentSensor" substitutionGroup="RigidBodySensor" type="RigidBodyJointMomentSensorType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Sensor zum Auslesen des kartesischen Gelenkmoments eines Starrkörpers.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="RigidBodyJointMomentSensorType">
    <xs:complexContent>
      <xs:extension base="RigidBodySensorType">
        <xs:sequence>
          <xs:element name="jointMomentNumber" type="pv:indexFullEval" minOccurs="0"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="FrameSensor" abstract="true" substitutionGroup="Sensor" type="FrameSensorType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Sensor zum Auslesen von Koordinatensystemen in absoluten Koordinaten
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="FrameSensorType">
    <xs:complexContent>
      <xs:extension base="SensorType">
        <xs:sequence>
          <xs:element name="frame">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Pfad des Koordinatensystems von welchem die absoluten Koordinaten ausgelesen werden
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:attribute name="ref" type="mbsim:FrameReferenceType" use="required"/>
            </xs:complexType>
          </xs:element>
          <xs:element name="outputFrame" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Alle kartesischen Sensor-Signale werden in diesem Koordinatensystemen ausgegeben. Wenn nicht angegeben wird das I-System von DynamicSystemSolver verwendet.
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:attribute name="ref" type="mbsim:FrameReferenceType" use="required"/>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="PositionSensor" substitutionGroup="FrameSensor" type="PositionSensorType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Sensor zum Auslesen der Position im Welt-Koordinatensystem
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="PositionSensorType">
    <xs:complexContent>
      <xs:extension base="FrameSensorType"/>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="OrientationSensor" substitutionGroup="FrameSensor" type="OrientationSensorType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Sensor zum Auslesen der Drehmatrix vom körperfesten ins Welt-System
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="OrientationSensorType">
    <xs:complexContent>
      <xs:extension base="FrameSensorType"/>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="VelocitySensor" substitutionGroup="FrameSensor" type="VelocitySensorType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Sensor zum Auslesen der Geschwindigkeit im Welt-Koordinatensystem
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="VelocitySensorType">
    <xs:complexContent>
      <xs:extension base="FrameSensorType"/>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="AngularVelocitySensor" substitutionGroup="FrameSensor" type="AngularVelocitySensorType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Sensor zum Auslesen der Winkelgeschwindigkeit im Welt-Koordinatensystem
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="AngularVelocitySensorType">
    <xs:complexContent>
      <xs:extension base="FrameSensorType"/>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="AccelerationSensor" substitutionGroup="FrameSensor" type="AccelerationSensorType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Sensor zum Auslesen der Beschleunigung im Welt-Koordinatensystem
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="AccelerationSensorType">
    <xs:complexContent>
      <xs:extension base="FrameSensorType"/>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="AngularAccelerationSensor" substitutionGroup="FrameSensor" type="AngularAccelerationSensorType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Sensor zum Auslesen der Winkelbeschleunigung im Welt-Koordinatensystem
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="AngularAccelerationSensorType">
    <xs:complexContent>
      <xs:extension base="FrameSensorType"/>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="FunctionSensor" substitutionGroup="Sensor" type="FunctionSensorType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Sensor zur zeitabhängigen Auswertung von Funktionen
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="FunctionSensorType">
    <xs:complexContent>
      <xs:extension base="SensorType">
        <xs:sequence>
          <xs:element name="function">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Bennenung der Funktion
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:choice>
                <xs:element ref="mbsim:Function"/>
                <xs:element ref="pv:Embed"/>
              </xs:choice>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  <xs:element name="SignalFunction" substitutionGroup="mbsim:Function" type="SignalFunctionType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Funktion dessen Rückgabewert von einem Signal stammt.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="SignalFunctionType">
    <xs:complexContent>
      <xs:extension base="mbsim:FunctionType" >
        <xs:sequence>
          <xs:element name="returnSignal">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Signal von welchem der Rückgabewert entnommen wird.
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:attribute name="ref" type="SignalReferenceType" use="required"/>
            </xs:complexType> 
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="LinkSensor" abstract="true" substitutionGroup="Sensor" type="LinkSensorType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Sensor zum Auslesen von Daten eines Links.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="LinkSensorType">
    <xs:complexContent>
      <xs:extension base="SensorType">
        <xs:sequence>
          <xs:element name="link">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Pfad des Links
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:attribute name="ref" type="mbsim:LinkReferenceType" use="required"/>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="GeneralizedRelativePositionSensor" substitutionGroup="LinkSensor" type="GeneralizedRelativePositionSensorType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Sensor zum Auslesen des generalisierten, relativen Abstands eines Links.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="GeneralizedRelativePositionSensorType">
    <xs:complexContent>
      <xs:extension base="LinkSensorType"/>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="GeneralizedRelativeVelocitySensor" substitutionGroup="LinkSensor" type="GeneralizedRelativeVelocitySensorType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Sensor zum Auslesen der generalisierten, relativen Geschwindigkeit eines Links.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="GeneralizedRelativeVelocitySensorType">
    <xs:complexContent>
      <xs:extension base="LinkSensorType"/>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="GeneralizedForceSensor" substitutionGroup="LinkSensor" type="GeneralizedForceSensorType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Sensor zum Auslesen der generealisierten Kraft eines Links.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="GeneralizedForceSensorType">
    <xs:complexContent>
      <xs:extension base="LinkSensorType"/>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="MechanicalLinkSensor" abstract="true" substitutionGroup="LinkSensor" type="MechanicalLinkSensorType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Sensor zum Auslesen von Daten eines mechanischen Links.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="MechanicalLinkSensorType">
    <xs:complexContent>
      <xs:extension base="LinkSensorType"/>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="MechanicalLinkForceSensor" substitutionGroup="MechanicalLinkSensor" type="MechanicalLinkForceSensorType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Sensor zum Auslesen der kartesischen Kraft eines Links.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="MechanicalLinkForceSensorType">
    <xs:complexContent>
      <xs:extension base="MechanicalLinkSensorType">
        <xs:sequence>
          <xs:element name="forceNumber" type="pv:indexFullEval" minOccurs="0"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="MechanicalLinkMomentSensor" substitutionGroup="MechanicalLinkSensor" type="MechanicalLinkMomentSensorType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Sensor zum Auslesen des kartesischen Moments eines Links.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="MechanicalLinkMomentSensorType">
    <xs:complexContent>
      <xs:extension base="MechanicalLinkSensorType">
        <xs:sequence>
          <xs:element name="momentNumber" type="pv:indexFullEval" minOccurs="0"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="ContactSensor" abstract="true" substitutionGroup="Sensor" type="ContactSensorType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Sensor zum Auslesen von Daten eines Contacts.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="ContactSensorType">
    <xs:complexContent>
      <xs:extension base="SensorType">
        <xs:sequence>
          <xs:element name="contact">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Pfad des Contacts
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:attribute name="ref" type="mbsim:ContactReferenceType" use="required"/>
            </xs:complexType>
          </xs:element>
          <xs:element name="singleContactNumber" type="pv:indexFullEval" minOccurs="0"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="GeneralizedRelativeContactPositionSensor" substitutionGroup="ContactSensor" type="GeneralizedRelativeContactPositionSensorType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Sensor zum Auslesen des generalisierten, relativen Abstands eines Contacts.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="GeneralizedRelativeContactPositionSensorType">
    <xs:complexContent>
      <xs:extension base="ContactSensorType"/>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="GeneralizedRelativeContactVelocitySensor" substitutionGroup="ContactSensor" type="GeneralizedRelativeContactVelocitySensorType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Sensor zum Auslesen der generalisierten, relativen Geschwindigkeit eines Contacts.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="GeneralizedRelativeContactVelocitySensorType">
    <xs:complexContent>
      <xs:extension base="ContactSensorType"/>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="GeneralizedContactForceSensor" substitutionGroup="ContactSensor" type="GeneralizedContactForceSensorType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Sensor zum Auslesen der generalisierten Kraft eines Contacts.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="GeneralizedContactForceSensorType">
    <xs:complexContent>
      <xs:extension base="ContactSensorType"/>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="TyreContactSensor" abstract="true" substitutionGroup="Sensor" type="TyreContactSensorType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Sensor zum Auslesen von Daten eines Reifenkontakts.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="TyreContactSensorType">
    <xs:complexContent>
      <xs:extension base="SensorType">
        <xs:sequence>
          <xs:element name="tyreContact">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Pfad des Reifenkontakts.
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:attribute name="ref" type="mbsim:LinkReferenceType" use="required"/>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="TyreContactPositionSensor" substitutionGroup="TyreContactSensor" type="TyreContactPositionSensorType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Sensor zum Auslesen der Position des Koordinatensystems im Reifenkontaktpunkt.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="TyreContactPositionSensorType">
    <xs:complexContent>
      <xs:extension base="TyreContactSensorType">
        <xs:sequence>
          <xs:element name="positionNumber" type="pv:indexFullEval" minOccurs="0"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="TyreContactOrientationSensor" substitutionGroup="TyreContactSensor" type="TyreContactOrientationSensorType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Sensor zum Auslesen der Orientierung des Koordinatensystems im Reifenkontaktpunkt.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="TyreContactOrientationSensorType">
    <xs:complexContent>
      <xs:extension base="TyreContactSensorType">
        <xs:sequence>
          <xs:element name="orientationNumber" type="pv:indexFullEval" minOccurs="0"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="TyreContactVelocitySensor" substitutionGroup="TyreContactSensor" type="TyreContactVelocitySensorType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Sensor zum Auslesen der Geschwindigkeit des Koordinatensystems im Reifenkontaktpunkt.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="TyreContactVelocitySensorType">
    <xs:complexContent>
      <xs:extension base="TyreContactSensorType">
        <xs:sequence>
          <xs:element name="velocityNumber" type="pv:indexFullEval" minOccurs="0"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="TyreContactAngularVelocitySensor" substitutionGroup="TyreContactSensor" type="TyreContactAngularVelocitySensorType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Sensor zum Auslesen der Winkelgeschwindigkeit des Koordinatensystems im Reifenkontaktpunkt.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="TyreContactAngularVelocitySensorType">
    <xs:complexContent>
      <xs:extension base="TyreContactSensorType">
        <xs:sequence>
          <xs:element name="angularVelocityNumber" type="pv:indexFullEval" minOccurs="0"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="TyreModelSensor" substitutionGroup="TyreContactSensor" type="TyreModelSensorType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Sensor zum Auslesen der Daten des Reifenmodells.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="TyreModelSensorType">
    <xs:complexContent>
      <xs:extension base="TyreContactSensorType"/>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="ConstraintSensor" abstract="true" substitutionGroup="Sensor" type="ConstraintSensorType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Sensor zum Auslesen von Daten eines Constraints.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="ConstraintSensorType">
    <xs:complexContent>
      <xs:extension base="SensorType">
        <xs:sequence>
          <xs:element name="constraint">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Pfad des Constraints
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:attribute name="ref" type="mbsim:ConstraintReferenceType" use="required"/>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="MechanicalConstraintSensor" abstract="true" substitutionGroup="ConstraintSensor" type="MechanicalConstraintSensorType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Sensor zum Auslesen von Daten eines mechanischen Constraints.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="MechanicalConstraintSensorType">
    <xs:complexContent>
      <xs:extension base="ConstraintSensorType"/>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="MechanicalConstraintForceSensor" substitutionGroup="MechanicalConstraintSensor" type="MechanicalConstraintForceSensorType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Sensor zum Auslesen der kartesischen Kraft eines Constraints.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="MechanicalConstraintForceSensorType">
    <xs:complexContent>
      <xs:extension base="MechanicalConstraintSensorType">
        <xs:sequence>
          <xs:element name="forceNumber" type="pv:indexFullEval" minOccurs="0"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="MechanicalConstraintMomentSensor" substitutionGroup="MechanicalConstraintSensor" type="MechanicalConstraintMomentSensorType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Sensor zum Auslesen des kartesischen Moments eines Constraints.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="MechanicalConstraintMomentSensorType">
    <xs:complexContent>
      <xs:extension base="MechanicalConstraintSensorType">
        <xs:sequence>
          <xs:element name="momentNumber" type="pv:indexFullEval" minOccurs="0"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="SignalSensor" abstract="true" substitutionGroup="Sensor" type="SignalSensorType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Sensor zum Auslesen von Koordinatensystemen in absoluten Koordinaten
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="SignalSensorType">
    <xs:complexContent>
      <xs:extension base="SensorType">
        <xs:sequence>
          <xs:element name="signal">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Eingangssignal
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:attribute name="ref" type="SignalReferenceType" use="required"/>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="Multiplexer" substitutionGroup="Signal" type="MultiplexerType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Vektorwertiges Zusammenführen von Signalen
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="MultiplexerType">
    <xs:complexContent>
      <xs:extension base="SignalType">
        <xs:choice minOccurs="1" maxOccurs="unbounded">
          <xs:element name="inputSignal">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Eingangssignal
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:attribute name="ref" type="SignalReferenceType" use="required"/>
            </xs:complexType>
          </xs:element>
          <xs:element ref="pv:Embed"/>
        </xs:choice>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="Demultiplexer" substitutionGroup="Signal" type="DemultiplexerType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Auswahl eines Index eines vektorwertigen Signals
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="DemultiplexerType">
    <xs:complexContent>
      <xs:extension base="SignalType">
        <xs:sequence>
          <xs:element name="inputSignal">
            <xs:complexType>
              <xs:attribute name="ref" type="SignalReferenceType" use="required"/>
            </xs:complexType>
          </xs:element>
          <xs:element name="indices" type="pv:indexVector">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Vektor der ausgewählten Indizes.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="SignalOperation" substitutionGroup="Signal" type="SignalOperationType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        TODO
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="SignalOperationType">
    <xs:complexContent>
      <xs:extension base="SignalType">
        <xs:sequence>
          <xs:choice minOccurs="1" maxOccurs="unbounded">
            <xs:element name="inputSignal">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Eingangssignal
              </xs:documentation></xs:annotation>
              <xs:complexType>
                <xs:attribute name="ref" type="SignalReferenceType" use="required"/>
              </xs:complexType>
            </xs:element>
            <xs:element ref="pv:Embed"/>
          </xs:choice>
          <xs:element name="multiplexInputSignals" type="pv:booleanFullEval" minOccurs="0"/>
          <xs:element name="function">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Funktion
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:choice>
                <xs:element ref="mbsim:Function"/>
                <xs:element ref="pv:Embed"/>
              </xs:choice>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="SignalTimeDiscretization" substitutionGroup="Signal" type="SignalTimeDiscretizationType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Zeitdiskretisierung eines Signals (ALPHA-STATUS)
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="SignalTimeDiscretizationType">
    <xs:complexContent>
      <xs:extension base="SignalType">
        <xs:sequence>
          <xs:element name="input">
            <xs:complexType>
              <xs:attribute name="ref" type="SignalReferenceType" use="required"/>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="LinearTransferSystem" substitutionGroup="Signal" type="LinearTransferSystemType"/>
  <xs:complexType name="LinearTransferSystemType">
    <xs:complexContent>
      <xs:extension base="SignalType">
        <xs:sequence>
          <xs:element name="initialState" minOccurs="0" type="pv:unknownVector">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
              Anfangszustand
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="inputSignal">
            <xs:complexType>
              <xs:attribute name="ref" type="SignalReferenceType" use="required"/>
            </xs:complexType>
          </xs:element>
          <xs:element name="systemMatrix" type="pv:nounitMatrix"/>
          <xs:element name="inputMatrix" type="pv:nounitMatrix"/>
          <xs:element name="outputMatrix" type="pv:nounitMatrix" minOccurs="0"/>
          <xs:element name="feedthroughMatrix" type="pv:nounitMatrix" minOccurs="0"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="NonlinearTransferSystem" substitutionGroup="Signal" type="NonlinearTransferSystemType"/>
  <xs:complexType name="NonlinearTransferSystemType">
    <xs:complexContent>
      <xs:extension base="SignalType">
        <xs:sequence>
          <xs:element name="initialState" minOccurs="0" type="pv:unknownVector">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
              Anfangszustand
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="inputSignal">
            <xs:complexType>
              <xs:attribute name="ref" type="SignalReferenceType" use="required"/>
            </xs:complexType>
          </xs:element>
          <xs:element name="systemFunction">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Systemfunktion
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:choice>
                <xs:element ref="mbsim:Function"/>
                <xs:element ref="pv:Embed"/>
              </xs:choice>
            </xs:complexType>
          </xs:element>
          <xs:element name="outputFunction" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Ausgabefunktion
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:choice>
                <xs:element ref="mbsim:Function"/>
                <xs:element ref="pv:Embed"/>
              </xs:choice>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="MasslessSpringDamper" substitutionGroup="Signal" type="MasslessSpringDamperType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Feder-Dämpfer System, bei dem die Masse vernachlässigt wird. <br/>
        <object class="figure" data="massless_spring_damper.svg">Größen</object>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="MasslessSpringDamperType">
    <xs:complexContent>
      <xs:extension base="SignalType">
        <xs:sequence>
          <xs:sequence>
            <xs:element name="springStiffness" type="pv:stiffnessScalar">
              <xs:annotation>
                <xs:documentation xml:lang="de" xmlns="">
                  <object class="inlineeqn">c</object>
                </xs:documentation>
              </xs:annotation>
            </xs:element>
            <xs:element name="basicSpringForce" type="pv:forceScalar">
              <xs:annotation>
                <xs:documentation xml:lang="de" xmlns="">
                  <object class="inlineeqn">F_0</object>
                </xs:documentation>
              </xs:annotation>
            </xs:element>
            <xs:element name="dampingCoefficient" type="pv:dampingScalar">
              <xs:annotation>
                <xs:documentation xml:lang="de" xmlns="">
                  <object class="inlineeqn">d</object>
                </xs:documentation>
              </xs:annotation>
            </xs:element>
            <xs:element name="negativeDampingCoefficient" type="pv:dampingScalar" minOccurs="0">
              <xs:annotation>
                <xs:documentation xml:lang="de" xmlns="">
                  <object class="inlineeqn">d_{neg}</object>
                </xs:documentation>
              </xs:annotation>
            </xs:element>
            <xs:element name="frictionForce" type="pv:forceScalar" minOccurs="0">
              <xs:annotation>
                <xs:documentation xml:lang="de" xmlns="">
                  <object class="inlineeqn">F_{fric}</object>
                </xs:documentation>
              </xs:annotation>
            </xs:element>
            <xs:element name="negativeFrictionForce" type="pv:forceScalar" minOccurs="0">
              <xs:annotation>
                <xs:documentation xml:lang="de" xmlns="">
                  <object class="inlineeqn">F_{fric, neg}</object>
                </xs:documentation>
              </xs:annotation>
            </xs:element>
            <xs:element name="minimalPositionValue" type="pv:lengthScalar" minOccurs="0">
              <xs:annotation>
                <xs:documentation xml:lang="de" xmlns="">
                  <object class="inlineeqn">x_{min}</object>
                </xs:documentation>
              </xs:annotation>
            </xs:element>
            <xs:element name="maximalPositionValue" type="pv:lengthScalar" minOccurs="0">
              <xs:annotation>
                <xs:documentation xml:lang="de" xmlns="">
                  <object class="inlineeqn">x_{max}</object>
                </xs:documentation>
              </xs:annotation>
            </xs:element>
          </xs:sequence>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="SignalObserver" substitutionGroup="mbsim:Observer" type="SignalObserverType">
    <xs:annotation><xs:documentation xml:lang="en" xmlns="">
      Observe the data of a signal and optionally visualize a 3-vector signal as a Arrow or
      a n-vector signal as a IvScreenObserver.
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="SignalObserverType">
    <xs:complexContent>
      <xs:extension base="mbsim:ObserverType">
        <xs:sequence>
          <xs:element name="signal">
            <xs:annotation>
              <xs:documentation xml:lang="en" xmlns="">
                The signal to be observed.
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:attribute name="ref" type="SignalReferenceType" use="required"/>
            </xs:complexType>
          </xs:element>
          <xs:element name="position" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                The 3-vector signal for the position where the Arrow should be visualized, (0,0,0) if not given.
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:attribute name="ref" type="SignalReferenceType" use="required"/>
            </xs:complexType>
          </xs:element>
          <xs:element name="enableOpenMBV" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="en" xmlns="">
                Enable the visualization of a 3-vector signal as a Arrow.
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:group ref="mbsim:OpenMBVArrowParameters"/>
            </xs:complexType>
          </xs:element>
          <xs:element name="openMBVIvScreenAnnotation" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="en" xmlns="">
                enable the visualization of a n-vector signal as an OpenMBV IvScreenAnnotation.
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:choice>
                <xs:element ref="ombv:IvScreenAnnotation"/>
                <xs:element ref="pv:Embed"/>
              </xs:choice>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="FrameChaserObserver" substitutionGroup="mbsim:Observer" type="FrameChaserObserverType">
    <xs:annotation><xs:documentation xml:lang="en" xmlns="">
    Creates a OpenMBV <a class="link" href="openmbv:Frame"><span class="_element">&lt;Frame&gt;</span></a> which
    moves (translation and rotation) according to a given definition.
    This definition can be provided per component of the translation and rotation.
    It can also reference a MBSim <a class="link" href="mbsim:Frame"><span class="_element">&lt;Frame&gt;</span></a> to chase.
    Single components for the translation and rotation can still be overwritten when following a Frame.
    This is even the basic usage of this observer: following a MBSim Frame but using different definitions for some
    components of the translation and/or rotation.
    This is very useful in OpenMBV to move the camera with such a FrameChaserObserver.
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="FrameChaserObserverType">
    <xs:complexContent>
      <xs:extension base="mbsim:ObserverType">
        <xs:sequence>
          <xs:element name="frame" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="en" xmlns="">
              The frame to chase. If given, this observer follows the referenced Frame but the following definitions can
              be used to overwrite single components for translation and rotation.
              If not given, this observer is fixed in space at the world coordinate system but the following defintions can
              still be used to overwrite single components.
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:attribute name="ref" type="mbsim:FrameReferenceType" use="required"/>
            </xs:complexType>
          </xs:element>
          <xs:choice minOccurs="0">
            <xs:element name="constantX" type="pv:lengthScalar" minOccurs="0">
              <xs:annotation><xs:documentation xml:lang="en" xmlns="">
                Defines a constant value for the x-translation of the observer frame.
              </xs:documentation></xs:annotation>
            </xs:element>
            <xs:element name="signalX">
              <xs:annotation><xs:documentation xml:lang="en" xmlns="">
                Defines a signal being used for the x-translation of the observer frame.
              </xs:documentation></xs:annotation>
              <xs:complexType>
                <xs:attribute name="ref" type="SignalReferenceType" use="required"/>
              </xs:complexType>
            </xs:element>
          </xs:choice>
          <xs:choice minOccurs="0">
            <xs:element name="constantY" type="pv:lengthScalar" minOccurs="0"/>
            <xs:element name="signalY">
              <xs:complexType>
                <xs:attribute name="ref" type="SignalReferenceType" use="required"/>
              </xs:complexType>
            </xs:element>
          </xs:choice>
          <xs:choice minOccurs="0">
            <xs:element name="constantZ" type="pv:lengthScalar" minOccurs="0"/>
            <xs:element name="signalZ">
              <xs:complexType>
                <xs:attribute name="ref" type="SignalReferenceType" use="required"/>
              </xs:complexType>
            </xs:element>
          </xs:choice>
          <xs:choice minOccurs="0">
            <xs:element name="constantRotationX" type="pv:angleScalar" minOccurs="0">
              <xs:annotation><xs:documentation xml:lang="en" xmlns="">
                Defines a constant angle for the rotation about the world x-axis of the observer frame.
              </xs:documentation></xs:annotation>
            </xs:element>
            <xs:element name="signalRotationX">
              <xs:annotation><xs:documentation xml:lang="en" xmlns="">
                Defines a signal being used for the rotation angle about the world x-axis of the observer frame.
              </xs:documentation></xs:annotation>
              <xs:complexType>
                <xs:attribute name="ref" type="SignalReferenceType" use="required"/>
              </xs:complexType>
            </xs:element>
          </xs:choice>
          <xs:choice minOccurs="0">
            <xs:element name="constantRotationY" type="pv:angleScalar" minOccurs="0"/>
            <xs:element name="signalRotationY">
              <xs:complexType>
                <xs:attribute name="ref" type="SignalReferenceType" use="required"/>
              </xs:complexType>
            </xs:element>
          </xs:choice>
          <xs:choice minOccurs="0">
            <xs:element name="constantRotationZ" type="pv:angleScalar" minOccurs="0"/>
            <xs:element name="signalRotationZ">
              <xs:complexType>
                <xs:attribute name="ref" type="SignalReferenceType" use="required"/>
              </xs:complexType>
            </xs:element>
          </xs:choice>
          <xs:element name="enableOpenMBV" minOccurs="0">
            <xs:complexType>
              <xs:group ref="mbsim:OpenMBVFrameParameters"/>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="MotionObserver" substitutionGroup="mbsim:Observer" type="MotionObserverType">
    <xs:annotation><xs:documentation xml:lang="en" xmlns="">
      Creates a OpenMBV <a class="link" href="openmbv:RigidBody"><span class="_element">&lt;Rigid Body&gt;</span></a> which
      moves according to a given position and orientation signal.
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="MotionObserverType">
    <xs:complexContent>
      <xs:extension base="mbsim:ObserverType">
        <xs:sequence>
          <xs:element name="frameOfReference" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="en" xmlns="">
              The frame of reference.
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:attribute name="ref" type="mbsim:FrameReferenceType" use="required"/>
            </xs:complexType>
          </xs:element>
          <xs:element name="positionSignal" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="en" xmlns="">
              Defines a signal being used for the position of the body. The size of the signal must be 3.
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:attribute name="ref" type="SignalReferenceType" use="required"/>
            </xs:complexType>
          </xs:element>
          <xs:element name="orientationSignal" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="en" xmlns="">
              Defines a signal being used for the orientation of the body. The size of the signal must be 3 in case of Cardan angles or 9 in case of a transformation matrix.
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:attribute name="ref" type="SignalReferenceType" use="required"/>
            </xs:complexType>
          </xs:element>
          <xs:element name="openMBVRigidBody" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Activates the visualization of the body in OpenMBV.
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:choice>
                <xs:element ref="ombv:RigidBody"/>
                <xs:element ref="pv:Embed"/>
              </xs:choice>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="Switch" substitutionGroup="Signal" type="SwitchType"/>
  <xs:complexType name="SwitchType">
    <xs:complexContent>
      <xs:extension base="SignalType">
        <xs:sequence>
          <xs:element name="firstDataInputSignal">
            <xs:complexType>
              <xs:attribute name="ref" type="SignalReferenceType" use="required"/>
            </xs:complexType>
          </xs:element>
          <xs:element name="secondDataInputSignal">
            <xs:complexType>
              <xs:attribute name="ref" type="SignalReferenceType" use="required"/>
            </xs:complexType>
          </xs:element>
          <xs:element name="controlInputSignal">
            <xs:complexType>
              <xs:attribute name="ref" type="SignalReferenceType" use="required"/>
            </xs:complexType>
          </xs:element>
	  <xs:element name="threshold" type="pv:unknownScalar" minOccurs="0"/>
	  <xs:element name="rootFinding" type="pv:booleanFullEval" minOccurs="0"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="Stop" substitutionGroup="Signal" type="StopType"/>
  <xs:complexType name="StopType">
    <xs:complexContent>
      <xs:extension base="SignalType">
        <xs:sequence>
          <xs:element name="inputSignal">
            <xs:complexType>
              <xs:attribute name="ref" type="SignalReferenceType" use="required"/>
            </xs:complexType>
          </xs:element>
	  <xs:element name="threshold" type="pv:unknownVector" minOccurs="0"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="Duration" substitutionGroup="Signal" type="DurationType"/>
  <xs:complexType name="DurationType">
    <xs:complexContent>
      <xs:extension base="SignalType">
        <xs:sequence>
          <xs:element name="inputSignal">
            <xs:complexType>
              <xs:attribute name="ref" type="SignalReferenceType" use="required"/>
            </xs:complexType>
          </xs:element>
	  <xs:element name="threshold" type="pv:unknownScalar" minOccurs="0"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="StateMachine" substitutionGroup="Signal" type="StateMachineType"/>
  <xs:complexType name="StateMachineType">
    <xs:complexContent>
      <xs:extension base="SignalType">
        <xs:sequence>
          <xs:element name="state" minOccurs="1" maxOccurs="unbounded">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Zustände.
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:attribute name="name" type="pv:stringFullEval" use="required"/>
              <xs:attribute name="value" type="pv:floatFullEval" use="required"/>
            </xs:complexType>
          </xs:element>
          <xs:element name="transition" minOccurs="1" maxOccurs="unbounded">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Zustandsübergänge.
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:attribute name="source" type="pv:stringFullEval" use="required"/>
              <xs:attribute name="destination" type="pv:stringFullEval" use="required"/>
              <xs:attribute name="signal" type="SignalReferenceType" use="required"/>
              <xs:attribute name="threshold" type="pv:floatFullEval" use="optional"/>
            </xs:complexType>
          </xs:element>
          <xs:element name="initialState" type="pv:stringFullEval" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Anfangszustand.
            </xs:documentation></xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="StateMachineSensor" substitutionGroup="Sensor" type="StateMachineSensorType"/>
  <xs:complexType name="StateMachineSensorType">
    <xs:complexContent>
      <xs:extension base="SensorType">
        <xs:sequence>
          <xs:element name="stateMachine">
            <xs:complexType>
              <xs:attribute name="ref" type="SignalReferenceType" use="required"/>
            </xs:complexType>
          </xs:element>
	  <xs:element name="state" type="pv:stringFullEval" minOccurs="0"/>
          <xs:element name="selection" type="pv:stringFullEval" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Auswahl des Sensorsignals (standardmäßig durationOfActivity).
              <ul>
                <li>value: Wert</li>
                <li>activity: Aktivität</li>
                <li>durationOfActivity: Dauer der Aktivität</li>
              </ul>
            </xs:documentation></xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="LinearSystemAnalyzer" substitutionGroup="mbsim:Solver" type="LinearSystemAnalyzerType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
      Führt eine Eigenanalyse, eine Modalanalyse und eine Frequenzganganalyse eines dynamischen Systems durch. Dabei wird das nichtlineare System in ein lineares, zeitinvariantes System transformiert. Die zugehörigen Matrizen A, B, C und D werden in einer Datei gespeichert.
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="LinearSystemAnalyzerType">
    <xs:complexContent>
      <xs:extension base="mbsim:SolverType">
        <xs:sequence>
          <xs:element name="initialTime" type="pv:timeScalar" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Anfangszeitpunkt. Entspricht dem Zeitpunkt, zu dem das System linearisiert werden soll.
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="initialState" type="pv:unknownVector" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Anfangszustand.
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="initialInput" type="pv:unknownVector" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Startwerte der Eingangsgrößen.
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="minimumNaturalFrequency" type="pv:unknownScalar" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Kleinste Eigenfrequenz, die berechnet werden soll. Standardardmäßig 0.01 Hz.
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="maximumNaturalFrequency" type="pv:unknownScalar" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Größte Eigenfrequenz, die berechnet werden soll. Standardardmäßig 100 kHz.
            </xs:documentation></xs:annotation>
          </xs:element>
	  <xs:element name="normalModeScaleFactor" type="pv:nounitScalar" minOccurs="0">
	    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
	      Faktor, mit der alle Eigenmoden skaliert werden sollen.
	    </xs:documentation></xs:annotation>
	  </xs:element>
	  <xs:element name="normalModeScale" type="pv:nounitVector" minOccurs="0">
	    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
	      Faktoren, mit denen die einzelen Eigenmoden skaliert werden sollen.
	    </xs:documentation></xs:annotation>
	  </xs:element>
          <xs:element name="excitationFrequencies" type="pv:unknownVector" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Vektor der Anregungsfrequenzen.
            </xs:documentation></xs:annotation>
          </xs:element>
	  <xs:element name="excitationAmplitudeFunction" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Anregungsamplituden der Eingänge als Funktion der Anregungsfrequenz.
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:choice>
                <xs:element ref="mbsim:Function"/>
                <xs:element ref="pv:Embed"/>
              </xs:choice>
            </xs:complexType>
          </xs:element>
          <xs:element name="excitationPhaseFunction" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Phasenverschiebungen der Eingänge als Funktion der Anregungsfrequenz.
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:choice>
                <xs:element ref="mbsim:Function"/>
                <xs:element ref="pv:Embed"/>
              </xs:choice>
            </xs:complexType>
          </xs:element>
          <xs:element name="visualizeNormalModes" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Visualisierung der Schwingformen in OpenMBV.
            </xs:documentation></xs:annotation>
	    <xs:complexType>
	      <xs:sequence>
	        <xs:element name="modeNumbers" type="pv:nounitVector" minOccurs="0">
	          <xs:annotation><xs:documentation xml:lang="de" xmlns="">
		    Auswahl der Moden, die visualisiert werden sollen.
		  </xs:documentation></xs:annotation>
	        </xs:element>
	      </xs:sequence>
	    </xs:complexType>
          </xs:element>
          <xs:element name="visualizeFrequencyResponse" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Visualisierung des Frequenzgangs in OpenMBV.
            </xs:documentation></xs:annotation>
	    <xs:complexType>
	      <xs:sequence>
                <xs:element name="frequencyRange" type="pv:unknownVector" minOccurs="0">
                  <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                    Frequenzbreich, der visualisiert werden soll. Standardardmäßig 0 bis 10 Hz.
                  </xs:documentation></xs:annotation>
                </xs:element>
	      </xs:sequence>
	    </xs:complexType>
          </xs:element>
          <xs:element name="visualizeSuperposedSolution" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Visualisierung der überlagerten Schwingungsantwort in OpenMBV.
            </xs:documentation></xs:annotation>
	    <xs:complexType>
	      <xs:sequence>
                <xs:element name="frequencyAmplitudePhaseArray">
                  <xs:annotation>
                    <xs:documentation xml:lang="de" xmlns="">
                      tbd.
                    </xs:documentation>
                  </xs:annotation>
                  <xs:complexType>
                    <xs:sequence>
                      <xs:element name="ele" type="pv:unknownMatrix" maxOccurs="unbounded"/>
                    </xs:sequence>
                  </xs:complexType>
                </xs:element>
                <xs:element name="timeSpan" type="pv:timeScalar" minOccurs="0">
                  <xs:annotation><xs:documentation xml:lang="de" xmlns="">
		    Zeitspanne für die Simulation.
                  </xs:documentation></xs:annotation>
                </xs:element>
                <xs:element name="includeTransientSolution" type="pv:booleanFullEval" minOccurs="0">
                  <xs:annotation><xs:documentation xml:lang="de" xmlns="">
		    Definiert, ob der Einschwingvorgang bei der Visualisierung berücksichtigt werden soll. Standarmäßig ja.
                  </xs:documentation></xs:annotation>
                </xs:element>
	      </xs:sequence>
	    </xs:complexType>
          </xs:element>
          <xs:element name="plotStepSize" type="pv:timeScalar" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Zeitschrittweite bei der Visualisierung.
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="loops" type="pv:integerFullEval" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Anzahl der Schwingungen pro Eigenmode bzw. pro Anregungsfrquenz bei der Visualisierung.
            </xs:documentation></xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

</xs:schema>
