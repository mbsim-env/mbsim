\section{\MBSim - Program Overview}
\MBSim{} is written in the object-oriented programming language C++. The interface of all classes is documented in the source code using Doxygen. This documentation has been extracted for convenient study together with a class overview during installation with the command \texttt{make doc}. Just change to \texttt{\$HOME/MBSim/*/doc/html} and open \texttt{index.html} with an appropriate browser. With this class documentation and the use of self-explaining names in the user interface it is goal of this section to give an overview about the main features of \MBSim{}.\par
\MBSim{} can handle a set of dynamical systems from various domains not only separated but also exchanging data of the form
\begin{align*}
\dot{\vq}&=\vT\vu\\
\vM\dot{\vu}&=\vh\left(\vq,\vu,t\right)+\vW\vlambda\\
\dot{\vx}&=\vf\left(\vx\right)\\
&\mathcal{\vN}\left(\vq,\vu,t\right)
\end{align*}
A typical example of a dynamical system only from mechanics is given by Fig.~\ref{fig:objects}.
\begin{figure}
	\centering
    
    \psfrag{Body}{\textsf{\small body}}
    \psfrag{Frame}{\textsf{\small frame}}
    \psfrag{Contour}{\textsf{\small contour}}
    \psfrag{Joint}{\textsf{\small joint}}
    \psfrag{Contact}{\textsf{\small contact}}
    \psfrag{Load}{\put(-5.0,+5.0){\textsf{\small kinetic excitation}}}
  	\includegraphics[width=12cm]{Figures/objectorientationMBSim.eps} 
  	\caption{object structure in \MBSim}
  	\label{fig:objects}
\end{figure}
One has the environment and two bodies holding the inertia terms. Indicated are interconnecting links due to contacts between body contours giving also the possibility to model friction and ideal joints between body frames as well as an external kinetic excitation acting on a body frame. These ingredients from the mechanical point of view and a schedule of the simulation are basically explained in the following to have an easier begin with \MBSim{}.

\subsection{Description of the Components}
The following classes can be used for modelling and simulating dynamical systems in \MBSim{}.

\subsubsection{DynamicSystem and DynamicSystemSolver}
Hierarchically bodies and links belong to \texttt{DynamicSystem}s. The top-most \texttt{DynamicSystem} is called \texttt{DynamicSystemSolver}. It also represents the interface to the integration schemes and allows the setting of environment variables (e.g. gravitation).\par
Important settings: 
\begin{itemize}
\item[] \texttt{setReorganizeHierarchy}\\
    enforces the automatic creation of invisible tree structures only for simulation depending on the hierarchy of frames used for modelling 
\item[] \texttt{setConstraintSolver}\\
    solver for constraint equations on acceleration level (cf. \emph{setImpactSolver})
\item[] \texttt{setImpactSolver}\\
    solver for constraint equations on velocity level; available constraint equation solution schemes are
    \begin{itemize}
        \item[] \texttt{LinearEquations}\\
        Cholesky solution scheme for regular linear systems (only bilateral constraints)
        \item[] \texttt{GaussSeidel}\\
        Gauss-Seidel solution scheme for piecewise linear systems (planar Coulomb friction)
        \item[] \texttt{FixedPointSingle}\\
        Gauss-Seidel solution scheme with fixed point search and relaxation strategy for spatial Coulomb friction
        \item[] \texttt{RootFinding}\\
        damped and globalised Newton scheme for spatial Coulomb friction
        \end{itemize}
\item[] \texttt{setLinAlg}\\
    linear equations solver for \emph{RootFinding}; available solvers are
    \begin{itemize}
    \item[] \texttt{LUDecomposition}\\
    LU decomposition is only valid for non-singular contact situations
    \item[] \texttt{LevenbergMarquardt}\\
    regularisation of contact matrix by Levenberg Marquard factor
    \item[] \texttt{PseudoInverse}\\
    selecting the norm-minimal solution if there exist several 
    \end{itemize}
\item[] \texttt{setStrategy}\\
    set relaxation strategy to \texttt{local} (contact wise) or \texttt{global} (all contacts)
\item[] \texttt{setNumJacProj}
\item[] \texttt{setMaxIter}\\
    set the maximum number of iterations in the contact solver
\item[] \texttt{setStopIfNoConvergence}\\
    the integrator stops integration, if there is no convergence in the contact solver
\item[] \texttt{addFrame}\\
    cf. \texttt{Frame}
\end{itemize}

\subsubsection{Frames}
\texttt{Frame}s are a basic concept in \MBSim{} to define an interface for \MBSim{} components concerning kinematic and kinetic expressions. New frames can be added arbitrarily and recursively based on a predecessor frame. That is why there has to be a first frame for specific \MBSim{} components, e.g. each \texttt{DynamicSystem} has got a stationary frame \texttt{"I"} (inertia frame).\par
Important settings next to position and orientation are defined according to the parametrisation
\begin{align*}
  	\begin{pmatrix}	\rs{_I}[_P]{\va}\\ \rs{_I}{\vPsi}\end{pmatrix} 
	&= \begin{pmatrix}\rs{_I}[_P]{\vJ}\\ \rs{_I}[_R]{\vJ}\end{pmatrix} \,
	\dot{\vu} +
   	  \begin{pmatrix}\rs{_I}[_P]{\viota}\\\rs{_I}[_R]{\viota}\end{pmatrix}
\end{align*}
such that summarizing
\begin{itemize}
\item[] \texttt{getPosition} 
\item[] \texttt{getOrientation} 
\item[] \texttt{getVelocity}
\item[] \texttt{getAngularVelocity} 
\item[] \texttt{getJacobianOfTranslation} 
\item[] \texttt{getJacobianOfRotation}
\item[] \texttt{getGyroscopicAccelerationOfTranslation}
\item[] \texttt{getGyroscopicAccelerationOfRotation}
\item[] \texttt{enableOpenMBV}\\
    enabling visualisation for \OpenMBV{}
\end{itemize}

\subsubsection{Bodies}
\paragraph{Rigid Bodies}
For each \texttt{RigidBody} a \texttt{Frame} \texttt{"C"} in the centre of gravity is predefined. One perhaps newly created \texttt{Frame} of the \texttt{RigidBody} has to be chosen as frame for kinematics, and one \texttt{Frame} of another \texttt{Body} or a \texttt{DynamicSystem} has to be chosen as frame of reference. Then, the motion of the frame of kinematics and so also the \texttt{RigidBody} with respect to this frame of reference is defined by the individual generalised coordinates of the \texttt{RigidBody} or its constrained relative motion. Both absolute (if the frame of reference belongs to a \texttt{DynamicSystem}) and relative (if the frame of reference belongs to another \texttt{RigidBody}) kinematical structures are canonically given by this frame recursion. The drawback of this general description is a time-dependent mass-matrix also in the absolute kinematics case.\par
Important settings: 
\begin{itemize}
\item[] \texttt{setMass}
\item[] \texttt{setInertiaTensor}\\
    is defined with respect to \texttt{"C"}, if no other \texttt{Frame} is given as second argument
\item[] \texttt{setFrameOfReference}\\
    one possibility to define initial values
\item[] \texttt{setFrameForKinematics}
\item[] \texttt{setOpenMBVRigidBody}\\
    enabling visualisation for \OpenMBV{}
\end{itemize}
Kinematics can be defined individually according to
\begin{align*}
        \rs{_B}[_{O'P}]{\vr} &= \rs{_B}[_{O'P}]{\vr}({\vq}_{\text{rel}}^{(i)},\,t)\,,\\
        \vA_{BK} &= \vA_{BK}({\vq}_{\text{rel}}^{(i)},\,t)\,,\\
        \rs{_B}[_{O'P,\text{rel}}]{\vv} &=  \rs{_B}[_{P,\text{rel}}]{\vJ} \,\vu_\text{rel}^{(i)} + \rs{_B}[_{P,\text{rel}}]{\viota}  \, \\
        \rs{_B}[_{BK}]{\vomega} &= \rs{_B}[_{R,\text{rel}}]{\vJ} \,\vu_\text{rel}^{(i)} + \rs{_B}[_{R,\text{rel}}]{\viota} \\
        \frac{\mathrm{d}}{\mathrm{d} t}\left(\rs{_B}[_{O'P,\text{rel}}]{\vv}\right) &= \rs{_I}[_{P,\text{rel}}]{\vJ} \,\dot{\vu}_\text{rel}^{(i)} +\frac{\mathrm{d}}{\mathrm{d} t}\left(\rs{_B}[_{P,\text{rel}}]{\vJ} \right)\,\vu_\text{rel}^{(i)} + \frac{\mathrm{d}}{\mathrm{d} t}\left(\rs{_B}[_{P,\text{rel}}]{\viota} \right)  \,,\\ 
        \frac{\mathrm{d}}{\mathrm{d} t}\left(\rs{_B}[_{BK}]{\vomega}\right) &= \rs{_I}[_{R,\text{rel}}]{\vJ} \,\dot{\vu}_\text{rel}^{(i)} +\frac{\mathrm{d}}{\mathrm{d} t}\left(\rs{_B}[_{R,\text{rel}}]{\vJ} \right)\,\vu_\text{rel}^{(i)} + \frac{\mathrm{d}}{\mathrm{d} t}\left(\rs{_B}[_{P,\text{rel}}]{\viota} \right)  \,. 
\end{align*}
using functions such that
\begin{itemize}
\item[] \texttt{setTranslation}
\item[] \texttt{setRotation}
\item[] \texttt{setJacobianOfTranslation}
\item[] \texttt{setJacobianOfRotation}
\item[] \texttt{setDerivativeOfJacobianOfTranslation}
\item[] \texttt{setDerivativeOfJacobianOfRotation}
\item[] \texttt{setGuidingVelocityOfTranslation}
\item[] \texttt{setGuidingVelocityOfRotation}
\item[] \texttt{setDerivativeOfGuidingVelocityOfTranslation}
\item[] \texttt{setDerivativeOfGuidingVelocityOfRotation}
\end{itemize}
A body is defined with respect to its generalised coordinates and velocities, contacts between contours and joints between frames may be rigid or flexible also including friction. The definition of loads might include arbitrary functional descriptions.

\paragraph{Flexible Bodies}
The equations of motion of a \texttt{FlexibleBody} is at the moment always derived with respect to a stationary frame. So, flexible bodies can only be used as root but not as leave in a recursive tree structure. The following flexible bodies are available. 

\begin{itemize}
%\item \emph{BodyFlexible1s01Torsion}
%\item \emph{BodyFlexible1s21ANCF} 2D-Balken mit Absolute Nodal Coordinate Formulation
\item[] \texttt{BodyFlexible1s21RCM}\\
  planar beam using redundant coordinate methode with three coordinates per finite element node, translation  $x$, $y$ and rotation $\gamma$, as well as two additional bending deflections $c_1$, $c_2$
\item[] \texttt{BodyFlexible1s33RCM}\\
  spatial beam using redundant coordinate methode with six coordinates per finite element node, translation  $x$, $y$, $z$ and reversed Cardan rotation $\alpha$, $\beta$, $\gamma$, as well as four additional bending deflections $c_1$, $c_2$, $c_3$, $c_4$
%\item \emph{BodyFlexible1s23BTA} Biege-Torsions-Welle (5-Koordinaten pro Knoten $\alpha$, $y$, $\gamma$, $z$, $\beta$ im jeweils mit $\alpha$ mitdrehenden KOSY)
%\item \emph{BodyFlexibleLinearExternal}
\end{itemize}

\subsubsection{LinkMechanics}
Mechanical links represent interconnections between mechanical bodies.

\paragraph{Actuators}
An \texttt{Actuator} connects two frames using a predefined control function.

\paragraph{Joints}
\texttt{Joint}s connect two frames with the force laws depending on the ideal normal relative kinematics. The constitutive law has to be chosen for the calculation of the force parameter. 
Important settings: \emph{setForceDirection}, \emph{setMomentDirection}, \emph{setForceLaw} (acceleration level), \emph{setImpactForceLaw} (velocity level)

\paragraph{Contacts and Impacts}
Contacts and impacts are managed by \texttt{Contact}.
Important settings: \emph{setContactForceLaw}, \emph{setContactImpactLaw}, \emph{setFrictionForceLaw}, \emph{setFrictionImpactLaw}, \emph{setContactKinematics} \par 
The relative kinematics is defined between \texttt{Contour} classes. Thereby kinematically there might be a finite number of possible contact points; for the evaluation of force laws a decision rule has to be implemented. On velocity level the contact kinematics is independent of the specific contour. For the calculations on position level the following contours are available.
\begin{itemize}
\item[] \texttt{CircleHollow}\\
    one dimensional sphere with contact from inside 
\item[] \texttt{CircleSolid}\\
    one dimensional sphere with contact from outside 
\item[] \texttt{FlexibleBand}\\
    flexible contour describing a band in a certain distance and direction of a neutral fibre
\item[] \texttt{Frustum}\\
    frustum with its axis given by the second column of the contour reference frame
\item[] \texttt{Line}\\
    affine one dimensional space 
\item[] \texttt{Plane}\\
    affine two dimensional surface
\item[] \texttt{Point}\\
    most primitive rigid contour
\item[] \texttt{Sphere}\\
    two dimensional sphere
\end{itemize}

Available contact kinematics on position level:
\begin{itemize}
\item[] \texttt{CircleSolidLine}
\item[] \texttt{PointLine}
\item[] \texttt{PointFrustum}
\item[] \texttt{PointPlane}
\item[] \texttt{PointFlexibleBand}
\item[] \texttt{SpherePlane}
\end{itemize}

\paragraph{Constitutive Laws}
Concerning the constitutive laws it is distinguished between contact laws on acceleration and impact laws on velocity level. Further, both flexible and rigid laws in normal and tangential direction are available.\footnote{Modelling hint: There are contradictions between energy conservation in normal direction and dissipation due to friction when combining these features.})\par

\paragraph{Conventions}
For modelling own contact kinematics and constitutive laws some conventions are important.
\begin{itemize}
\item contact kinematics\\
    \texttt{updateg} should define the normal distance, the possible contact locations and trihedral orientations, \texttt{updatewb} are nonlinear kinematic terms
\item accompanying contour trihedral\\
    the first column is the outward pointing normal, 
\end{itemize}

\subsubsection{Integration Schemes}
Available integration schemes:
\begin{itemize}
\item[] \texttt{DOPRI5Integrator}\\
    Dormand-Prince one-step integration scheme of order 5 for nonstiff ODE with step size control
\item[] \texttt{RADAU5Integrator}\\
    one-step integration scheme of order 5 for stiff ODE with step size control
\item[] \texttt{TimeSteppingIntegrator}\\
    one-step semi-implicit integration scheme of order 1 for nonstiff MDE
\item[] \texttt{ThetaTimeSteppingIntegrator}\\
    one-step integration scheme of order 1 for nonstiff with $\Theta=0$ and stiff with $\Theta\in\left(0,1\right] $MDE
\end{itemize}
%DAEs behandeln \emph{RADAU5DAEIntegrator}, \emph{DASKRIntegrator} und \emph{DASPKIntegrator}. Dar\"uberhinaus gibt es noch \emph{RKSuite}, \emph{LSODAR} (Mehrschrittverfahren steif/nicht steif) und \emph{LSODE}.  oder der allgemeinere \emph{ThetaTimeSteppingIntegrator} mit konstanter Schrittweitenvorgabe angewendet werden. \emph{TimeSteppingSSCIntegrator} implementiert für den semi-impliziten Fall eine Schrittweitensteuerung und \emph{DAETSIntegrator} liefert eine Kopplung zwischen TimeStepping und Dassl. Bei letzteren muss der Befehl \texttt{setSolver} vor der Initialisierung des MBS durchgef\"uhrt werden. Folgende M\"oglichkeiten stehen zur Wahl:

\subsection{Program Flow}
Conceptionally the program flow is defined by the election of the integration scheme. It can always be stopped using \texttt{Ctrl-C} also enforcing the closing of the plot functionality. With
\begin{verbatim}
kill -USR2 <PID of simulation thread>
\end{verbatim}
a flush of the plot routine is asked for.

\subsubsection{Timestepping Integration}
Timestepping integration solves the whole equations of the system including the contacts on velocity level with fixed time step size. In detail one has the following work flow.
\begin{enumerate}
\item $\text{\texttt{DS::plot}}\left(t,\vq,\vu\right)$
\item $\vq\leftarrow\vq+\text{\texttt{DS::deltaq}}\left(t,\vq,\vu\right)$
\item $t\leftarrow t+\Delta t$
\item $\text{\texttt{DS::update}}\left(t,\vq,\vu\right)$
    \begin{enumerate}
    \item[]\texttt{DS::updateStateDependentVariables}\\
      update variables depending on the generalised state and the structure of the system with one independent group and several trees
    \item[]\texttt{DS::updateg}
      \begin{itemize}
      \item update of the relative position kinematics independent of the system structure using the order
      \begin{align*}
        \text{\texttt{Link}}\rightarrow\text{\texttt{LinkMechanics}}\rightarrow\text{\texttt{Joint}, \texttt{Contact}, \texttt{Actuator}}\rightarrow\text{\texttt{ContactKinematics}}
      \end{align*}
      \item several contacts points are possible from the kinematical point of view, whereby the maximum number is calculated in \texttt{ContactKinematics}\\
      \item conventions in the contact frame matrix:
        \begin{itemize}
        \item frames are cartesian
        \item first column is the outpointing normal
        \item second column sign is different for the two contacting bodies 
        \end{itemize}
      \end{itemize}
    \item[]\texttt{DS::checkActiveg}
      \begin{itemize}
      \item determine the state of the relative kinematics concerning the activity of links
      \item redefine global memory references using indices and indents
      \end{itemize}
    \item[]\texttt{DS::updategd}
      \begin{itemize}
      \item update of the relative velocity kinematics independent of the system structure
      \item can be done in the child classes of \texttt{LinkMechanics}
      \end{itemize}
    \item[]\texttt{DS::updateT}\\
      updates the linear transformation matrix $\dot{\vq}=\vT\vu$ independent of the system structure
    \item[]\texttt{updateJacobians}\\
      updates the \textsc{Jacobians} for projecting forces in generalised directions dependent on the system structure
    \item[]\texttt{updateh}\\
      updates the right hand sides with the possibility to account for internal forces of \texttt{objects} and external forces of \texttt{links} independent of the system structure
    \item[]\texttt{updateM}\\
      updates the mass matrix independent of the system structure
    \item[]\texttt{facLLM}
      \begin{itemize}
      \item computes the \textsc{Cholesky} decomposition of the mass matrix dependent on the system structure
      \item \texttt{group} calculates the matrix inverse locally per object
      \item \texttt{tree} calculates the matrix inverse globally
      \end{itemize}
    \item[]\texttt{updateW}\\
      updates the \textsc{Jacobian} between in general set-valued \texttt{link}-force parameters and generalised coordinates
    \item[]\texttt{updateV}
      \begin{itemize}
      \item the decomposition of the in general set-valued \texttt{link}-forces
      \begin{align*}
      \vW\vlambda=\vW_N\vlambda_N+\vW_T\vlambda_T
      \end{align*}
      in a normal and tangential part allows to separate the single-valued slip case
      \item for affected \texttt{links} it is
      \begin{align*}
      \tilde{\vW}\tilde{\vlambda}=\left(\tilde{\vW}_N+\mu\tilde{\vW}_T\right)\tilde{\vlambda}_N=\tilde{\vV}\tilde{\vlambda}_N\ .
      \end{align*}
      \item altogether this is a reduction of the set-valued equations being expressed by the projection
      \begin{align*}
      \vV\vlambda^{*}\ .
      \end{align*}
      \end{itemize}
    \item[]\texttt{updateG}
      \begin{itemize}
      \item the force action matrix
      \begin{align*}
      \vG=\vW^T\vM^{-1}\vV
      \end{align*}
      must be calculated by the most global view, namely the \texttt{DynamicSystemSolver}
      \item the size of $\vG$ is reduced due to the introduction of $\vV$ but is non-symmetric
      \item for a time-stepping scheme it is $\vV=\vW$
      \end{itemize}
    \end{enumerate}
\item $\text{\texttt{DS::solveImpacts}}\left(t,\vq,\vu\right)$
    \begin{itemize}
    \item the constrained equations are solved on velocity level using sparse matrix structures (cf.~\cite[MKL sparse matrix storage format]{Intel08})
    \item block structures are not evaluated
    \end{itemize}
\item $\vu\leftarrow\vu+\text{\texttt{DS::deltau}}$
\item $\vx\leftarrow\vx+\text{\texttt{DS::deltax}}$
\item \texttt{DS::projectGeneralizedPositions}
\end{enumerate}

\subsubsection{Event-Driven Integration}
Currently, \texttt{LSODAR} is the only event-driven integrator with automatic switch between stiff and non-stiff equations.
\begin{enumerate}
\item \texttt{DS::computeInitialCondition}\\
    checks for system configuration and creates the necessary contact container
\item $\text{\texttt{DS::plot}}\left(t,\vq\right)$
\item \texttt{DLSODAR} 
    \begin{enumerate}
    \item[]$\text{\texttt{DS::zdot}}\left(t,\vq,\vu\right)$ is available for standard and inverse kinetics calculations
      \begin{itemize}
      \item \texttt{wb} means $\bar{w}$ and describes the acceleration terms in the constraint kinematics
      \item \texttt{computeConstraintForces} uses a least square algorithm to solve the Delassus equations, assume $Ax=b$ with a $m\times n$ full-rank matrix $A$, then there are two cases
        \begin{itemize}
        \item $m\geq n$ (skinny) can always be solved by $\left\|Ax-b\right\|\rightarrow\min$ and so by SVD\\
          analytically the solution is given by the normal equations $x=\left(A^TA\right)^{-1}A^Tb$
        \item $m<n$ (fat) has an infinite dimensional solution space, one has to pick one solution\\
          $\left\|x\right\|\rightarrow\min,\ Ax=b$ which is analytically given by $x=A^T\left(A^TA\right)^{-1}b$, again numerically a SVD solves the problem most efficiently
        \end{itemize}
      \end{itemize}
    \item[]\texttt{DS::getsv} the stop vector defines the root function concerning contacts and stick-slip-transitions for the DAE solver
      \begin{itemize}
      \item it can be only set by \texttt{Link}
      \item contains kinematics for not-active directions and kinetics for active directions
      \item the last entry is used for position and velocity projections
      \end{itemize}
    \end{enumerate}
\item \texttt{DS::shift} is invoked, if there is a sign change in the stop vector
    \begin{itemize}
      \item drift compensation if indicated by stop vector
      \item project to slighly positive gaps to avoid instantaneous appearance of new shift point
      \item[] \texttt{updateCondition} should impact or differential equations be solved, after earlier mentioned reconfiguring
      \item case studies
        \begin{itemize}
        \item[] \texttt{impact} has highest priority and changes overall configuration
        \item[] \texttt{impact} requires \texttt{D::checkAllgd} because of possible slip-stick transition
        \item no difference between $\Lambda$ and $\lambda$
        \item \texttt{gdn} means $\dot{g}^{+}$
        \item[] \texttt{impact} involves new configuration and so also the equations of motion have to be solved
        \item \texttt{checkActivegdd} has to be done with the same tolerance like in the nonlinear equations solver
        \item[] \texttt{gActive} means a contact is closed
        \item[] \texttt{gdActive} means a contact remains closed
        \end{itemize}
    \end{itemize}
\end{enumerate}

%%------------------------------------------------------------ SUBSECTION --
\subsection{Plot Routines}\label{sec:plot}

\subsubsection{Usage}
The result of a simulation with \MBSim{} are a \texttt{mbsim.h5} file for plot analysis as well as \texttt{ombv.h5} and \texttt{ombv.xml} files for visualisation. Additionally there is information concerning the integrator in \texttt{*.plt} and \texttt{*.sum} files; for visualisation \texttt{*.iv} files might appear.\\
For getting data from \MBSim{} a \HDF{} wrapper is used. Viewing the multibody system parts can be done with
\begin{verbatim}
    h5lsserie <h5-file>
\end{verbatim}
Several possible options are explained by typing \texttt{-h}:
\begin{enumerate}
\item[\texttt{-d}] shows the description of the data to plot\\
\item[\texttt{-l}] shows the column labels of the data to plot\\
\item[\texttt{-f}] follows external links in a set of \HDF{}-files to avoid redundant data (\HDF{} is possible per DynamicSystem)
\end{enumerate}
The specific names in \HDF{} format are specialised by reading from right to left. The url to specific data is given by a path and can be used in
\begin{verbatim}
    h5dumpserie <path>
\end{verbatim}
The column one is interested in is declared using a colon. Also several columns can be appended, whereby shorter ones are enlarged by \texttt{nan} entries. Altogether, it is possible to use the dump by
\begin{verbatim}
    gnuplot "<dump" u *:* w l
\end{verbatim}
or in \textsf{MatLab} by
\begin{verbatim}
    h5dump('<path>')
\end{verbatim}
A convenient tool for analysing data is given by
\begin{verbatim}
    h5plotserie <h5-file>
\end{verbatim}
The usage is quite canonic and documented in the online help. Interesting features are
\begin{itemize}
\item superimposing graphs by \texttt{<shift>}
\item plotting labels by \texttt{<ctrl>}
\item disabling graphs by double click
\end{itemize}

\subsubsection{Implementation}
In \MBSim{} plotting is done using \texttt{plotFeatures} being defined in \texttt{element.h} and set in \texttt{dynamic\_system\_solver.cc}. One plot-file comprises time-series of rowvectors with the same data type in all entries.

