<?xml version="1.0" encoding="UTF-8"?>
<xs:schema targetNamespace="http://www.mbsim-env.de/MBSim"
  elementFormDefault="qualified"
  attributeFormDefault="unqualified"
  xmlns="http://www.mbsim-env.de/MBSim"
  xmlns:pv="http://www.mbsim-env.de/MBXMLUtils"
  xmlns:ombv="http://www.mbsim-env.de/OpenMBV"
  xmlns:xml="http://www.w3.org/XML/1998/namespace"
  xmlns:xs="http://www.w3.org/2001/XMLSchema">

  <xs:annotation>
    <xs:documentation xml:lang="de" xmlns="">
      MBSim ist ein Simulationstool zur Analyse von dynamischen Systemen. Sein Ursprung liegt 
      in der Modellierung von nichtglatten Mehrkörpersystemen, woraus sich auch der Name "MBSim" ableitet.
      Der mathematische Hintergrund wurde in den letzten Jahrzehnten am Lehrstuhl für Angewandte Mechanik der
      Technischen Universität München entwickelt. Eine gute Zusammenfassung ist die Doktorarbeit und das Vorlesungsskript von Martin Förg [1,2]. Roland Zander
      diskutiert Erweiterungen hinsichtlich flexibler Körper [3]. In [4] erhält man einen Überblick über die Forschung am
      Lehrstuhl für Angewandte Mechanik auf dem Gebiet der
      nichtglatten Mechanik. Dort sind auch Simulationsergebnisse von akademischen und
      industriellen Beispielen zu finden. Erweiterungen bezüglich Hydraulik und Regelungstechnik sowie
      Parallelisierung und Co-Simulation sind einzigartig im Bereich der nichtglatten Dynamik.
      <ol>
        <li>Martin Förg. <i>Mehrkörpersysteme mit mengenwertigen Kraftgesetzen - Theorie und Numerik.</i>
          PhD thesis, TU München, 2007.</li>
        <li>Martin Förg. <i>Mehrkörpersimulation - Vorlesungsskript</i>, München, 2006, Version 19.06.2008.</li>
        <li>Roland Zander. <i>Flexible Multibody Systems with Set-Valued Force Laws.</i> PhD thesis,
          TU München, 2008.</li>
        <li>Roland Zander, Thorsten Schindler, Markus Friedrich, Robert Huber, Martin Förg, and Heinz
          Ulbrich. <i>Non-smooth dynamics in academia and industry: recent work at TU München.</i>
          Acta Mechanica, 195:167–183, 2008.</li>
      </ol>
    </xs:documentation>
  </xs:annotation>

  <xs:import namespace="http://www.mbsim-env.de/MBXMLUtils"/>

  <xs:import namespace="http://www.mbsim-env.de/OpenMBV"/>

  <xs:group name="OpenMBVColoredBodyParameters">
    <xs:sequence>
      <xs:element name="diffuseColor" type="pv:nounitVector" minOccurs="0"/>
      <xs:element name="transparency" type="pv:nounitScalar" minOccurs="0"/>
      <xs:element name="pointSize" type="pv:lengthScalar" minOccurs="0"/>
      <xs:element name="lineWidth" type="pv:lengthScalar" minOccurs="0"/>
    </xs:sequence>
  </xs:group>

  <xs:group name="OpenMBVDynamicColoredBodyParameters">
    <xs:sequence>
      <xs:group ref="OpenMBVColoredBodyParameters"/>
      <xs:element name="colorRepresentation" type="pv:stringFullEval" minOccurs="0"/>
      <xs:element name="minimalColorValue" type="pv:nounitScalar" minOccurs="0"/>
      <xs:element name="maximalColorValue" type="pv:nounitScalar" minOccurs="0"/>
    </xs:sequence>
  </xs:group>

  <xs:group name="OpenMBVFrameParameters">
    <xs:sequence>
      <xs:group ref="OpenMBVColoredBodyParameters"/>
      <xs:element name="size" type="pv:lengthScalar" minOccurs="0">
        <xs:annotation>
          <xs:documentation xml:lang="de" xmlns="">
            Länge der Achsen des KOS.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="offset" type="pv:nounitScalar" minOccurs="0">
        <xs:annotation>
          <xs:documentation xml:lang="de" xmlns="">
            Relative Verschiebung der Achsen (0=Achsenkreuz, 1=Rechtssystem).
          </xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:sequence>
  </xs:group>

  <xs:group name="OpenMBVArrowParameters">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
      Darstellung eines Vektorpfeils.
      Auswahl der Farbdarstellung:
      <ul>
        <li>none: keine</li>
        <li>absoluteValue: Absolutwert des Vektors</li>
      </ul>
    </xs:documentation></xs:annotation>
    <xs:sequence>
      <xs:group ref="OpenMBVDynamicColoredBodyParameters"/>
      <xs:element name="scaleLength" type="pv:nounitScalar" minOccurs="0"/>
      <xs:element name="scaleSize" type="pv:nounitScalar" minOccurs="0"/>
      <xs:element name="type" type="pv:stringFullEval" minOccurs="0"/>
      <xs:element name="referencePoint" type="pv:stringFullEval" minOccurs="0"/>
    </xs:sequence>
  </xs:group>

  <xs:group name="OpenMBVInteractionArrowParameters">
    <xs:sequence>
      <xs:group ref="OpenMBVArrowParameters"/>
      <xs:element name="sideOfInteraction" type="pv:stringFullEval" minOccurs="0">
        <xs:annotation><xs:documentation xml:lang="de" xmlns="">
          Auswahl des Schnittufers, an dem die Schnittreaktionen angezeigt werden sollen.
          <ul>
            <li>action: actio Schnittufer</li>
            <li>reaction: reactio Schnittufer</li>
            <li>both: beide Schnittufer</li>
          </ul>
        </xs:documentation></xs:annotation>
      </xs:element>
    </xs:sequence>
  </xs:group>

  <xs:group name="OpenMBVLineParameters">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
      Darstellung einer Linie.
    </xs:documentation></xs:annotation>
    <xs:sequence>
      <xs:group ref="OpenMBVColoredBodyParameters"/>
      <xs:element name="length" type="pv:lengthScalar" minOccurs="0"/>
    </xs:sequence>
  </xs:group>

  <xs:group name="OpenMBVPlaneParameters">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
      Darstellung einer Ebene.
    </xs:documentation></xs:annotation>
    <xs:sequence>
      <xs:group ref="OpenMBVColoredBodyParameters"/>
      <xs:element name="length" type="pv:lengthVector" minOccurs="0"/>
    </xs:sequence>
  </xs:group>

  <xs:group name="OpenMBVCoilSpringParameters">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
      Darstellung einer Spiralfeder.
      Auswahl der Farbdarstellung:
      <ul>
        <li>none: keine</li>
        <li>deflection: Federweg</li>
        <li>tensileForce: Zugkraft</li>
        <li>compressiveForce: Druckkraft</li>
        <li>absoluteForce: Absolute Kraft</li>
      </ul>
    </xs:documentation></xs:annotation>
    <xs:sequence>
      <xs:group ref="OpenMBVDynamicColoredBodyParameters"/>
      <xs:element name="numberOfCoils" type="pv:nounitScalar" minOccurs="0"/>
      <xs:element name="springRadius" type="pv:lengthScalar" minOccurs="0"/>
      <xs:element name="crossSectionRadius" type="pv:lengthScalar" minOccurs="0"/>
      <xs:element name="nominalLength" type="pv:lengthScalar" minOccurs="0"/>
      <xs:element name="type" type="pv:stringFullEval" minOccurs="0"/>
    </xs:sequence>
  </xs:group>

  <xs:group name="OpenMBVPlanarContourParameters">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
      Darstellung einer ebenen Kontur.
    </xs:documentation></xs:annotation>
    <xs:sequence>
      <xs:group ref="OpenMBVColoredBodyParameters"/>
      <xs:element name="nodes" type="pv:nounitVector" minOccurs="0"/>
      <xs:element name="filled" type="pv:booleanFullEval" minOccurs="0"/>
    </xs:sequence>
  </xs:group>

  <xs:group name="OpenMBVSpatialContourParameters">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
      Darstellung einer räumlichen Kontur.
    </xs:documentation></xs:annotation>
    <xs:sequence>
      <xs:group ref="OpenMBVColoredBodyParameters"/>
      <xs:element name="etaNodes" type="pv:nounitVector" minOccurs="0"/>
      <xs:element name="xiNodes" type="pv:nounitVector" minOccurs="0"/>
    </xs:sequence>
  </xs:group>

  <!-- A reference to a Frame at the same hierarchy -->
  <xs:simpleType name="CurrentFrameReferenceType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Definiert eine Pfadangabe zu einem <a class="link" href="mbsim:Frame"><span class="_element">&lt;Frame&gt;</span></a> im aktuellen Kontext.
        Gültige Werte sind <code>Frame[X]</code>, wobei <code>X</code> den <a class="link" href="pv:stringPartialEval">Element-Namen</a> des
        zu referenzierenden Frames darstellt.
    </xs:documentation></xs:annotation>
    <xs:restriction base="pv:stringPartialEval"/>
  </xs:simpleType>

  <!-- A reference to a Frame at the parent -->
  <xs:simpleType name="ParentFrameReferenceType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Definiert eine Pfadangabe zu einem <a class="link" href="mbsim:Frame"><span class="_element">&lt;Frame&gt;</span></a> des Vorgängers
        des aktuellen Kontext (Vorgänger in der Hierarchieebene). Gültige Werte sind <code>../Frame[X]</code>, wobei <code>X</code> den
        <a class="link" href="pv:stringPartialEval">Element-Namen</a> des Frames des Vorgangers darstellt.
        <p>Die Hierarchieebenen entsprechend prinzipiell den Ebenen von XML. Als neue Hierarchieebenen zählen jedoch NUR
          Elemente die mit einem Großbuchstaben beginnen.</p>
    </xs:documentation></xs:annotation>
    <xs:restriction base="pv:stringPartialEval"/>
  </xs:simpleType>

  <!-- A reference to a Frame somewhere in the hierarchy -->
  <xs:simpleType name="FrameReferenceType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Definiert eine Pfadangabe zu einem <a class="link" href="mbsim:Frame"><span class="_element">&lt;Frame&gt;</span></a> an beliebiger
        Position im Modell. Gültige Werte sind z.B. <code>../../Group[X]/Group[X]/Object[Y]/Frame[Z]</code>, wobei <code>X</code>,
        <code>Y</code> und <code>Z</code> geweils einen <a class="link" href="pv:stringPartialEval">Element-Namen</a> darstellt. Der Pfadteil
        <code>..</code> kann dabei beliebig oft auftreten und wechselt eine Hierarchieebene nach oben. Der Pfadteil
        <code>Group</code> kann beliebig oft oder nicht auftreten und wechselt eine Hierarchieebene tiefer in die
        <code>Group</code> mit dem Element-Namen <code>X</code>. Als letzter Pfadteil kann der <code>Frame Z</code> des
        <code>Object's Y</code> ausgewählt werden oder der <code>Frame Z</code> der <code>Group</code> wenn die Angabe von
        <code>Object</code> weggelassen wird. Alternativ kann die Pfadangabe anstatt mit <code>..</code> mit <code>/</code> beginnen,
        in diesem Fall beginnt die Referenzierung beim obersten Element
        (<a class="link" href="mbsim:DynamicSystemSolver"><code>DynamicSystemSolver</code></a>) des Modells.
        <p>Die Hierarchieebenen entsprechend prinzipiell den Ebenen von XML. Als neue Hierarchieebenen zählen jedoch NUR
          Elemente die mit einem Großbuchstaben beginnen.</p>
    </xs:documentation></xs:annotation>
    <xs:restriction base="pv:stringPartialEval"/>
  </xs:simpleType>

  <!-- A reference to a Contour somewhere in the hierarchy -->
  <xs:simpleType name="ContourReferenceType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Definiert eine Pfadangabe zu einer <a class="link" href="mbsim:Contour"><span class="_element">&lt;Contour&gt;</span></a> an beliebiger
        Position im Modell. Gültige Werte sind z.B. <code>../../Group[X]/Group[X]/Object[Y]/Contour[Z]</code>, wobei <code>X</code>,
        <code>Y</code> und <code>Z</code> geweils einen <a class="link" href="pv:stringPartialEval">Element-Namen</a> darstellt. Der Pfadteil
        <code>..</code> kann dabei beliebig oft auftreten und wechselt eine Hierarchieebene nach oben. Der Pfadteil
        <code>Group</code> kann beliebig oft oder nicht auftreten und wechselt eine Hierarchieebene tiefer in die
        <code>Group</code> mit dem Element-Namen <code>X</code>. Als letzter Pfadteil kann die <code>Contour Z</code> des
        <code>Object's Y</code> ausgewählt werden oder die <code>Contour Z</code> der <code>Group</code> wenn die Angabe von
        <code>Object</code> weggelassen wird. Alternativ kann die Pfadangabe anstatt mit <code>..</code> mit <code>/</code> beginnen,
        in diesem Fall beginnt die Referenzierung beim obersten Element
        (<a class="link" href="mbsim:DynamicSystemSolver"><code>DynamicSystemSolver</code></a>) des Modells.
        <p>Die Hierarchieebenen entsprechend prinzipiell den Ebenen von XML. Als neue Hierarchieebenen zählen jedoch NUR
          Elemente die mit einem Großbuchstaben beginnen.</p>
    </xs:documentation></xs:annotation>
    <xs:restriction base="pv:stringPartialEval"/>
  </xs:simpleType>

  <!-- A reference to an Object somewhere in the hierarchy -->
  <xs:simpleType name="ObjectReferenceType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Definiert eine Pfadangabe zu einem <a class="link" href="mbsim:Object"><span class="_element">&lt;Object&gt;</span></a> an beliebiger
        Position im Modell. Gültige Werte sind z.B. <code>../../Group[X]/Group[X]/Object[Y]</code>, wobei <code>X</code> und
        <code>Y</code> geweils einen <a class="link" href="pv:stringPartialEval">Element-Namen</a> darstellt. Der Pfadteil <code>..</code>
        kann dabei beliebig oft auftreten und wechselt eine Hierarchieebene nach oben. Der Pfadteil <code>Group</code>
        kann beliebig oft oder nicht auftreten und wechselt eine Hierarchieebene tiefer in die <code>Group</code> mit dem
        Element-Namen <code>X</code>. Als letzter Pfadteil wird das <code>Object Y</code> ausgewählt. Alternativ kann die
        Pfadangabe anstatt mit <code>..</code> mit <code>/</code> beginnen, in diesem Fall beginnt die Referenzierung beim
        obersten Element (<a class="link" href="mbsim:DynamicSystemSolver"><code>DynamicSystemSolver</code></a>) des Modells.
        <p>Die Hierarchieebenen entsprechend prinzipiell den Ebenen von XML. Als neue Hierarchieebenen zählen jedoch NUR
          Elemente die mit einem Großbuchstaben beginnen.</p>
    </xs:documentation></xs:annotation>
    <xs:restriction base="pv:stringPartialEval"/>
  </xs:simpleType>

  <!-- A reference to a Link somewhere in the hierarchy -->
  <xs:simpleType name="LinkReferenceType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Definiert eine Pfadangabe zu einem <a class="link" href="mbsim:Link"><span class="_element">&lt;Link&gt;</span></a> an beliebiger
        Position im Modell. Gültige Werte sind z.B. <code>../../Group[X]/Group[X]/Link[Y]</code>, wobei <code>X</code> und
        <code>Y</code> geweils einen <a class="link" href="pv:stringPartialEval">Element-Namen</a> darstellt. Der Pfadteil <code>..</code>
        kann dabei beliebig oft auftreten und wechselt eine Hierarchieebene nach oben. Der Pfadteil <code>Group</code>
        kann beliebig oft oder nicht auftreten und wechselt eine Hierarchieebene tiefer in die <code>Group</code> mit dem
        Element-Namen <code>X</code>. Als letzter Pfadteil wird das <code>Link Y</code> ausgewählt. Alternativ kann die
        Pfadangabe anstatt mit <code>..</code> mit <code>/</code> beginnen, in diesem Fall beginnt die Referenzierung beim
        obersten Element (<a class="link" href="mbsim:DynamicSystemSolver"><code>DynamicSystemSolver</code></a>) des Modells.
        <p>Die Hierarchieebenen entsprechend prinzipiell den Ebenen von XML. Als neue Hierarchieebenen zählen jedoch NUR
          Elemente die mit einem Großbuchstaben beginnen.</p>
    </xs:documentation></xs:annotation>
    <xs:restriction base="pv:stringPartialEval"/>
  </xs:simpleType>

  <!-- A reference to a Contact somewhere in the hierarchy -->
  <xs:simpleType name="ContactReferenceType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Definiert eine Pfadangabe zu einem <a class="link" href="mbsim:Contact"><span class="_element">&lt;Contact&gt;</span></a> an beliebiger
        Position im Modell. Gültige Werte sind z.B. <code>../../Group[X]/Group[X]/Contact[Y]</code>, wobei <code>X</code> und
        <code>Y</code> geweils einen <a class="link" href="pv:stringPartialEval">Element-Namen</a> darstellt. Der Pfadteil <code>..</code>
        kann dabei beliebig oft auftreten und wechselt eine Hierarchieebene nach oben. Der Pfadteil <code>Group</code> kann
        beliebig oft oder nicht auftreten und wechselt eine Hierarchieebene tiefer in die <code>Group</code> mit dem
        Element-Namen <code>X</code>. Als letzter Pfadteil wird der <code>Contact Y</code> ausgewählt. Alternativ kann die
        Pfadangabe anstatt mit <code>..</code> mit <code>/</code> beginnen, in diesem Fall beginnt die Referenzierung beim
        obersten Element (<a class="link" href="mbsim:DynamicSystemSolver"><code>DynamicSystemSolver</code></a>) des Modells.
        <p>Die Hierarchieebenen entsprechend prinzipiell den Ebenen von XML. Als neue Hierarchieebenen zählen jedoch NUR
          Elemente die mit einem Großbuchstaben beginnen.</p>
    </xs:documentation></xs:annotation>
    <xs:restriction base="pv:stringPartialEval"/>
  </xs:simpleType>

  <!-- A reference to a Constraint somewhere in the hierarchy -->
  <xs:simpleType name="ConstraintReferenceType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Definiert eine Pfadangabe zu einem <a class="constraint" href="mbsim:Constraint"><span class="_element">&lt;Constraint&gt;</span></a> an beliebiger
        Position im Modell. Gültige Werte sind z.B. <code>../../Group[X]/Group[X]/Constraint[Y]</code>, wobei <code>X</code> und
        <code>Y</code> geweils einen <a class="constraint" href="pv:stringPartialEval">Element-Namen</a> darstellt. Der Pfadteil <code>..</code>
        kann dabei beliebig oft auftreten und wechselt eine Hierarchieebene nach oben. Der Pfadteil <code>Group</code>
        kann beliebig oft oder nicht auftreten und wechselt eine Hierarchieebene tiefer in die <code>Group</code> mit dem
        Element-Namen <code>X</code>. Als letzter Pfadteil wird das <code>Constraint Y</code> ausgewählt. Alternativ kann die
        Pfadangabe anstatt mit <code>..</code> mit <code>/</code> beginnen, in diesem Fall beginnt die Referenzierung beim
        obersten Element (<a class="constraint" href="mbsim:DynamicSystemSolver"><code>DynamicSystemSolver</code></a>) des Modells.
        <p>Die Hierarchieebenen entsprechend prinzipiell den Ebenen von XML. Als neue Hierarchieebenen zählen jedoch NUR
          Elemente die mit einem Großbuchstaben beginnen.</p>
    </xs:documentation></xs:annotation>
    <xs:restriction base="pv:stringPartialEval"/>
  </xs:simpleType>

  <xs:element name="Element" abstract="true" type="ElementType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        <p>Abstraktes (Top-Level) Basis Element von MBSim.</p>
        <p>Das Attribut <code>name</code> gibt den Namen des Elements an. Dieser Name wird für die Referenzierung des
          Elements benötig. Die Plotausgaben verwenden ebenfalls diese Namen.</p>
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="ElementType">
    <xs:sequence>
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:element name="plotFeature">  
          <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Definiert die Plotfeatures für dieses Element.
          </xs:documentation></xs:annotation>
          <xs:complexType>
            <xs:simpleContent>
              <xs:extension base="pv:booleanFullEval">
                <xs:attribute name="value" type="pv:qnamePartialEval" use="required"/>
              </xs:extension>
            </xs:simpleContent>
          </xs:complexType> 
        </xs:element>  
        <xs:element name="plotFeatureForChildren">
          <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Definiert die Plotfeatures für alle Kindelement.
          </xs:documentation></xs:annotation>
          <xs:complexType>
            <xs:simpleContent>
              <xs:extension base="pv:booleanFullEval">
                <xs:attribute name="value" type="pv:qnamePartialEval" use="required"/>
              </xs:extension>
            </xs:simpleContent>
          </xs:complexType> 
        </xs:element>  
        <xs:element name="plotFeatureRecursive">  
          <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Definiert die Plotfeatures für diese Element und alle Kindelement.
          </xs:documentation></xs:annotation>
          <xs:complexType>
            <xs:simpleContent>
              <xs:extension base="pv:booleanFullEval">
                <xs:attribute name="value" type="pv:qnamePartialEval" use="required"/>
              </xs:extension>
            </xs:simpleContent>
          </xs:complexType> 
        </xs:element>  
      </xs:choice>
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:element name="plotAttribute">  
          <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Definiert ein Plot-Attribute ohne Wert.
              (Plot attribute sind statische Daten welche als key/value Paar an plot datasets/groups angehängt werden.)
          </xs:documentation></xs:annotation>
          <xs:complexType>
            <xs:attribute name="name" type="pv:stringPartialEval" use="required"/>
          </xs:complexType> 
        </xs:element>  
        <xs:element name="plotAttributeInt">
          <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Definiert ein Plot-Attribute mit integer Wert.
          </xs:documentation></xs:annotation>
          <xs:complexType>
            <xs:simpleContent>
              <xs:extension base="pv:integerFullEval">
                <xs:attribute name="name" type="pv:stringPartialEval" use="required"/>
              </xs:extension>
            </xs:simpleContent>
          </xs:complexType> 
        </xs:element>  
        <xs:element name="plotAttributeFloat">
          <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Definiert ein Plot-Attribute mit floating-point Wert.
          </xs:documentation></xs:annotation>
          <xs:complexType>
            <xs:simpleContent>
              <xs:extension base="pv:floatFullEval">
                <xs:attribute name="name" type="pv:stringPartialEval" use="required"/>
              </xs:extension>
            </xs:simpleContent>
          </xs:complexType> 
        </xs:element>  
        <xs:element name="plotAttributeString">
          <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Definiert ein Plot-Attribute mit string Wert.
          </xs:documentation></xs:annotation>
          <xs:complexType>
            <xs:simpleContent>
              <xs:extension base="pv:stringFullEval">
                <xs:attribute name="name" type="pv:stringPartialEval" use="required"/>
              </xs:extension>
            </xs:simpleContent>
          </xs:complexType> 
        </xs:element>  
        <xs:element name="plotAttributeIntVector">
          <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Definiert ein Plot-Attribute mit integer Vector-Wert.
          </xs:documentation></xs:annotation>
          <xs:complexType>
            <xs:complexContent>
              <xs:extension base="pv:integerVector">
                <xs:attribute name="name" type="pv:stringPartialEval" use="required"/>
              </xs:extension>
            </xs:complexContent>
          </xs:complexType> 
        </xs:element>  
        <xs:element name="plotAttributeFloatVector">
          <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Definiert ein Plot-Attribute mit floating-point Vector-Wert.
          </xs:documentation></xs:annotation>
          <xs:complexType>
            <xs:complexContent>
              <xs:extension base="pv:unknownVector">
                <xs:attribute name="name" type="pv:stringPartialEval" use="required"/>
              </xs:extension>
            </xs:complexContent>
          </xs:complexType> 
        </xs:element>  
        <xs:element name="plotAttributeFloatMatrix">
          <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Definiert ein Plot-Attribute mit floating-point Vector-Wert.
          </xs:documentation></xs:annotation>
          <xs:complexType>
            <xs:complexContent>
              <xs:extension base="pv:unknownMatrix">
                <xs:attribute name="name" type="pv:stringPartialEval" use="required"/>
              </xs:extension>
            </xs:complexContent>
          </xs:complexType> 
        </xs:element>  
      </xs:choice> 
    </xs:sequence>
    <xs:attribute name="name" type="pv:stringPartialEval"/> <!-- is not required here since Function has not name attribute -->
  </xs:complexType> 

  <xs:element name="EmptyGroup" abstract="true" substitutionGroup="Element" type="EmptyGroupType"/>
  <xs:complexType name="EmptyGroupType">
    <xs:complexContent>
      <xs:extension base="ElementType"/>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="Group" substitutionGroup="EmptyGroup" type="GroupType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Definiert eine neue Hierarchieebene in Form einer Gruppe.<br/>
        Eine Gruppe stellt dabei einen
        Kontainer für andere <code>Group</code>'s, <code>Object</code>'s (Körper) und <code>Link</code>'s
        (Verbindungselemente) bereit. Mithilfe von Gruppen können somit hierarchische Modelle erzeugt werden.
        <p>Jede Gruppe definiert automatisch ein statisches KOS mit den Namen "I".</p>
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="GroupType">
    <xs:complexContent>
      <xs:extension base="EmptyGroupType">
        <xs:sequence>
          <xs:element name="frameOfReference" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Koordinatensystem, in dem die Positionierung der Gruppe angegeben wird. Standardmäßig wird das "I"-System des übergeordneten Systems verwendet.
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:attribute name="ref" type="ParentFrameReferenceType" use="required"/>
            </xs:complexType>
          </xs:element>
          <xs:element name="frames">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Kontainer für ortsfeste (statische) Koordinatensysteme dieser Gruppe.
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:choice minOccurs="0" maxOccurs="unbounded">
                <xs:element ref="FixedRelativeFrame"/>
                <xs:element ref="pv:Embed"/>
              </xs:choice>
            </xs:complexType>
          </xs:element>
          <xs:element name="contours">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Kontainer für ortsfeste (statische) Kontaktkonturen dieser Gruppe.
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:choice minOccurs="0" maxOccurs="unbounded">
                <xs:element ref="Contour"/>
                <xs:element ref="pv:Embed"/>
              </xs:choice>
            </xs:complexType>
          </xs:element>
          <xs:element name="groups">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Kontainer für Untergruppen dieser Gruppe.
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:choice minOccurs="0" maxOccurs="unbounded">
                <xs:element ref="EmptyGroup">
                  <xs:annotation>
                    <xs:documentation xml:lang="de" xmlns="">
                      Lokale Definition.
                    </xs:documentation>
                  </xs:annotation>
                </xs:element>
                <xs:element ref="pv:Embed">
                  <xs:annotation>
                    <xs:documentation xml:lang="de" xmlns="">
                      Definition in externer Datei.
                    </xs:documentation>
                  </xs:annotation>
                </xs:element>
              </xs:choice>
            </xs:complexType>
          </xs:element>
          <xs:element name="objects">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Kontainer für <code>Object</code>'s (Körper, hydraulische Leitungen, ...).
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:choice minOccurs="0" maxOccurs="unbounded">
                <xs:element ref="Object">
                  <xs:annotation>
                    <xs:documentation xml:lang="de" xmlns="">
                      Lokale Definition.
                    </xs:documentation>
                  </xs:annotation>
                </xs:element>
                <xs:element ref="pv:Embed">
                  <xs:annotation>
                    <xs:documentation xml:lang="de" xmlns="">
                      Definition in externer Datei.
                    </xs:documentation>
                  </xs:annotation>
                </xs:element>
              </xs:choice>
            </xs:complexType>
          </xs:element>
          <xs:element name="links">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Kontainer für <code>Link</code>'s (Verbindungen, Kontakte, hydraulische Knoten, ...).
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:choice minOccurs="0" maxOccurs="unbounded">
                <xs:element ref="Link">
                  <xs:annotation>
                    <xs:documentation xml:lang="de" xmlns="">
                      Lokale Definition.
                    </xs:documentation>
                  </xs:annotation>
                </xs:element>
                <xs:element ref="pv:Embed">
                  <xs:annotation>
                    <xs:documentation xml:lang="de" xmlns="">
                      Definition in externer Datei.
                    </xs:documentation>
                  </xs:annotation>
                </xs:element>
              </xs:choice>
            </xs:complexType>
          </xs:element>
          <xs:element name="constraints">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Kontainer für <code>Constraint</code>'s (Zwangsbedingungen).
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:choice minOccurs="0" maxOccurs="unbounded">
                <xs:element ref="Constraint">
                  <xs:annotation>
                    <xs:documentation xml:lang="de" xmlns="">
                      Lokale Definition.
                    </xs:documentation>
                  </xs:annotation>
                </xs:element>
                <xs:element ref="pv:Embed">
                  <xs:annotation>
                    <xs:documentation xml:lang="de" xmlns="">
                      Definition in externer Datei.
                    </xs:documentation>
                  </xs:annotation>
                </xs:element>
              </xs:choice>
            </xs:complexType>
          </xs:element>
          <xs:element name="observers">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Kontainer für <code>Observer</code>'s (Beobachter für kinematische und kinetische Größen).
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:choice minOccurs="0" maxOccurs="unbounded">
                <xs:element ref="Observer">
                  <xs:annotation>
                    <xs:documentation xml:lang="de" xmlns="">
                      Lokale Definition.
                    </xs:documentation>
                  </xs:annotation>
                </xs:element>
                <xs:element ref="pv:Embed">
                  <xs:annotation>
                    <xs:documentation xml:lang="de" xmlns="">
                      Definition in externer Datei.
                    </xs:documentation>
                  </xs:annotation>
                </xs:element>
              </xs:choice>
            </xs:complexType>
          </xs:element>
          <xs:element name="enableOpenMBVFrameI" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Aktiviert die Visualisierung des Koordinatensystems "I" dieser Gruppe in OpenMBV.
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:group ref="OpenMBVFrameParameters"/>
            </xs:complexType> 
          </xs:element>
          <xs:element name="plotFeatureFrameI" minOccurs="0" maxOccurs="unbounded">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Definiert die Plotfeatures des Koordinatensystems "I" dieser Gruppe.
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:simpleContent>
                <xs:extension base="pv:booleanFullEval">
                  <xs:attribute name="value" type="pv:qnamePartialEval" use="required"/>
                </xs:extension>
              </xs:simpleContent>
            </xs:complexType>
          </xs:element>
        </xs:sequence> 
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="Environment" abstract="true" type="EnvironmentType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Abstrakte Oberklasse für die Definition von Umgebungsgrößen verschiedener physikalischer Domains, z.b. die Erdbeschleunigung in der Mechanik.
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="EnvironmentType"/>

  <xs:element name="MBSimEnvironment" substitutionGroup="Environment" type="MBSimEnvironmentType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Definiert mechanische Umgebungsgrößen.
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="MBSimEnvironmentType">
    <xs:complexContent>
      <xs:extension base="EnvironmentType">
        <xs:sequence>
          <xs:element name="accelerationOfGravity" type="pv:accelerationVector">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Vektor der Erdbeschleunigung angegeben im KOS "I" von <a class="link" href="mbsim:DynamicSystemSolver"><span class="_element">&lt;DynamicSystemSolver&gt;</span></a>.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="openMBVObject" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Visualisierung der Umgebung (nicht bewegte Objekte).
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:choice minOccurs="0" maxOccurs="unbounded">
                <xs:element ref="ombv:Object"/>
                <xs:element ref="pv:Embed"/>
              </xs:choice>
            </xs:complexType>
          </xs:element>
        </xs:sequence> 
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="DynamicSystemSolver" substitutionGroup="Group" type="DynamicSystemSolverType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        DynamicSystemSolver ist das oberste Herarchie-Element eines Modells, ein Integrierbares Gesamtsystem.<br/>
        Da DynamicSystemSolver von Group abgeleitet ist, besitzt es Gruppenstruktur und kann mit anderen Gruppen, Objekten und Link's gefüllt werden. Darüberhinaus werden
        innerhalb von DynamicSystemSolver die Umgebungsgrößen der einzelnen verwendeten Domains definiert.
        <p>Da das oberste XML Element auch stets den <i>Namespace</i> der folgenden Elemente definieren muss,
          sind die ersten Zeilen eines Modells zumeist durch</p>
        <code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;</code><br/>
        <span class="_element">&lt;DynamicSystemSolver name="MBS" xmlns="http://www.mbsim-env.de/MBSim"</span><br/>
        <code>  xmlns:ombv="http://www.mbsim-env.de/OpenMBV"</code><br/>
        <code>  xmlns:pv="http://www.mbsim-env.de/MBXMLUtils"&gt;</code><br/>
        <code>  ...</code><br/>
        <p>gegeben</p>
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="DynamicSystemSolverType">
    <xs:complexContent>
      <xs:extension base="GroupType">
        <xs:sequence>
          <xs:element name="environments">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Kontainer für Umgebungsvariablen des physikalen Systems.
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:choice minOccurs="0" maxOccurs="unbounded">
                <xs:element ref="Environment"/>
                <xs:element ref="pv:Embed"/>
              </xs:choice>
            </xs:complexType>
          </xs:element>
          <xs:element name="smoothSolver" minOccurs="0" type="pv:stringFullEval">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                <p>Lösungsverfahren für Nebenbedingungsgleichungen auf Beschleunigungsebene in glatten Bereichen (offnen und schließen von Kontakten wird nicht verfolgt).</p>
                <dl>
                  <dt>"fixedpoint"</dt> <dd>Fixpunktiteration mit Relaxationsstrategie (Anwendungsfall: Räumliche Coulombreibung; Eigenschaften: mäßige Konvergenz).</dd>
                  <dt>"GaussSeidel"</dt> <dd>Gauss-Seidel-Verfahren (Anwendungsfall: Ebene Coulombreibung; Eigenschaften: mäßige Konvergenz).</dd>
                  <dt>"direct"</dt> <dd>[DEFAULT] Lösung per minimaler Fehlerquadrate für lineare Gleichungssysteme (Anwendungsfall: nur zweiseitige Bindungen; Eigenschaften: exakte Lösung in einem Schritt).</dd>
                  <dt>"rootfinding"</dt> <dd>Gedämpftes und globalisiertes Newton-Verfahren (Anwendungsfall: Räumliche Coulombreibung; Eigenschaften: sehr robust).</dd>
                  <dt>"directNonlinear"</dt> <dd>Lösung mittels iterativem Newton-Löser für nicht-lineare Gleichungssystem, Lösung der Iterationschritte per minimaler linearer Fehlerquadrate (Anwendungsfall: nur zweiseitige Bindungen; Eigenschaften: nicht-lineare Abhängigkeiten von lambda möglich).</dd>
                </dl>
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="constraintSolver" minOccurs="0" type="pv:stringFullEval">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                <p>Lösungsverfahren für Nebenbedingungsgleichungen auf Beschleunigungsebene in glatten und stoßhaften Bereichen (offnen und schließen von Kontakten wird verfolgt).</p>
                <dl>
                  <dt>"fixedpoint"</dt> <dd>[DEFAULT] Fixpunktiteration mit Relaxationsstrategie (Anwendungsfall: Räumliche Coulombreibung; Eigenschaften: mäßige Konvergenz).</dd>
                  <dt>"GaussSeidel"</dt> <dd>Gauss-Seidel-Verfahren (Anwendungsfall: Ebene Coulombreibung; Eigenschaften: mäßige Konvergenz).</dd>
                  <dt>"direct"</dt> <dd>Lösung per minimaler Fehlerquadrate für lineare Gleichungssysteme (Anwendungsfall: nur zweiseitige Bindungen; Eigenschaften: exakte Lösung in einem Schritt).</dd>
                  <dt>"rootfinding"</dt> <dd>Gedämpftes und globalisiertes Newton-Verfahren (Anwendungsfall: Räumliche Coulombreibung; Eigenschaften: sehr robust).</dd>
                  <dt>"directNonlinear"</dt> <dd>Lösung mittels iterativem Newton-Löser für nicht-lineare Gleichungssystem, Lösung der Iterationschritte per minimaler linearer Fehlerquadrate (Anwendungsfall: nur zweiseitige Bindungen; Eigenschaften: nicht-lineare Abhängigkeiten von lambda möglich).</dd>
                </dl>
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="impactSolver" minOccurs="0" type="pv:stringFullEval">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                <p>Lösungsverfahren für Nebenbedingungsgleichungen auf Geschwindigkeitssebene (bei stößen).</p>
                <dl>
                  <dt>"fixedpoint"</dt> <dd>[DEFAULT] Fixpunktiteration mit Relaxationsstrategie (Anwendungsfall: Räumliche Coulombreibung; Eigenschaften: mäßige Konvergenz).</dd>
                  <dt>"GaussSeidel"</dt> <dd>Gauss-Seidel-Verfahren (Anwendungsfall: Ebene Coulombreibung; Eigenschaften: mäßige Konvergenz).</dd>
                  <dt>"direct"</dt> <dd>Cholesky-Zerlegung für reguläre Gleichungssysteme (Anwendungsfall: nur zweiseitige Bindungen; Eigenschaften: exakte Lösung in einem Schritt).</dd>
                  <dt>"rootfinding"</dt> <dd>Gedämpftes und globalisiertes Newton-Verfahren (Anwendungsfall: Räumliche Coulombreibung; Eigenschaften: sehr robust).</dd>
                  <dt>"directNonlinear"</dt> <dd>Lösung mittels iterativem Newton-Löser für nicht-lineare Gleichungssystem, Lösung der Iterationschritte per minimaler linearer Fehlerquadrate (Anwendungsfall: nur zweiseitige Bindungen; Eigenschaften: nicht-lineare Abhängigkeiten von lambda möglich).</dd>
                </dl>
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="maximumNumberOfIterations" type="pv:integerFullEval" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Anzahl an Iterationen, bei der der Löser abbricht.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="highNumberOfIterations" type="pv:integerFullEval" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Anzahl an Iterationen, bei der der Löser eine Warnung ausgibt.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="numericalJacobian" type="pv:booleanFullEval" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Definiert, ob beim Lösungsverfahren "rootFinding" die Jacobi-Matrix numerisch berechnet werden soll.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="stopIfNoConvergence" type="pv:booleanFullEval" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Definiert, ob der Löser abbricht, wenn keine Konvergenz erreicht wird.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="projectionTolerance" type="pv:nounitScalar" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Definiert die Abbruchschranke welche der nicht-lineare Löser für die Positions-Projektion einhalten muss.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="localSolverTolerance" type="pv:nounitScalar" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Definiert die Abbruchschranke für lokale nicht-lineare Löser auf Element-Ebene. Zum Beispiel der Newton-Solver von JointConstraint.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="dynamicSystemSolverTolerance" type="pv:nounitScalar" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Definiert die Abbruchschranke für globale nicht-lineare Löser auf DynamicSystemSolver-Ebene. Zum Beispiel der Newton-Solver von directNonlinear.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="generalizedRelativePositionTolerance" type="pv:nounitScalar" minOccurs="0">
          </xs:element>
          <xs:element name="generalizedRelativeVelocityTolerance" type="pv:nounitScalar" minOccurs="0">
          </xs:element>
          <xs:element name="generalizedRelativeAccelerationTolerance" type="pv:nounitScalar" minOccurs="0">
          </xs:element>
          <xs:element name="generalizedForceTolerance" type="pv:nounitScalar" minOccurs="0">
          </xs:element>
          <xs:element name="generalizedImpulseTolerance" type="pv:nounitScalar" minOccurs="0">
          </xs:element>
          <xs:element name="generalizedRelativePositionCorrectionValue" type="pv:nounitScalar" minOccurs="0">
          </xs:element>
          <xs:element name="generalizedRelativeVelocityCorrectionValue" type="pv:nounitScalar" minOccurs="0">
          </xs:element>
          <xs:element name="inverseKinetics" minOccurs="0" type="pv:booleanFullEval">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Definiert, ob Gelenkreaktionen berechnet werden sollen.
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="initialProjection" minOccurs="0" type="pv:booleanFullEval">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Definiert, ob vor Beginn der Simulation eine Projektion der generalisierten Lagen und Geschwindigkeiten erfolgen soll.
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="determineEquilibriumState" type="pv:booleanFullEval" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Definiert, ob vor Beginn der Simulation die statische Gleichgewichtslage ermittelt werden soll.
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="useConstraintSolverForSmoothMotion" minOccurs="0" type="pv:booleanFullEval">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Definiert, ob die mengenwertigen Kraftgesetze auch während der glatten Bewegung mit dem definierten Lösungsverfahren aus <code>&lt;constraintSolver&gt;</code> berechnet werden sollen (true), oder ob während der glatten Bewegung immer der direkte Löser aus <code>&lt;smoothSolver&gt;</code> verwendet werden soll (false).
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="useConstraintSolverForPlot" minOccurs="0" type="pv:booleanFullEval">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Definiert, ob die mengenwertigen Kraftgesetze auch in der Plot-Routine mit dem definierten Lösungsverfahren berechnet aus <code>&lt;constraintSolver&gt;</code> werden sollen (true), oder ob für den Plot immer der direkte Löser aus <code>&lt;smoothSolver&gt;</code> verwendet werden soll (false).
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="compressionLevel" minOccurs="0" type="pv:integerFullEval">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Definiert den compressions level (0-9) für HDF5 output files: 0: keine compression, 9: stärkste compression (Default: 1)
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="chunkSize" minOccurs="0" type="pv:integerFullEval">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Definiert die Anzahl der Zeilen der HDF5 chunk Größe (Default: 100)
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="cacheSize" minOccurs="0" type="pv:integerFullEval">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Definiert die Anzahl der Zeilen der nativen cache Größe. HDF5 schreibaktionen werden nur ausgeführt wenn der cache voll ist. (Default: 100)
            </xs:documentation></xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="Object" abstract="true" substitutionGroup="Element" type="ObjectType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Abstrakte Klasse eines Objekts.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="ObjectType">
    <xs:complexContent>
      <xs:extension base="ElementType"/>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="Body" abstract="true" substitutionGroup="Object" type="BodyType">
    <xs:annotation>
      <!--<xs:documentation xml:lang="de" xmlns="">
        The following <b>part</b> is <i>only</i> a test for <code>equation</code> and image output for the XML documentation FROM XSM SCHEMA.
        Also links to other parts of the Documentation is possible <a class="link" href="mbsim:Element">like this</a>.
        <p>A paragraph with a line break<br/>here</p>
        <p>Other paragraph with a definition list:</p>
        <dl>
          <dt>Def1</dt><dd>The description of Def1</dd>
          <dt>Def2</dt><dd>The description of Def2</dd>
        </dl>
        A unordered list
        <ul>
          <li>Item 1</li>
          <li>Item 2</li>
        </ul>
        and a ordered list
        <ol>
          <li>Item 1</li>
          <li>Item 2</li>
        </ol>
        A not inline equation
        <object class="eqn">
          <![CDATA[\int_a^b\sin(x)dx +
          \left[\begin{array}{cc}
          1 & 2 \\
          3 & 4
          \end{array}\right]]]>
        </object>
        And a inline equation <object class="inlineeqn">x_a+\cos(x)</object>. And a image.
        <object class="figure" data="mbsim.svg">The image caption</object>
        End of the test. 
      </xs:documentation>-->
      <xs:documentation xml:lang="de" xmlns="">
        Abstrakte Oberklasse für beliebige mechanische Körper (starr, flexibel, ...).
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="BodyType">
    <xs:complexContent>
      <xs:extension base="ObjectType">
        <xs:sequence>
          <xs:element name="generalizedInitialPosition" minOccurs="0" type="pv:unknownVector">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Inertiale Lage in den generalisierten Freiheitsgraden.
                <p>An dieser Stelle werden die Anfangslagen von zustandsbehafteten Objekten angegeben. Bei Starrkörpern muss die Länge dieses Vektors der Anzahl der angegebenen Translations- und Rotationsrichtungen entsprechen, wobei zunächst die translatorischen Lagen und danach die rotatorischen Lagen anzugeben sind.</p>
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="generalizedInitialVelocity" minOccurs="0" type="pv:unknownVector">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Inertiale Geschwindigkeiten in den generalisierten Freiheitsgraden.
                <p>vgl. <i>generalizedInitialPosition</i> für die Zuordnung.</p>
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="frameOfReference" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Definiert das KOS bezüglich dessen die Bewegung (Kinematik; generalisierte Lagen) des Körpers angegeben wird.<br/>
                Ist dieses Referenz-KOS ein KOS einer Gruppe (statisches KOS) so wird der Körper mit absoluten Koordinaten parametriert.
                Ist das Referenz-KOS eine KOS eines anderen Körpers (bewegtes KOS),
                so handelt es sich um einen Körper mit relativer Parametrierung (Baumstruktur).
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:attribute name="ref" type="FrameReferenceType" use="required"/>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="RigidBody" substitutionGroup="Body" type="RigidBodyType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Definiert einen Starrkörper.<br/>
        Grundlage zur Definition aller kinematischen Zusammenhänge bei Starrkörpern sind zwei Koordinatensysteme, das <code>frameOfReference</code> (siehe <a class="link" href="mbsim:Object">&lt;Object&gt;</a>) und das <code>frameForKinematics</code>. Das <code>frameOfReference</code> gehört entweder zu einer Gruppe und ist somit inertial fest oder es gehört zu einem anderen Körper und kann somit bewegt sein. Das <code>frameForKinematics</code> ist ein beliebiges körperfestes Koordinatensystem. Schließlich wird die Bewegung des Starrkörpers mittels generalisierter Koordinaten oder zeitabhängiger Funktionen als Bewegung des <code>frameForKinematics</code> relativ zum <code>frameOfReference</code> definiert.<br/>
        Zur rekursiven Definition weiterer körperfester Koordinatensystem hat jeder Starrkörper automatisch ein Koordinatensystem "C" in seinem Schwerpunkt.
        <object class="figure" data="rigid_body.svg">Kinematische Beschreibung eines Starrkörpers</object>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="RigidBodyType">
    <xs:complexContent>
      <xs:extension base="BodyType">
        <xs:sequence>
          <xs:element name="frameForKinematics" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Definiert das KOS, dessen relative Bewegung bezüglich des <code>frameOfReference</code>
                (siehe <a class="link" href="mbsim:Object"><code>Object</code></a>) sich unmittelbar aus den
                generalisierten Koordinaten dieses Körpers ergibt.
                <p>Es kann sich somit entsprechend der angegebenen translatorischen und rotatorischen Freiheitsgrade
                  relativ gegenüber dem <code>frameOfReference</code> bewegen und ist zu Beginn der Simulation um die
                  angegebenen generalisierten Startwerte gegenüber dem <code>frameOfReference</code> ausgelenkt.</p>
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:attribute name="ref" type="CurrentFrameReferenceType" use="required"/>
            </xs:complexType> 
          </xs:element>
          <xs:element name="mass" type="pv:massScalar">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Masse des Körpers.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="inertiaTensor" type="pv:inertiaMatrix">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Trägheitstensor des Körpers bezüglich des <code>frameForInertiaTensor</code> (standardmäßig das Schwerpunktkoordinatensystem "C").
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="frameForInertiaTensor" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Definiert das KOS für den Trägheitstensor (standardmäßig das Schwerpunktkoordinatensystem "C").
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:attribute name="ref" type="CurrentFrameReferenceType" use="required"/>
            </xs:complexType> 
          </xs:element>
          <xs:choice minOccurs="0">
            <xs:element name="generalTranslation">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                  Gibt die Vorschrift zur Berechnung des Translationsvektors
                  <object class="inlineeqn">\boldsymbol{r}_q=f(\boldsymbol{q},t)</object> in Abhängigkeit der 
                  generalisierten Lagen und der Zeit an.<br/>
                  Der Translationsvektor <object class="inlineeqn">\boldsymbol{r}_q</object> ist
                  im KOS <code>frameOfReference</code> dargestellt und stellt die
                  Relativverschiebung zwischen dem KOS <code>frameOfReference</code> und dem KOS <code>frameForKinematics</code> dar.
                  <p>Wird <code>Translation</code> nicht angegeben, so besitzt der Körper keine translatorischen Freiheitsgrade.</p>
              </xs:documentation></xs:annotation>
              <xs:complexType>
                <xs:choice>
                  <xs:element ref="Function"/>
                  <xs:element ref="pv:Embed"/>
                </xs:choice>
              </xs:complexType>
            </xs:element>
            <xs:element name="timeDependentTranslation">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                  Gibt die Vorschrift zur Berechnung des Translationsvektors
                  <object class="inlineeqn">\boldsymbol{r}_q=f(t)</object> in Abhängigkeit der 
                  generalisierten Lagen und der Zeit an.<br/>
                  Der Translationsvektor <object class="inlineeqn">\boldsymbol{r}_q</object> ist
                  im KOS <code>frameOfReference</code> dargestellt und stellt die
                  Relativverschiebung zwischen dem KOS <code>frameOfReference</code> und dem KOS <code>frameForKinematics</code> dar.
                  <p>Wird <code>Translation</code> nicht angegeben, so besitzt der Körper keine translatorischen Freiheitsgrade.</p>
              </xs:documentation></xs:annotation>
              <xs:complexType>
                <xs:choice>
                  <xs:element ref="Function"/>
                  <xs:element ref="pv:Embed"/>
                </xs:choice>
              </xs:complexType>
            </xs:element>
            <xs:element name="stateDependentTranslation">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                  Gibt die Vorschrift zur Berechnung des Translationsvektors
                  <object class="inlineeqn">\boldsymbol{r}_q=f(\boldsymbol{q})</object> in Abhängigkeit der 
                  generalisierten Lagen und der Zeit an.<br/>
                  Der Translationsvektor <object class="inlineeqn">\boldsymbol{r}_q</object> ist
                  im KOS <code>frameOfReference</code> dargestellt und stellt die
                  Relativverschiebung zwischen dem KOS <code>frameOfReference</code> und dem KOS <code>frameForKinematics</code> dar.
                  <p>Wird <code>Translation</code> nicht angegeben, so besitzt der Körper keine translatorischen Freiheitsgrade.</p>
              </xs:documentation></xs:annotation>
              <xs:complexType>
                <xs:choice>
                  <xs:element ref="Function"/>
                  <xs:element ref="pv:Embed"/>
                </xs:choice>
              </xs:complexType>
            </xs:element>
          </xs:choice>
          <xs:choice minOccurs="0">
            <xs:element name="generalRotation">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                  Gibt die Vorschrift zur Berechnung der Transformationsmatrix
                  <object class="inlineeqn">\boldsymbol{A}_q=f(\boldsymbol{q},t)</object> in Abhängigkeit der 
                  generalisierten Lagen und der Zeit an.<br/>
                  Die Transformationsmatrix <object class="inlineeqn">\boldsymbol{A}_q</object> stellt dabei die
                  Transformation vom KOS <code>frameForKinematics</code> in das KOS <code>frameOfReference</code> dar.
                  <p>Wird <code>Rotation</code> nicht angegeben, so besitzt der Körper keine rotatorischen Freiheitsgrade.</p>
              </xs:documentation></xs:annotation>
              <xs:complexType>
                <xs:choice>
                  <xs:element ref="Function"/>
                  <xs:element ref="pv:Embed"/>
                </xs:choice>
              </xs:complexType>
            </xs:element>
            <xs:element name="timeDependentRotation">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                  Gibt die Vorschrift zur Berechnung der Transformationsmatrix
                  <object class="inlineeqn">\boldsymbol{A}_q=f(t)</object> in Abhängigkeit der 
                  generalisierten Lagen und der Zeit an.<br/>
                  Die Transformationsmatrix <object class="inlineeqn">\boldsymbol{A}_q</object> stellt dabei die
                  Transformation vom KOS <code>frameForKinematics</code> in das KOS <code>frameOfReference</code> dar.
                  <p>Wird <code>Rotation</code> nicht angegeben, so besitzt der Körper keine rotatorischen Freiheitsgrade.</p>
              </xs:documentation></xs:annotation>
              <xs:complexType>
                <xs:choice>
                  <xs:element ref="Function"/>
                  <xs:element ref="pv:Embed"/>
                </xs:choice>
              </xs:complexType>
            </xs:element>
            <xs:element name="stateDependentRotation">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                  Gibt die Vorschrift zur Berechnung der Transformationsmatrix
                  <object class="inlineeqn">\boldsymbol{A}_q=f(\boldsymbol{q})</object> in Abhängigkeit der 
                  generalisierten Lagen und der Zeit an.<br/>
                  Die Transformationsmatrix <object class="inlineeqn">\boldsymbol{A}_q</object> stellt dabei die
                  Transformation vom KOS <code>frameForKinematics</code> in das KOS <code>frameOfReference</code> dar.
                  <p>Wird <code>Rotation</code> nicht angegeben, so besitzt der Körper keine rotatorischen Freiheitsgrade.</p>
              </xs:documentation></xs:annotation>
              <xs:complexType>
                <xs:choice>
                  <xs:element ref="Function"/>
                  <xs:element ref="pv:Embed"/>
                </xs:choice>
              </xs:complexType>
            </xs:element>
          </xs:choice>
          <xs:element name="translationDependentRotation" minOccurs="0" type="pv:booleanFullEval">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Definiert, ob die Rotation von der Translation abhängt. In diesem Fall werden für Translation und Rotation dieselben Koordinaten verwendet.
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="generalizedVelocityOfRotation" type="pv:stringFullEval" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Auswahl der generalisierten Geschwindigkeiten der Rotation.
              <ul>
                <li>derivativeOfGeneralizedPositionOfRotation: Ableitung der generalisierten Lagekoordinaten der Rotation.</li>
                <li>coordinatesOfAngularVelocityWrtFrameOfReference: Kartesische Koordinaten der Winkelgeschwindigkeit bzgl. des KOS <code>frameOfReference</code>.</li>
                <li>coordinatesOfAngularVelocityWrtFrameForKinematics: Kartesische Koordinaten der Winkelgeschwindigkeit bzgl. des KOS <code>frameForKinematics</code>.</li>
              </ul>
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="frames">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Kontainer für lokale Koordinatensysteme dieses Körpers.<br/>
                Da es sich um einen Starrkörper
                handelt, ist die relative Lage dieser KOS untereinander (und auch zum KOS "C") während
                der gesamten Simulation konstant.
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:choice minOccurs="0" maxOccurs="unbounded">
                <xs:element ref="FixedRelativeFrame"/>
                <xs:element ref="pv:Embed"/>
              </xs:choice>
            </xs:complexType>
          </xs:element>
          <xs:element name="contours">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Kontainer für lokale Kontaktkonturen dieses Körpers.<br/>
                Da es sich um einen Starrkörper handelt, ist die relative Lage dieser Kontaktkonturen
                untereinander (und auch zum KOS "C") während der gesamten Simulation konstant.
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:choice minOccurs="0" maxOccurs="unbounded">
                <xs:element ref="RigidContour"/>
                <xs:element ref="pv:Embed"/>
              </xs:choice>
            </xs:complexType>
          </xs:element>
          <xs:sequence minOccurs="0">
            <xs:element name="openMBVRigidBody">
              <xs:annotation>
                <xs:documentation xml:lang="de" xmlns="">
                  Aktiviert die Visualisierung dieses Körpers in OpenMBV durch den unten angegebenen OpenMBV Körper.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:choice>
                  <xs:element ref="ombv:RigidBody"/>
                  <xs:element ref="pv:Embed"/>
                </xs:choice>
              </xs:complexType>
            </xs:element>
            <xs:element name="openMBVFrameOfReference" minOccurs="0">
              <xs:annotation>
                <xs:documentation xml:lang="de" xmlns="">
                  Definiert das MBSim KOS, mit dem das Referenz-KOS des OpenMBV Körpers zusammenfällt.<br/>
                  Wird dieses Element nicht angegeben, so wird das KOS "C" verwendet.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:attribute name="ref" type="CurrentFrameReferenceType" use="required"/>
              </xs:complexType>
            </xs:element>
          </xs:sequence>
          <xs:element name="enableOpenMBVFrameC" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Aktiviert die Visualisierung des Schwerpunktskoordinatensystems "C" dieses Körpers in OpenMBV.
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:group ref="OpenMBVFrameParameters"/>
            </xs:complexType> 
          </xs:element>
          <xs:element name="plotFeatureFrameC" minOccurs="0" maxOccurs="unbounded">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Definiert die Plotfeatures des Schwerpunktskoordinatensystems "C" dieses Körpers.
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:simpleContent>
                <xs:extension base="pv:booleanFullEval">
                  <xs:attribute name="value" type="pv:qnamePartialEval" use="required"/>
                </xs:extension>
              </xs:simpleContent>
            </xs:complexType>
          </xs:element>
        </xs:sequence> 
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>   
  
  <xs:element name="Constraint" abstract="true" substitutionGroup="Element" type="ConstraintType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Kinematische Zwangsbedingungen.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="ConstraintType">
    <xs:complexContent>
      <xs:extension base="ElementType"/>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="GeneralizedConstraint" abstract="true" substitutionGroup="Constraint" type="GeneralizedConstraintType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Kinematische Zwangsbedingungen für generalisierte Koordinaten.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="GeneralizedConstraintType">
    <xs:complexContent>
      <xs:extension base="ConstraintType">
        <xs:sequence>
          <xs:element name="supportFrame" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Definiert das KOS an dem die Stützkraft und das Stützmoment eingeleitet werden.
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:attribute name="ref" type="FrameReferenceType" use="required"/>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="GeneralizedDualConstraint" substitutionGroup="GeneralizedConstraint" type="GeneralizedDualConstraintType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        TODO <br/>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="GeneralizedDualConstraintType">
    <xs:complexContent>
      <xs:extension base="GeneralizedConstraintType">
        <xs:sequence>
          <xs:element name="dependentRigidBody">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Starrkörper, dessen generalisierte Koordinaten durch eine Zeitfunktion bestimmt werden kann.
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:attribute name="ref" type="ObjectReferenceType" use="required"/>
            </xs:complexType> 
          </xs:element>
          <xs:element name="independentRigidBody" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Starrkörper, dessen generalisierte Koordinaten durch eine Zeitfunktion bestimmt werden kann.
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:attribute name="ref" type="ObjectReferenceType" use="required"/>
            </xs:complexType>
          </xs:element>
        </xs:sequence> 
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="GeneralizedPositionConstraint" substitutionGroup="GeneralizedDualConstraint" type="GeneralizedPositionConstraintType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        TODO <br/>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="GeneralizedPositionConstraintType">
    <xs:complexContent>
      <xs:extension base="GeneralizedDualConstraintType">
        <xs:sequence>
          <xs:element name="constraintFunction">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              TODO
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:choice>
                <xs:element ref="Function"/>
                <xs:element ref="pv:Embed"/>
              </xs:choice>
            </xs:complexType>
          </xs:element>
        </xs:sequence> 
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="GeneralizedVelocityConstraint" substitutionGroup="GeneralizedDualConstraint" type="GeneralizedVelocityConstraintType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        TODO <br/>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="GeneralizedVelocityConstraintType">
    <xs:complexContent>
      <xs:extension base="GeneralizedDualConstraintType">
        <xs:sequence>
          <xs:element name="initialState" minOccurs="0" type="pv:unknownVector">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
              tbd
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:choice>
            <xs:element name="generalConstraintFunction">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                TODO
              </xs:documentation></xs:annotation>
              <xs:complexType>
                <xs:choice>
                  <xs:element ref="Function"/>
                  <xs:element ref="pv:Embed"/>
                </xs:choice>
              </xs:complexType>
            </xs:element>
            <xs:element name="timeDependentConstraintFunction">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                TODO
              </xs:documentation></xs:annotation>
              <xs:complexType>
                <xs:choice>
                  <xs:element ref="Function"/>
                  <xs:element ref="pv:Embed"/>
                </xs:choice>
              </xs:complexType>
            </xs:element>
            <xs:element name="stateDependentConstraintFunction">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                TODO
              </xs:documentation></xs:annotation>
              <xs:complexType>
                <xs:choice>
                  <xs:element ref="Function"/>
                  <xs:element ref="pv:Embed"/>
                </xs:choice>
              </xs:complexType>
            </xs:element>
          </xs:choice>
        </xs:sequence> 
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="GeneralizedAccelerationConstraint" substitutionGroup="GeneralizedDualConstraint" type="GeneralizedAccelerationConstraintType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        TODO <br/>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="GeneralizedAccelerationConstraintType">
    <xs:complexContent>
      <xs:extension base="GeneralizedDualConstraintType">
        <xs:sequence>
          <xs:element name="initialState" minOccurs="0" type="pv:unknownVector">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
              tbd
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:choice>
            <xs:element name="generalConstraintFunction">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                TODO
              </xs:documentation></xs:annotation>
              <xs:complexType>
                <xs:choice>
                  <xs:element ref="Function"/>
                  <xs:element ref="pv:Embed"/>
                </xs:choice>
              </xs:complexType>
            </xs:element>
            <xs:element name="timeDependentConstraintFunction">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                TODO
              </xs:documentation></xs:annotation>
              <xs:complexType>
                <xs:choice>
                  <xs:element ref="Function"/>
                  <xs:element ref="pv:Embed"/>
                </xs:choice>
              </xs:complexType>
            </xs:element>
            <xs:element name="stateDependentConstraintFunction">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                TODO
              </xs:documentation></xs:annotation>
              <xs:complexType>
                <xs:choice>
                  <xs:element ref="Function"/>
                  <xs:element ref="pv:Embed"/>
                </xs:choice>
              </xs:complexType>
            </xs:element>
          </xs:choice>
        </xs:sequence> 
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="GeneralizedGearConstraint" substitutionGroup="GeneralizedConstraint" type="GeneralizedGearConstraintType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        TODO <br/>
        Kinematische Zwangsbedingung durch Angabe eines Übersetzungsverhältnisses.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="GeneralizedGearConstraintType">
    <xs:complexContent>
      <xs:extension base="GeneralizedConstraintType">
        <xs:sequence>
          <xs:element name="dependentRigidBody">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Getriebeausgang
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:attribute name="ref" type="ObjectReferenceType" use="required"/>
            </xs:complexType> 
          </xs:element>
          <xs:element name="independentRigidBody" minOccurs="1" maxOccurs="unbounded">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Getriebeeingang
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:attribute name="ref" type="ObjectReferenceType" use="required"/>
              <xs:attribute name="ratio" type="pv:floatFullEval" use="required"/>
            </xs:complexType> 
          </xs:element>
        </xs:sequence> 
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="JointConstraint" substitutionGroup="Constraint" type="JointConstraintType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        TODO <br/>
        Kinematische Zwangsbedingung durch geschlossene Schleifen. Die  Auflösung der kinematischen Schleife erfolgt durch die Lösung eines Gleichungssystems. Durch die inertiale generalisierte Lage kann ein Startvektor für den Lösungsalgorithmus vorgegeben werden.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="JointConstraintType">
    <xs:complexContent>
      <xs:extension base="ConstraintType">
        <xs:sequence>
          <xs:element name="dependentRigidBodyOnFirstSide" minOccurs="0" maxOccurs="unbounded">
            <xs:complexType>
              <xs:attribute name="ref" type="ObjectReferenceType" use="required">
                <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                  Liste der Körper auf Seite A des Lagers.
                </xs:documentation></xs:annotation>
              </xs:attribute>
            </xs:complexType>
          </xs:element>
          <xs:element name="dependentRigidBodyOnSecondSide" minOccurs="0" maxOccurs="unbounded">
            <xs:complexType>
              <xs:attribute name="ref" type="ObjectReferenceType" use="required">
                <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                  Liste der Körper auf Seite B des Lagers.
                </xs:documentation></xs:annotation>
              </xs:attribute>
            </xs:complexType>
          </xs:element>
          <xs:element name="independentRigidBody" minOccurs="1" maxOccurs="unbounded">
            <xs:complexType>
              <xs:attribute name="ref" type="ObjectReferenceType" use="required">
                <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                  Angabe der Körper, deren Freiheitsgrade erhalten bleiben. Die Lagen und Geschwindigkeiten aller anderen Körper in der kinematischen Schleife können aus den generalisierten Koordinate dieser Körper bestimmt werden.
                </xs:documentation></xs:annotation>
              </xs:attribute>
            </xs:complexType>
          </xs:element>
          <xs:element name="connect">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Angabe der beiden Koordinatensysteme, welche in Übereinstimmung gebracht werden sollen.
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:attribute name="ref1" type="FrameReferenceType" use="required"/>
              <xs:attribute name="ref2" type="FrameReferenceType" use="required"/>
            </xs:complexType> 
          </xs:element>
          <xs:element name="frameOfReference" type="pv:stringFullEval" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Auswahl des Koordinatensystems, in dem der Kraft- und Momentvektor dargestellt ist.
              <ul>
                <li>firstFrame: Erstes Koordinatensystem, das bei <code>connect</code> angegeben wurde</li>
                <li>secondFrame: Zweites Koordinatensystem, das bei <code>connect</code> angegeben wurde</li>
              </ul>
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="forceDirection" type="pv:nounitMatrix" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Richtungen <object class="inlineeqn">\mathbf{D}_T=\left(\mathbf{d}_{T,1},\ldots\right)</object> der Zwangskräfte des Gelenks in normierten Vektoren dargestellt im Koordinatensystem <code>frameOfReference</code> (standarmäßig das erste KOS).
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="momentDirection" type="pv:nounitMatrix" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Richtungen <object class="inlineeqn">\mathbf{D}_R=\left(\mathbf{d}_{R,1},\ldots\right)</object> der Zwangsmomente des Gelenks in normierten Vektoren dargestellt im Koordinatensystem <code>frameOfReference</code> (standarmäßig das erste KOS).
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="initialGuess" minOccurs="0" type="pv:unknownVector">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Anfangswerte für Newton-Löser.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence> 
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="GeneralizedConnectionConstraint" substitutionGroup="GeneralizedConstraint" type="GeneralizedConnectionConstraintType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
      tbd
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="GeneralizedConnectionConstraintType">
    <xs:complexContent>
      <xs:extension base="GeneralizedConstraintType">
        <xs:sequence>
          <xs:element name="dependentRigidBody">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Starrkörper, dessen generalisierte Koordinaten von den generalisierten Koordinaten eines anderen Körper abhängig sind.
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:attribute name="ref" type="ObjectReferenceType" use="required"/>
            </xs:complexType>
          </xs:element>
          <xs:element name="independentRigidBody" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Starrkörper, dessen generalisierte Koordinaten unabhängig sind.
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:attribute name="ref" type="ObjectReferenceType" use="required"/>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="InverseKinematicsConstraint" substitutionGroup="Constraint" type="InverseKinematicsConstraintType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Kinematisce Vorgabe für einen Körper in einem System mit Baumstruktur (Roboter)
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="InverseKinematicsConstraintType">
    <xs:complexContent>
      <xs:extension base="ConstraintType">
        <xs:sequence>
          <xs:element name="kinematics" type="pv:stringFullEval" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Auswahl der Kinematik.
              <ul>
                <li>planar: ebene Kinematik</li>
                <li>spatial: räumliche Kinematik</li>
              </ul>
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="frame">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Angabe des Koordinatensystems, für das die kinematische Vorgabe gelten soll.
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:attribute name="ref" type="FrameReferenceType" use="required"/>
            </xs:complexType>
          </xs:element>
          <xs:element name="translation">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Definiert die Translation in Abhängigkeit der Zeit.
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:choice>
                <xs:element ref="Function"/>
                <xs:element ref="pv:Embed"/>
              </xs:choice>
            </xs:complexType>
          </xs:element>
          <xs:element name="rotation" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Definiert die Rotation in Abhängigkeit der Zeit.
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:choice>
                <xs:element ref="Function"/>
                <xs:element ref="pv:Embed"/>
              </xs:choice>
            </xs:complexType>
          </xs:element>
          <xs:element name="initialGuess" minOccurs="0" type="pv:unknownVector">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Anfangswerte für Newton-Löser.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="Link" abstract="true" substitutionGroup="Element" type="LinkType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Abstrakte Oberklasse eines Verbindungselements zwischen Objekten.
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="LinkType">
    <xs:complexContent>
      <xs:extension base="ElementType"/>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="MechanicalLink" abstract="true" substitutionGroup="Link" type="MechanicalLinkType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Abstrakte Oberklasse eines Verbindungselements zwischen Objekten.
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="MechanicalLinkType">
    <xs:complexContent>
      <xs:extension base="LinkType"/>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="FrameLink" substitutionGroup="MechanicalLink" type="FrameLinkType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Abstrakte Oberklasse für mechanische Verbindungselemente zwischen Körpern.
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="FrameLinkType">
    <xs:complexContent>
      <xs:extension base="MechanicalLinkType">
        <xs:sequence>
          <xs:element name="connect">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Definiert den Angriffspunkt dieser kinetischen Anregung auf einen Körper. Als Angriffspunkt
                muss dabei ein KOS des entsprechenden Körpers angegeben werden.
                Bei inneren Kräften und Momenten können alternativ die KOS beider Schnittufer angegeben werden.
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:attribute name="ref1" type="FrameReferenceType"/>
              <xs:attribute name="ref2" type="FrameReferenceType" use="required"/>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="FixedFrameLink" substitutionGroup="FrameLink" type="FixedFrameLinkType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Abstrakte Oberklasse für mechanische Verbindungselemente zwischen Körpern.
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="FixedFrameLinkType">
    <xs:complexContent>
      <xs:extension base="FrameLinkType"/>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="FloatingFrameLink" substitutionGroup="FrameLink" type="FloatingFrameLinkType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Abstrakte Oberklasse für mechanische Verbindungselemente zwischen Körpern.
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="FloatingFrameLinkType">
    <xs:complexContent>
      <xs:extension base="FrameLinkType">
        <xs:sequence>
          <xs:element name="frameOfReference" type="pv:stringFullEval" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Auswahl des Koordinatensystems, in dem der Kraft- und Momentvektor dargestellt ist.
              <ul>
                <li>firstFrame: Erstes Koordinatensystem, das bei <code>connect</code> angegeben wurde</li>
                <li>secondFrame: Zweites Koordinatensystem, das bei <code>connect</code> angegeben wurde</li>
              </ul>
            </xs:documentation></xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="ContourLink" substitutionGroup="MechanicalLink" type="ContourLinkType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Abstrakte Oberklasse für mechanische Verbindungselemente zwischen Körpern.
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="ContourLinkType">
    <xs:complexContent>
      <xs:extension base="MechanicalLinkType">
        <xs:sequence>
          <xs:element name="connect">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Bindet zwei Konturen an einen Kontakt.
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:attribute name="ref1" type="ContourReferenceType" use="required"/>
              <xs:attribute name="ref2" type="ContourReferenceType" use="required"/>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="RigidBodyLink" substitutionGroup="MechanicalLink" type="RigidBodyLinkType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Abstrakte Oberklasse für mechanische Verbindungselemente zwischen Starrkörpern.
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="RigidBodyLinkType">
    <xs:complexContent>
      <xs:extension base="MechanicalLinkType">
        <xs:sequence>
          <xs:element name="supportFrame" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Definiert das KOS an dem die Stützkraft und das Stützmoment eingeleitet werden. Wird kein KOS angegeben, wird das Referenzsystem des ersten Körpers verwendet.
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:attribute name="ref" type="FrameReferenceType" use="required"/>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="DualRigidBodyLink" substitutionGroup="RigidBodyLink" type="DualRigidBodyLinkType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
      tbd
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="DualRigidBodyLinkType">
    <xs:complexContent>
      <xs:extension base="RigidBodyLinkType">
        <xs:sequence>
          <xs:element name="connect">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              tbd
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:attribute name="ref" type="ObjectReferenceType"/>
              <xs:attribute name="ref1" type="ObjectReferenceType"/>
              <xs:attribute name="ref2" type="ObjectReferenceType"/>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="KineticExcitation" substitutionGroup="FloatingFrameLink" type="KineticExcitationType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Definiert eine externe, kinetische Anregung auf einen Körper.
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="KineticExcitationType">
    <xs:complexContent>
      <xs:extension base="FloatingFrameLinkType">
        <xs:sequence>
          <xs:sequence minOccurs="0">
            <xs:element name="forceDirection" type="pv:nounitMatrix">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                  Definiert die Wirkrichtung der Kraftanregung(en).
                  Die Spalte i dieser Matrix definiert den Wirkrichtungsvektor des i-ten Eintrags der Kraftfunktion angegeben
                  im KOS <code>frameOfReference</code> (standardmäßig das zweite KOS). Um eine Skalierung der skalaren Kraft (i-ter Eintrag der Kraftfunktion)
                  zu umgehen, sollte jede Spalte dieser Matrix normiert sein.
              </xs:documentation></xs:annotation>
            </xs:element>
            <xs:element name="forceFunction">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                  Definiert die Kraftfunktion in Abhängigkeit der Zeit.
              </xs:documentation></xs:annotation>
              <xs:complexType>
                <xs:choice>
                  <xs:element ref="Function"/>
                  <xs:element ref="pv:Embed"/>
                </xs:choice>
              </xs:complexType>
            </xs:element>
          </xs:sequence>
          <xs:sequence minOccurs="0">
            <xs:element name="momentDirection" type="pv:nounitMatrix">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                  Definiert die Wirkrichtung der Momentenanregung(en).
                  Die Spalte i dieser Matrix definiert den Wirkrichtungsvektor des i-ten Eintrags der Momentfunktion angegeben
                  im KOS <code>frameOfReference</code> (standardmäßig das zweite KOS). Um eine Skalierung des skalaren Moments (i-ter Eintrag der Momentfunktion)
                  zu umgehen, sollte jede Spalte dieser Matrix normiert sein.
              </xs:documentation></xs:annotation>
            </xs:element>
            <xs:element name="momentFunction">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                  Definiert die Momentfunktion in Abhängigkeit der Zeit.
              </xs:documentation></xs:annotation>
              <xs:complexType>
                <xs:choice>
                  <xs:element ref="Function"/>
                  <xs:element ref="pv:Embed"/>
                </xs:choice>
              </xs:complexType>
            </xs:element>
          </xs:sequence>
          <xs:element name="enableOpenMBV" minOccurs="0">  
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Wenn angegeben, wird die kinetische Anregung durch einen Pfeil in OpenMBV visualisiert.
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:group ref="OpenMBVInteractionArrowParameters"/>
            </xs:complexType> 
          </xs:element>
        </xs:sequence> 
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="SpringDamper" substitutionGroup="FrameLink" type="SpringDamperType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Definiert ein Feder-Dämpfer Element als Verbindung zwischen zwei Körpern. Es wird zwischen einer gerichteten Verbindung und einer Punkt-zu-Punkt-Verbindung unterschieden.
        <p>
          <i>Punkt-zu-Punkt-Verbindung.</i> Die Kraft des Feder-Dämpfer-Elements wird aus dem Abstand der verbundenen Punkte und der in diese Richtung projezierten relativen Geschwindigkeit berechnet. Der Abstand ist dabei immer positiv. Die Kraft wird ebenfalls in diese Richtung aufgebracht.
        </p>
        <p>
          <i>Gerichtete Verbindung.</i> Die Kraft des Feder-Dämpfer-Elements wird aus dem in die Richtung der angegebenen Projektionsrichtung projezierten Verbindungsvektor der beiden verbundenen Punkte sowie der in diese Richtung projezierten Relativgeschwindigkeit berechnet. Die Kraft wird in der angegebenen Projektionsrichtung aufgebracht. <br/>
          <b>Achtung!</b> Durch eine falsche Wahl der Projektionsrichtung wird unter Umständen das Momentengleichgewicht nicht mehr erfüllt.
        </p>
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="SpringDamperType">
    <xs:complexContent>
      <xs:extension base="FrameLinkType">
        <xs:sequence>
          <xs:element name="forceFunction">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Definiert die Kraftfunktion in Abhängigkeit der relativen Auslenkung der Kraftangriffspunkte
                und der relativen Geschwindigkeit zwischen den Kraftangriffspunkten.
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:choice>
                <xs:element ref="Function"/>
                <xs:element ref="pv:Embed"/>
              </xs:choice>
            </xs:complexType>
          </xs:element>
          <xs:element name="unloadedLength" type="pv:lengthScalar">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Entspannte Federlänge <object class="inlineeqn">l_0</object>.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="enableOpenMBV" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Wenn angegeben, wird das Feder-Dämpfer Element durch eine OpenMBV Feder in OpenMBV visualisiert.
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:sequence>
                <xs:group ref="OpenMBVCoilSpringParameters"/>
              </xs:sequence>
            </xs:complexType> 
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="DirectionalSpringDamper" substitutionGroup="FloatingFrameLink" type="DirectionalSpringDamperType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Definiert ein Feder-Dämpfer Element als Verbindung zwischen zwei Körpern. Es wird zwischen einer gerichteten Verbindung und einer Punkt-zu-Punkt-Verbindung unterschieden.
        <p>
          <i>Punkt-zu-Punkt-Verbindung.</i> Die Kraft des Feder-Dämpfer-Elements wird aus dem Abstand der verbundenen Punkte und der in diese Richtung projezierten relativen Geschwindigkeit berechnet. Der Abstand ist dabei immer positiv. Die Kraft wird ebenfalls in diese Richtung aufgebracht.
        </p>
        <p>
          <i>Gerichtete Verbindung.</i> Die Kraft des Feder-Dämpfer-Elements wird aus dem in die Richtung der angegebenen Projektionsrichtung projezierten Verbindungsvektor der beiden verbundenen Punkte sowie der in diese Richtung projezierten Relativgeschwindigkeit berechnet. Die Kraft wird in der angegebenen Projektionsrichtung aufgebracht. <br/>
          <b>Achtung!</b> Durch eine falsche Wahl der Projektionsrichtung wird unter Umständen das Momentengleichgewicht nicht mehr erfüllt.
        </p>
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="DirectionalSpringDamperType">
    <xs:complexContent>
      <xs:extension base="FloatingFrameLinkType">
        <xs:sequence>
          <xs:element name="forceDirection" type="pv:nounitVector">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Definiert die Wirkrichtung der Kraftanregung(en).
                Die Spalte i dieser Matrix definiert den Wirkrichtungsvektor des i-ten Eintrags der Kraftfunktion angegeben
                im KOS <code>frameOfReference</code>. Um eine Skalierung der skalaren Kraft (i-ter Eintrag der Kraftfunktion)
                zu umgehen, sollte jede Spalte dieser Matrix normiert sein.
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="forceFunction">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Definiert die Kraftfunktion in Abhängigkeit der relativen Auslenkung der Kraftangriffspunkte
                und der relativen Geschwindigkeit zwischen den Kraftangriffspunkten.
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:choice>
                <xs:element ref="Function"/>
                <xs:element ref="pv:Embed"/>
              </xs:choice>
            </xs:complexType>
          </xs:element>
          <xs:element name="unloadedLength" type="pv:lengthScalar">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Entspannte Federlänge <object class="inlineeqn">l_0</object>.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="enableOpenMBV" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Wenn angegeben, wird das Feder-Dämpfer Element durch eine OpenMBV Feder in OpenMBV visualisiert.
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:sequence>
                <xs:group ref="OpenMBVCoilSpringParameters"/>
              </xs:sequence>
            </xs:complexType> 
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="IsotropicRotationalSpringDamper" substitutionGroup="FrameLink" type="IsotropicRotationalSpringDamperType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Definiert ein rotatorisches Feder-Dämpfer Element als Verbindung zwischen zwei Körpern.
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="IsotropicRotationalSpringDamperType">
    <xs:complexContent>
      <xs:extension base="FrameLinkType">
        <xs:sequence>
          <xs:element name="elasticMomentFunction">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Definiert die Momentfunktion in Abhängigkeit der relativen Verdrehung der Kraftangriffspunkte.
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:choice>
                <xs:element ref="Function"/>
                <xs:element ref="pv:Embed"/>
              </xs:choice>
            </xs:complexType>
          </xs:element>
          <xs:element name="dissipativeMomentFunction">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Definiert die Momentfunktion in Abhängigkeit der relativen Winkelgeschwindigkeit der Kraftangriffspunkte.
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:choice>
                <xs:element ref="Function"/>
                <xs:element ref="pv:Embed"/>
              </xs:choice>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="GeneralizedSpringDamper" substitutionGroup="DualRigidBodyLink" type="GeneralizedSpringDamperType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
    tbd
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="GeneralizedSpringDamperType">
    <xs:complexContent>
      <xs:extension base="DualRigidBodyLinkType">
        <xs:sequence>
          <xs:element name="generalizedForceFunction">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
            tbd
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:choice>
                <xs:element ref="Function"/>
                <xs:element ref="pv:Embed"/>
              </xs:choice>
            </xs:complexType> 
          </xs:element>
          <xs:element name="generalizedUnloadedLength" type="pv:unknownScalar">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Entspannte Federlänge <object class="inlineeqn">l_0</object>.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="GeneralizedFriction" substitutionGroup="DualRigidBodyLink" type="GeneralizedFrictionType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
    tbd
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="GeneralizedFrictionType">
    <xs:complexContent>
      <xs:extension base="DualRigidBodyLinkType">
        <xs:sequence>
          <xs:element name="generalizedFrictionForceLaw">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
            tbd
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:choice>
                <xs:element ref="FrictionForceLaw"/>
                <xs:element ref="pv:Embed"/>
              </xs:choice>
            </xs:complexType> 
          </xs:element>
          <xs:element name="generalizedFrictionImpactLaw" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
            tbd
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:choice>
                <xs:element ref="FrictionImpactLaw"/>
                <xs:element ref="pv:Embed"/>
              </xs:choice>
            </xs:complexType>
          </xs:element>
          <xs:element name="generalizedNormalForceFunction">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
            tbd
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:choice>
                <xs:element ref="Function"/>
                <xs:element ref="pv:Embed"/>
              </xs:choice>
            </xs:complexType> 
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="GeneralizedClutch" substitutionGroup="DualRigidBodyLink" type="GeneralizedClutchType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
    tbd
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="GeneralizedClutchType">
    <xs:complexContent>
      <xs:extension base="DualRigidBodyLinkType">
        <xs:sequence>
          <xs:element name="generalizedFrictionForceLaw">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
            tbd
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:choice>
                <xs:element ref="FrictionForceLaw"/>
                <xs:element ref="pv:Embed"/>
              </xs:choice>
            </xs:complexType>
          </xs:element>
          <xs:element name="generalizedFrictionImpactLaw" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
            tbd
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:choice>
                <xs:element ref="FrictionImpactLaw"/>
                <xs:element ref="pv:Embed"/>
              </xs:choice>
            </xs:complexType>
          </xs:element>
          <xs:element name="engagementFunction" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
            tbd
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:choice>
                <xs:element ref="Function"/>
                <xs:element ref="pv:Embed"/>
              </xs:choice>
            </xs:complexType>
          </xs:element>
          <xs:element name="generalizedNormalForceFunction">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
            tbd
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:choice>
                <xs:element ref="Function"/>
                <xs:element ref="pv:Embed"/>
              </xs:choice>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="GeneralizedConnection" substitutionGroup="DualRigidBodyLink" type="GeneralizedConnectionType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
    tbd
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="GeneralizedConnectionType">
    <xs:complexContent>
      <xs:extension base="DualRigidBodyLinkType">
        <xs:sequence>
          <xs:element name="generalizedForceLaw">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
            tbd
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:choice>
                <xs:element ref="GeneralizedForceLaw"/>
                <xs:element ref="pv:Embed"/>
              </xs:choice>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="GeneralizedElasticConnection" substitutionGroup="DualRigidBodyLink" type="GeneralizedElasticConnectionType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
    tbd
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="GeneralizedElasticConnectionType">
    <xs:complexContent>
      <xs:extension base="DualRigidBodyLinkType">
        <xs:sequence>
          <xs:element name="generalizedForceFunction">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
            tbd
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:choice>
                <xs:element ref="Function"/>
                <xs:element ref="pv:Embed"/>
              </xs:choice>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="GeneralizedKinematicExcitation" abstract="true" substitutionGroup="DualRigidBodyLink" type="GeneralizedKinematicExcitationType">
  </xs:element>
  <xs:complexType name="GeneralizedKinematicExcitationType">
    <xs:complexContent>
      <xs:extension base="DualRigidBodyLinkType">
        <xs:sequence>
          <xs:element name="generalizedForceLaw">
            <xs:complexType>
              <xs:choice>
                <xs:element ref="GeneralizedForceLaw"/>
                <xs:element ref="pv:Embed"/>
              </xs:choice>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="GeneralizedPositionExcitation" substitutionGroup="GeneralizedKinematicExcitation" type="GeneralizedPositionExcitationType">
  </xs:element>
  <xs:complexType name="GeneralizedPositionExcitationType">
    <xs:complexContent>
      <xs:extension base="GeneralizedKinematicExcitationType">
        <xs:sequence>
          <xs:element name="excitationFunction">
            <xs:complexType>
              <xs:choice>
                <xs:element ref="Function"/>
                <xs:element ref="pv:Embed"/>
              </xs:choice>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="GeneralizedGear" substitutionGroup="RigidBodyLink" type="GeneralizedGearType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        TODO <br/>
        Kinematische Zwangsbedingung durch Angabe eines Übersetzungsverhältnisses.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="GeneralizedGearType">
    <xs:complexContent>
      <xs:extension base="RigidBodyLinkType">
        <xs:sequence>
          <xs:element name="gearOutput">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Getriebeausgang
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:attribute name="ref" type="ObjectReferenceType" use="required"/>
            </xs:complexType>
          </xs:element>
          <xs:element name="gearInput" minOccurs="1" maxOccurs="unbounded">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Getriebeeingang
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:attribute name="ref" type="ObjectReferenceType" use="required"/>
              <xs:attribute name="ratio" type="pv:floatFullEval" use="required"/>
            </xs:complexType>
          </xs:element>
          <xs:element name="generalizedForceLaw">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
            tbd
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:choice>
                <xs:element ref="GeneralizedForceLaw"/>
                <xs:element ref="pv:Embed"/>
              </xs:choice>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="GeneralizedElasticStructure" substitutionGroup="RigidBodyLink" type="GeneralizedElasticStructureType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        TODO <br/>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="GeneralizedElasticStructureType">
    <xs:complexContent>
      <xs:extension base="RigidBodyLinkType">
        <xs:sequence>
          <xs:element name="rigidBody" minOccurs="1" maxOccurs="unbounded">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Starrkörper
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:attribute name="ref" type="ObjectReferenceType" use="required"/>
            </xs:complexType>
          </xs:element>
          <xs:element name="generalizedForceFunction">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
            tbd
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:choice>
                <xs:element ref="Function"/>
                <xs:element ref="pv:Embed"/>
              </xs:choice>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="Joint" substitutionGroup="FloatingFrameLink" type="JointType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Definiert ein Gelenk als Verbindung zwischen zwei Körpern oder zwischen Körper und Umwelt.<br/>
        Aufgabe von Gelenken ist es, die Relativbewegung zwischen einzelnen Körpern eines Mehrkörpersystems einzuschränken und somit nur bestimmte Bewegungsmöglichkeiten zuzulassen. Die Relativbewegungen, die zwei Körper im ungebundenen Zustand durchführen könnten, werden dabei durch Gelenkkräfte und -momente verhindert.<br/> 
        Dabei wird idealisiert davon ausgegangen, dass Zwangsreaktionen punktuell zwischen zwei Koordinatensystemen übertragen werden.<br/>
        Wie der Betrag der Zwangsreaktionen berechnet wird, bestimmt das zugrunde liegende konstitutive Gesetz.<br/>
        Die Richtungen der Zwangsreaktion sind vom Benutzer anzugeben und bestimmen den Typ des Gelenks (z.B. Schub- / Drehgelenk usw.).
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="JointType">
    <xs:complexContent>
      <xs:extension base="FloatingFrameLinkType">
        <xs:sequence>
          <xs:sequence minOccurs="0">
            <xs:element name="forceDirection" type="pv:nounitMatrix">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                  Richtungen <object class="inlineeqn">\mathbf{D}_T=\left(\mathbf{d}_{T,1},\ldots\right)</object> der Zwangskräfte des Gelenks in normierten Vektoren dargestellt im Koordinatensystem <code>frameOfReference</code> (standarmäßig das erste KOS).
              </xs:documentation></xs:annotation>
            </xs:element>
            <xs:element name="forceLaw">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                  Definiert das konstitutive Gesetz bez. der Zwangskräfte auf Beschleunigungsebene (ausreichend für alle funktionellen Gesetze / ausreichend wenn keine Stöße im System auftreten und das System ereignisgesteuert integriert wird)
              </xs:documentation></xs:annotation>
              <xs:complexType>
                <xs:choice>
                  <xs:element ref="GeneralizedForceLaw"/>
                  <xs:element ref="pv:Embed"/>
                </xs:choice>
              </xs:complexType>
            </xs:element>
          </xs:sequence>
          <xs:sequence minOccurs="0">
            <xs:element name="momentDirection" type="pv:nounitMatrix">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                  Richtungen <object class="inlineeqn">\mathbf{D}_R=\left(\mathbf{d}_{R,1},\ldots\right)</object> der Zwangsmomente des Gelenks in normierten Vektoren dargestellt im Koordinatensystem <code>frameOfReference</code> (standarmäßig das erste KOS).
              </xs:documentation></xs:annotation>
            </xs:element>
            <xs:element name="momentLaw">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                  Definiert das konstitutive Gesetz bez. der Zwangsmomente auf Beschleunigungsebene (ausreichend für alle funktionellen Gesetze / ausreichend wenn keine Stöße im System auftreten und das System ereignisgesteuert integriert wird)
              </xs:documentation></xs:annotation>
              <xs:complexType>
                <xs:choice>
                  <xs:element ref="GeneralizedForceLaw"/>
                  <xs:element ref="pv:Embed"/>
                </xs:choice>
              </xs:complexType>
            </xs:element>
          </xs:sequence>
          <xs:element name="integrateGeneralizedRelativeVelocityOfRotation" type="pv:booleanFullEval" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Definiert, ob die generalisierte relative Position der Rotation durch Integration der generalisierten relativen Geschwindigkeit der Rotation berechnet werden soll. Default: False
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="angleMode" type="pv:stringFullEval" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Auswahl der Winkelmessmethode (nur relevant wenn integrateGeneralizedRelativeVelocityOfRotation auf False gesetzt ist):
              <ul>
                <li>smallAngles: (Default) Die Winkelmessung verfolgt nach Kleinwinkelnäherung.</li>
                <li>cardan: Die Winkelmessung erfolgt in nach "cardan" Winkeln.</li>
              </ul>
              Für alle Methoden werden entsprechende "Warning" Nachrichten ausgegeben welche den Gültigkeitsbereich der Methode beschreibt.
              Im Zweivelsfall sollte die Winkelmessung nicht benutzt werden und integrateGeneralizedRelativeVelocityOfRotation auf True gesetzt werden.
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="disableAngleWarning" type="pv:booleanFullEval" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Deaktiviert die "Warning" Nachrichten je nach Einstellung von "integrateGeneralizedRelativeVelocityOfRotation" und "angleMode". Default: False
              Sollte nur aktiviert werden wenn die entsprechenden "Warnings" für den Anwendungsfall nicht relevant sind.
            </xs:documentation></xs:annotation>
          </xs:element>
        </xs:sequence> 
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="ElasticJoint" substitutionGroup="FloatingFrameLink" type="ElasticJointType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Definiert ein Gelenk als elastische Verbindung zwischen zwei Körpern oder zwischen Körper und Umwelt.<br/>
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="ElasticJointType">
    <xs:complexContent>
      <xs:extension base="FloatingFrameLinkType">
        <xs:sequence>
          <xs:element name="forceDirection" type="pv:nounitMatrix" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Richtungen <object class="inlineeqn">\mathbf{D}_T=\left(\mathbf{d}_{T,1},\ldots\right)</object> der Zwangskräfte des Gelenks in normierten Vektoren dargestellt im Koordinatensystem <code>frameOfReference</code> (standarmäßig das erste KOS).
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="momentDirection" type="pv:nounitMatrix" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Richtungen <object class="inlineeqn">\mathbf{D}_R=\left(\mathbf{d}_{R,1},\ldots\right)</object> der Zwangsmomente des Gelenks in normierten Vektoren dargestellt im Koordinatensystem <code>frameOfReference</code> (standarmäßig das erste KOS).
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="generalizedForceFunction" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
            tbd
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:choice>
                <xs:element ref="Function"/>
                <xs:element ref="pv:Embed"/>
              </xs:choice>
            </xs:complexType>
          </xs:element>
          <xs:element name="integrateGeneralizedRelativeVelocityOfRotation" type="pv:booleanFullEval" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Definiert, ob die generalisierte relative Position der Rotation durch Integration der generalisierten relativen Geschwindigkeit der Rotation berechnet werden soll.
            </xs:documentation></xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="Contact" substitutionGroup="Link" type="ContactType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Definiert einen Kontakt als Interaktion zwischen mehreren Körpern.<br/>
        Bei der Simulation von Mehrkörpersystemen kann es aufgrund der Bewegung der Körper zu Kontakten zwischen einzelnen Körpern, aber auch zwischen einem Körper und der Umwelt kommen. Kommen zwei Körper in Kontakt, bildet sich an den sich berührenden Konturen (siehe <a class="link" href="mbsim:Contour">&lt;Contour&gt;</a>) eine Kontaktfläche aus, in der die Kontaktkräfte zwischen den Kontaktpartnern übertragen werden.<br/>
        Idealisiert wird davon ausgegangen, dass nur punktförmige Kontakte existieren; dies ist für eine Vielzahl von Problemstellungen ausreichend. Bei flächenhaften Kontakten muss die Oberfläche durch eine endliche Anzahl von Punkten diskretisiert werden.<br/>
        Es wird zwischen Kontaktkinematik und -kinetik unterschieden. In der Kontaktkinematik wird die relative Lage und Bewegung von zwei Konturen, also potentielle Kontaktpunkte, Abstand, relative Geschwindigkeiten in Konturnormalenrichtung und in der Tangentialebene der Kontur sowie u.U. auch Beschleunigungsgrößen bestimmt. Sie sind Eingangsgrößen der Kontaktkinetik und bestimmen somit anschließend die Kontaktkräfte über konstitutive Gesetze.
        <object class="figure" data="contact.svg">Kinematik einer Kontaktpaarung</object>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="ContactType">
    <xs:complexContent>
      <xs:extension base="LinkType">
        <xs:sequence>
          <xs:element name="connect">
           <xs:annotation>
             <xs:documentation xml:lang="de" xmlns="">
               Bindet zwei Konturen an einen Kontakt.
             </xs:documentation>
           </xs:annotation>
             <xs:complexType>
               <xs:attribute name="ref1" type="ContourReferenceType" use="required"/>
               <xs:attribute name="ref2" type="ContourReferenceType" use="required"/>
             </xs:complexType>
          </xs:element>
          <xs:element name="normalForceLaw">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Definiert das konstitutive Gesetz bez. der Kontaktkräfte auf Beschleunigungsebene in Konturnormalenrichtung (ausreichend für alle funktionellen Gesetze / ausreichend wenn keine Stöße im System auftreten und das System ereignisgesteuert integriert wird).
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:choice>
                <xs:element ref="GeneralizedForceLaw"/>
                <xs:element ref="pv:Embed"/>
              </xs:choice>
            </xs:complexType>
          </xs:element>
          <xs:element name="normalImpactLaw" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Definiert das konstitutive Gesetz bez. der Kontaktkräfte auf Geschwindigkeitsebene in Konturnormalenrichtung (nötig wenn Stöße im System auftreten oder das System mit Timestepping-Verfahren integriert wird).
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:choice>
                <xs:element ref="GeneralizedImpactLaw"/>
                <xs:element ref="pv:Embed"/>
              </xs:choice>
            </xs:complexType>
          </xs:element>
          <xs:sequence minOccurs="0">
            <xs:element name="tangentialForceLaw">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                  Definiert das konstitutive Reibgesetz bez. der Kontaktkräfte auf Beschleunigungssebene (ausreichend für alle funktionellen Gesetze / ausreichend wenn keine Stöße im System auftreten und das System ereignisgesteuert integriert wird).
              </xs:documentation></xs:annotation>
              <xs:complexType>
                <xs:choice>
                  <xs:element ref="FrictionForceLaw"/>
                  <xs:element ref="pv:Embed"/>
                </xs:choice>
              </xs:complexType>
            </xs:element>
            <xs:element name="tangentialImpactLaw" minOccurs="0">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                  Definiert das konstitutive Reibgesetz bez. der Kontaktkräfte auf Geschwindigkeitssebene (nötig wenn Stöße im System auftreten oder das System mit Timestepping-Verfahren integriert wird).
              </xs:documentation></xs:annotation>
              <xs:complexType>
                <xs:choice>
                  <xs:element ref="FrictionImpactLaw"/>
                  <xs:element ref="pv:Embed"/>
                </xs:choice>
              </xs:complexType>
            </xs:element>
          </xs:sequence>
          <xs:element name="globalSearch" minOccurs="0" type="pv:booleanFullEval">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Definiert, ob alle möglichen Kontaktpunkte gesucht werden sollen.
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="initialGlobalSearch" minOccurs="0" type="pv:booleanFullEval">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Definiert, ob initial alle möglichen Kontaktpunkte gesucht werden sollen.
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="initialGuess" minOccurs="0" type="pv:unknownMatrix">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Anfangswerte für Newton-Löser.
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="tolerance" minOccurs="0" type="pv:nounitScalar">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Toleranz für Newton-Löser.
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="maximumNumberOfContacts" minOccurs="0" type="pv:nounitScalar">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Maximale Anzahl an Kontakten.
            </xs:documentation></xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="MaxwellContact" substitutionGroup="Link" type="MaxwellContactType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
      tbd
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="MaxwellContactType">
    <xs:complexContent>
      <xs:extension base="LinkType">
        <xs:sequence>
          <xs:element name="connect" maxOccurs="unbounded">
           <xs:annotation>
             <xs:documentation xml:lang="de" xmlns="">
               Bindet zwei Konturen an einen Kontakt.
             </xs:documentation>
           </xs:annotation>
             <xs:complexType>
               <xs:attribute name="ref1" type="ContourReferenceType" use="required"/>
               <xs:attribute name="ref2" type="ContourReferenceType" use="required"/>
               <xs:attribute name="name" type="pv:stringPartialEval" use="optional"/>
             </xs:complexType>
          </xs:element>
          <xs:element name="normalForceLaw" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Definiert das konstitutive Gesetz bez. der Kontaktkräfte auf Beschleunigungsebene in Konturnormalenrichtung (ausreichend für alle funktionellen Gesetze / ausreichend wenn keine Stöße im System auftreten und das System ereignisgesteuert integriert wird).
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:choice>
                <xs:element ref="GeneralizedForceLaw"/>
                <xs:element ref="pv:Embed"/>
              </xs:choice>
            </xs:complexType>
          </xs:element>
          <xs:element name="normalImpactLaw" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Definiert das konstitutive Gesetz bez. der Kontaktkräfte auf Geschwindigkeitsebene in Konturnormalenrichtung (nötig wenn Stöße im System auftreten oder das System mit Timestepping-Verfahren integriert wird).
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:choice>
                <xs:element ref="GeneralizedImpactLaw"/>
                <xs:element ref="pv:Embed"/>
              </xs:choice>
            </xs:complexType>
          </xs:element>
          <xs:sequence minOccurs="0">
            <xs:element name="tangentialForceLaw">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                  Definiert das konstitutive Reibgesetz bez. der Kontaktkräfte auf Beschleunigungssebene (ausreichend für alle funktionellen Gesetze / ausreichend wenn keine Stöße im System auftreten und das System ereignisgesteuert integriert wird).
              </xs:documentation></xs:annotation>
              <xs:complexType>
                <xs:choice>
                  <xs:element ref="FrictionForceLaw"/>
                  <xs:element ref="pv:Embed"/>
                </xs:choice>
              </xs:complexType>
            </xs:element>
            <xs:element name="tangentialImpactLaw" minOccurs="0">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                  Definiert das konstitutive Reibgesetz bez. der Kontaktkräfte auf Geschwindigkeitssebene (nötig wenn Stöße im System auftreten oder das System mit Timestepping-Verfahren integriert wird).
              </xs:documentation></xs:annotation>
              <xs:complexType>
                <xs:choice>
                  <xs:element ref="FrictionImpactLaw"/>
                  <xs:element ref="pv:Embed"/>
                </xs:choice>
              </xs:complexType>
            </xs:element>
          </xs:sequence>
          <xs:element name="globalSearch" minOccurs="0" type="pv:booleanFullEval">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Definiert, ob alle möglichen Kontaktpunkte gesucht werden sollen.
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="initialGlobalSearch" minOccurs="0" type="pv:booleanFullEval">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Definiert, ob initial alle möglichen Kontaktpunkte gesucht werden sollen.
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="initialGuess" minOccurs="0" type="pv:unknownMatrix">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Anfangswerte für den Newton-Löser.
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="tolerance" minOccurs="0" type="pv:nounitScalar">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Toleranz für den Newton-Löser.
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="InfluenceFunction">
            <xs:complexType>
              <xs:choice>
                <xs:element ref="InfluenceFunction" maxOccurs="unbounded"/>
                <xs:element ref="pv:Embed"/>
              </xs:choice>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="DiskContact" substitutionGroup="ContourLink" type="DiskContactType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Definiert einen Scheibenkontakt.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="DiskContactType">
    <xs:complexContent>
      <xs:extension base="ContourLinkType">
        <xs:sequence>
          <xs:element name="normalForceLaw">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Definiert das konstitutive Gesetz bez. der Kontaktkräfte auf Beschleunigungsebene in Konturnormalenrichtung (ausreichend für alle funktionellen Gesetze / ausreichend wenn keine Stöße im System auftreten und das System ereignisgesteuert integriert wird).
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:choice>
                <xs:element ref="GeneralizedForceLaw"/>
                <xs:element ref="pv:Embed"/>
              </xs:choice>
            </xs:complexType>
          </xs:element>
          <xs:element name="normalImpactLaw" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Definiert das konstitutive Gesetz bez. der Kontaktkräfte auf Geschwindigkeitsebene in Konturnormalenrichtung (nötig wenn Stöße im System auftreten oder das System mit Timestepping-Verfahren integriert wird).
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:choice>
                <xs:element ref="GeneralizedImpactLaw"/>
                <xs:element ref="pv:Embed"/>
              </xs:choice>
            </xs:complexType>
          </xs:element>
          <xs:element name="tangentialForceLaw">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Definiert das konstitutive Reibgesetz bez. der Kontaktkräfte auf Beschleunigungssebene (ausreichend für alle funktionellen Gesetze / ausreichend wenn keine Stöße im System auftreten und das System ereignisgesteuert integriert wird).
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:choice>
                <xs:element ref="FrictionForceLaw"/>
                <xs:element ref="pv:Embed"/>
              </xs:choice>
            </xs:complexType>
          </xs:element>
          <xs:element name="tangentialImpactLaw" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Definiert das konstitutive Reibgesetz bez. der Kontaktkräfte auf Geschwindigkeitssebene (nötig wenn Stöße im System auftreten oder das System mit Timestepping-Verfahren integriert wird).
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:choice>
                <xs:element ref="FrictionImpactLaw"/>
                <xs:element ref="pv:Embed"/>
              </xs:choice>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="TyreContact" substitutionGroup="ContourLink" type="TyreContactType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
      Reifenkontakt.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="TyreContactType">
    <xs:complexContent>
      <xs:extension base="ContourLinkType">
        <xs:sequence>
          <xs:element name="tyreModel">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
            Auswahl des Reifenmodells.
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:choice>
                <xs:element ref="TyreModel"/>
                <xs:element ref="pv:Embed"/>
              </xs:choice>
            </xs:complexType>
          </xs:element>
          <xs:element name="initialGuess" minOccurs="0" type="pv:unknownMatrix">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Anfangswerte für den Newton-Löser zur Kontaktpunktsuche.
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="tolerance" minOccurs="0" type="pv:nounitScalar">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Toleranz für den Newton-Löser zur Kontaktpunktsuche.
            </xs:documentation></xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="Frame" substitutionGroup="Element" type="FrameType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Klasse zur Beschreibung von Koordinatensystemen.
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="FrameType">
    <xs:complexContent>
      <xs:extension base="ElementType">
        <xs:sequence>
          <xs:element name="enableOpenMBV" minOccurs="0">  
            <xs:complexType>
              <xs:group ref="OpenMBVFrameParameters"/>
            </xs:complexType> 
          </xs:element>
        </xs:sequence> 
      </xs:extension>
    </xs:complexContent>
  </xs:complexType> 

  <xs:element name="FixedRelativeFrame" substitutionGroup="Frame" type="FixedRelativeFrameType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Klasse zur Beschreibung von Koordinatensystemen.
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="FixedRelativeFrameType">
    <xs:complexContent>
      <xs:extension base="FrameType">
        <xs:sequence>
          <xs:element name="frameOfReference" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Koordinatensystem, in dem die Positionierung des KOS angegeben wird.<br/>
                Standardmässig "I"-System der Gruppe bzw. "C"-System des RigidBody.
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:attribute name="ref" type="ParentFrameReferenceType" use="required"/>
            </xs:complexType>
          </xs:element>
          <xs:element name="relativePosition" type="pv:lengthVector" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Relative Lage des Koordinatensystems.<br/>
                Vektor von <code>frameOfReference</code> zum Ursprung des neuen KOS dargestellt
                im KOS <code>frameOfReference</code>.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="relativeOrientation" type="pv:rotationMatrix" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Relative Orientierung des Koordinatensystems.<br/>
                Transformationsmatrix vom neuen KOS ins KOS <code>frameOfReference</code>.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType> 

  <xs:element name="Contour" abstract="true" substitutionGroup="Element" type="ContourType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Abstrakte Klasse für Kontaktkonturen.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="ContourType">
    <xs:complexContent>
      <xs:extension base="ElementType">
        <xs:sequence>
          <xs:element name="thickness" type="pv:lengthScalar" minOccurs="0">
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="RigidContour" abstract="true" substitutionGroup="Contour" type="RigidContourType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Abstrakte Klasse für starre Konturen.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="RigidContourType">
    <xs:complexContent>
      <xs:extension base="ContourType">
        <xs:sequence>
          <xs:element name="frameOfReference" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Koordinatensystem, in dem die Positionierung des KOS angegeben wird.<br/>
                Standardmässig "I"-System der Gruppe bzw. "C"-System des RigidBody.
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:attribute name="ref" type="FrameReferenceType" use="required"/>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="Circle" substitutionGroup="RigidContour" type="CircleType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Ebene Kontur eines Circle.<br/>
        Die Kreiskontur liegt normal zur z-Achse des Referenzkoordinatensystems.
        <object class="figure" data="contour_circlehollow.svg">Orientierung einer Cicle-Kontur (hollow-Circle)</object>
        <object class="figure" data="contour_circlesolid.svg">Orientierung einer Cicle-Kontur (solid-Circle)</object>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="CircleType">
    <xs:complexContent>
      <xs:extension base="RigidContourType">
        <xs:sequence>
          <xs:element name="radius" type="pv:lengthScalar">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Definiert den Radius des Kreises.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="solid" type="pv:booleanFullEval" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Definiert, ob der Kreis ein Vollkreis ist.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="enableOpenMBV" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Aktiviert die Visualisierung der Kontur.
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:group ref="OpenMBVColoredBodyParameters"/>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="Cylinder" substitutionGroup="RigidContour" type="CylinderType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Kontur eines Zylinders.<br/>
        Die Kontur liegt normal zur z-Achse des Referenzkoordinatensystems.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="CylinderType">
    <xs:complexContent>
      <xs:extension base="RigidContourType">
        <xs:sequence>
          <xs:element name="radius" type="pv:lengthScalar">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Definiert den Radius des Zylinders.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="height" type="pv:lengthScalar">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Definiert die Höhe des Zylinders.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="solid" type="pv:booleanFullEval" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Definiert, ob der Zylinder ein Vollzylinder ist.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="enableOpenMBV" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Aktiviert die Visualisierung der Kontur.
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:group ref="OpenMBVColoredBodyParameters"/>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="Frustum" substitutionGroup="RigidContour" type="FrustumType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Kontur eines Kegelstumpfes, die über Variation der zu definierenden Größen auch Kegel und Zylinder abdeckt.<br/>
        Die Symmetrieachse fällt mit der y-Achse des Referenzkoordinationsystems zusammen. Zu definierende geometrische Größen sind in der Zeichnung eingetragen.      
        <object class="figure" data="contour_frustum.svg">Orientierung und geometrische Größen einer Frustum-Kontur</object>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="FrustumType">
    <xs:complexContent>
      <xs:extension base="RigidContourType">
        <xs:sequence>
          <xs:element name="baseRadius" type="pv:lengthScalar">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Radius des Fußkreises.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="topRadius" type="pv:lengthScalar">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Radius des Kopfkreises.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="height" type="pv:lengthScalar">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Höhe des Kegelstumpfes.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:choice>
            <xs:element name="solid">
              <xs:annotation>
                <xs:documentation xml:lang="de" xmlns="">
                  Als Kontaktkontur wird die Ausfläche des Kegelstumpfes gewählt.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType/>
            </xs:element>
            <xs:element name="hollow">
              <xs:annotation>
                <xs:documentation xml:lang="de" xmlns="">
                  Als Kontaktkontur wird die Innenfläche des Kegelstumpfes gewählt.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType/>
            </xs:element>
          </xs:choice>
          <xs:element name="enableOpenMBV" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Aktiviert die Visualisierung der Kontur.
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:group ref="OpenMBVColoredBodyParameters"/>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="Line" substitutionGroup="RigidContour" type="LineType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Einfache, unendlich ausgedehnte Linienkontur.<br/>
        Die Linie verläuft in Richtung der y-Achse des Referenzkoordinatensystems, die Normale weist in die Richtung der x-Achse des Referenzkoordinatensystems.
        <object class="figure" data="contour_line.svg">Orientierung einer Line-Kontur</object>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="LineType">
    <xs:complexContent>
      <xs:extension base="RigidContourType">
        <xs:sequence>
          <xs:element name="enableOpenMBV" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Aktiviert die Visualisierung der Kontur.
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:group ref="OpenMBVLineParameters"/>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
   </xs:complexContent>
  </xs:complexType>

  <xs:element name="LineSegment" substitutionGroup="RigidContour" type="LineSegmentType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Einfache Linienkontur mit endlicher Ausdehnung.<br/>
        Die Linie verläuft in Richtung der y-Achse des Referenzkoordinatensystems, die Normale weist in die Richtung der x-Achse des Referenzkoordinatensystems.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="LineSegmentType">
    <xs:complexContent>
      <xs:extension base="RigidContourType">
        <xs:sequence>
          <xs:element name="length" type="pv:lengthScalar">
          </xs:element>
          <xs:element name="enableOpenMBV" minOccurs="0">
            <xs:complexType>
              <xs:group ref="OpenMBVColoredBodyParameters"/>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="CompoundContour" substitutionGroup="RigidContour" abstract="true"  type="CompoundContourType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Abstrakte Basisklasse für Gruppen von Kontouren.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="CompoundContourType">
    <xs:complexContent>
      <xs:extension base="RigidContourType"/>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="Cuboid" substitutionGroup="CompoundContour" type="CuboidType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Quaderkontour bestehenden aus 8 Punkten, 6 Flächen und 12 Kanten.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="CuboidType">
    <xs:complexContent>
      <xs:extension base="CompoundContourType">
        <xs:sequence>
          <xs:element name="length" type="pv:lengthVector"/>
          <xs:element name="enableOpenMBV" minOccurs="0">
            <xs:complexType>
              <xs:group ref="OpenMBVColoredBodyParameters"/>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="Plane" substitutionGroup="RigidContour" type="PlaneType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Unendlich ausgedehnte Ebenenkontur.<br/>
        Die Ebene wird durch die y- und z-Achse des Referenzkoordinatensystems beschrieben.
        <object class="figure" data="contour_plane.svg">Orientierung einer Plane-Kontur</object>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="PlaneType">
    <xs:complexContent>
      <xs:extension base="RigidContourType">
        <xs:sequence>
          <xs:element name="enableOpenMBV" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Aktiviert die Visualisierung der Kontur.
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:group ref="OpenMBVPlaneParameters"/>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="PlaneWithFrustum" substitutionGroup="RigidContour" type="PlaneWithFrustumType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Eine Kontur, die aus einer Ebene und einem Kegelstumpf (Frustum) besteht.<br/>
        Die Ebene wird wie gezeichnet durch die y- und z-Achse des Referenzkoordinatensystems aufgespannt, die Rotationsachse des Kegelstumpfes ist die x-Achse des Referenzkoordinatensystems. Für eine Kegelstumpf-Höhe h&gt;0 erstreckt sich die Kegelstumpfkontur in Richtung der positiven x-Achse des Referenzkoordinatensystems. <object class="inlineeqn">\rho</object> ist der Radius der Verrundung zwischen Ebene und Kegelstumpf und am Kopf des Kegelstumpfes.
        <object class="figure" data="contour_planewithfrustum.svg">Orientierung einer PlaneWithFrustum-Kontur</object>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="PlaneWithFrustumType">
    <xs:complexContent>
      <xs:extension base="RigidContourType">
        <xs:sequence>
          <xs:element name="baseRadius" type="pv:lengthScalar">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Radius des Fußkreises.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="topRadius" type="pv:lengthScalar">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Radius des Kopfkreises.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="height" type="pv:lengthScalar">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Höhe des Kegelstumpfes.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="roundingRadius" type="pv:lengthScalar">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Verrundungsradius, einmal zwischen Ebene und Kegelstumpf und einmal zwischen Kegelstumpf und Deckfläche des Kegelstumpfes (wie gezeichnet).
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="enableOpenMBV" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Aktiviert die Visualisierung der Kontur.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="Point" substitutionGroup="RigidContour" type="PointType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Kontur eines einzelnen Punktes.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="PointType">
    <xs:complexContent>
      <xs:extension base="RigidContourType">
        <xs:sequence>
          <xs:element name="enableOpenMBV" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Aktiviert die Visualisierung der Kontur.
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:group ref="OpenMBVColoredBodyParameters"/>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="Sphere" substitutionGroup="RigidContour" type="SphereType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Kontur einer Kugel.<br/>
        r gibt den Radius der Kugel an
        <object class="figure" data="contour_sphere.svg">Geometrie einer Sphere-Kontur</object>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="SphereType">
    <xs:complexContent>
      <xs:extension base="RigidContourType">
        <xs:sequence>
          <xs:element name="radius" type="pv:lengthScalar">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Radius der Kugel.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="enableOpenMBV" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Aktiviert die Visualisierung der Kontur.
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:group ref="OpenMBVColoredBodyParameters"/>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="ContourContinuum" substitutionGroup="Contour" abstract="true" type="ContourContinuumType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Abstrakte Klasse zur Beschreibung kontinuierlicher Konturen.<br/>
        Die Konturen werden in Abhängigkeit eines Parameters <object class="inlineeqn">\alpha \, \left(\alpha_{Start} \leq \alpha \leq \alpha_{End} \right)</object> beschrieben. Für eine effiziente Abstandsberechnung müssen vom Benutzer zusätzliche Stützstellen angegeben werden, anhand derer eine erste Abschätzung des Kontaktbereiches erfolgt.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="ContourContinuumType">
    <xs:complexContent>
      <xs:extension base="ContourType">
        <xs:sequence>
          <xs:element name="alphaStart" type="pv:nounitScalar">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Startwert des Laufparameters <object class="inlineeqn">\alpha</object>.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="alphaEnd" type="pv:nounitScalar">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Endwert des Laufparameters <object class="inlineeqn">\alpha</object>.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="nodes" type="pv:nounitScalar">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Stützstellen.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="Contour1s" substitutionGroup="ContourContinuum" abstract="true" type="Contour1sType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Abstrakte Klasse zur Beschreibung beliebiger Konturen, die durch eine räumliche Kurve beschrieben werden können. 
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="Contour1sType">
    <xs:complexContent>
      <xs:extension base="ContourContinuumType">
        <xs:sequence>
          <xs:element name="diameter" type="pv:lengthScalar">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Durchmesser der Kurvenkontur.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="PlanarContour" substitutionGroup="RigidContour" type="PlanarContourType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Kurvenkontur, bei der die Parametrisierung analytisch durch einen funktionalen Zusammenhang beschrieben werden kann:
        <object class="eqn">
          <![CDATA[\mathbf{f}:\,\mathbf{R}\rightarrow\mathbf{R}^3;\quad\alpha\mapsto\mathbf{f} \left(\alpha\right)=
          \left(\begin{array}{c}
          f_x\left(\alpha\right) \\
          f_y\left(\alpha\right) \\
          f_z\left(\alpha\right)
          \end{array}\right)]]>
        </object>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="PlanarContourType">
    <xs:complexContent>
      <xs:extension base="RigidContourType">
        <xs:sequence>
          <xs:element name="nodes" type="pv:nounitVector">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                tbd
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="contourFunction">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Beschreibung der Kontur.
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:choice>
                <xs:element ref="Function"/>
                <xs:element ref="pv:Embed"/>
              </xs:choice>
            </xs:complexType>
          </xs:element>
          <xs:element name="open" minOccurs="0" type="pv:booleanFullEval">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Definiert, ob die Kontur offen ist.
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="enableOpenMBV" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Aktiviert die Visualisierung der Kontur.
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:group ref="OpenMBVPlanarContourParameters"/>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="PlanarNurbsContour" substitutionGroup="RigidContour" type="PlanarNurbsContourType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Ebene NURBS Kontur.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="PlanarNurbsContourType">
    <xs:complexContent>
      <xs:extension base="RigidContourType">
        <xs:sequence>
          <xs:element name="interpolation" type="pv:stringFullEval" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Auswahl der Interpolationsmethode.
              <ul>
                <li>equallySpaced: "equally spaced" Interpolation</li>
                <li>chordLength: "chord length" Interpolation</li>
                <li>none: keine Interpolation</li>
              </ul>
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="controlPoints" type="pv:nounitMatrix">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Kontrollpunkte.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="numberOfControlPoints" type="pv:integerFullEval">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Anzahl der Kontrollpunkte.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="knotVector" type="pv:nounitVector" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Knotenvektor.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="degree" type="pv:integerFullEval" minOccurs="0" >
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
               Polynomgrad.
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="open" minOccurs="0" type="pv:booleanFullEval">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Definiert, ob die Kontur offen ist.
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="enableOpenMBV" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Aktiviert die Visualisierung der Kontur.
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:group ref="OpenMBVColoredBodyParameters"/>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="SpatialContour" substitutionGroup="RigidContour" type="SpatialContourType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Kurvenkontur, bei der die Parametrisierung analytisch durch einen funktionalen Zusammenhang beschrieben werden kann:
        <object class="eqn">
          <![CDATA[\mathbf{f}:\,\mathbf{R}\rightarrow\mathbf{R}^3;\quad\alpha\mapsto\mathbf{f} \left(\alpha\right)=
          \left(\begin{array}{c}
          f_x\left(\alpha\right) \\
          f_y\left(\alpha\right) \\
          f_z\left(\alpha\right)
          \end{array}\right)]]>
        </object>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="SpatialContourType">
    <xs:complexContent>
      <xs:extension base="RigidContourType">
        <xs:sequence>
          <xs:element name="etaNodes" type="pv:nounitVector">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                tbd
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="xiNodes" type="pv:nounitVector">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                tbd
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="contourFunction">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Beschreibung der Kontur.
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:choice>
                <xs:element ref="Function"/>
                <xs:element ref="pv:Embed"/>
              </xs:choice>
            </xs:complexType> 
          </xs:element>
          <xs:element name="openEta" minOccurs="0" type="pv:booleanFullEval">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Definiert, ob die Kontur in eta-Richtung offen ist.
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="openXi" minOccurs="0" type="pv:booleanFullEval">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Definiert, ob die Kontur in xi-Richtung offen ist.
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="enableOpenMBV" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Aktiviert die Visualisierung der Kontur.
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:group ref="OpenMBVSpatialContourParameters"/>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="SpatialNurbsContour" substitutionGroup="RigidContour" type="SpatialNurbsContourType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Räumliche NURBS Kontur.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="SpatialNurbsContourType">
    <xs:complexContent>
      <xs:extension base="RigidContourType">
        <xs:sequence>
          <xs:element name="interpolation" type="pv:stringFullEval" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Auswahl der Interpolationsmethode.
              <ul>
                <li>equallySpaced: "equally spaced" Interpolation</li>
                <li>chordLength: "chord length" Interpolation</li>
                <li>none: keine Interpolation</li>
              </ul>
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="controlPoints" type="pv:nounitMatrix">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Kontrollpunkte.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="numberOfEtaControlPoints" type="pv:integerFullEval">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Anzahl der Kontrollpunkte in eta-Richtung.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="numberOfXiControlPoints" type="pv:integerFullEval">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Anzahl der Kontrollpunkte in xi-Richtung.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="etaKnotVector" type="pv:nounitVector" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Knotenvektor in eta-Richtung.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="xiKnotVector" type="pv:nounitVector" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Knotenvektor in xi-Richtung.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="etaDegree" type="pv:integerFullEval" minOccurs="0" >
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
               Polynomgrad in eta-Richtung.
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="xiDegree" type="pv:integerFullEval" minOccurs="0" >
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
               Polynomgrad in xi-Richtung.
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="openEta" minOccurs="0" type="pv:booleanFullEval">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Definiert, ob die Kontur in eta-Richtung offen ist.
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="openXi" minOccurs="0" type="pv:booleanFullEval">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Definiert, ob die Kontur in xi-Richtung offen ist.
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="enableOpenMBV" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Aktiviert die Visualisierung der Kontur.
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:group ref="OpenMBVColoredBodyParameters"/>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="Disk" substitutionGroup="RigidContour" type="DiskType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Kontur einer Scheibe.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="DiskType">
    <xs:complexContent>
      <xs:extension base="RigidContourType">
        <xs:sequence>
          <xs:element name="outerRadius" type="pv:lengthScalar">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Definiert den äußeren Radius der Scheibe.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="width" type="pv:lengthScalar">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Definiert die Breite der Scheibe.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="innerRadius" type="pv:lengthScalar" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Definiert den inneren Radius der Scheibe.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="enableOpenMBV" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Aktiviert die Visualisierung der Kontur.
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:group ref="OpenMBVColoredBodyParameters"/>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="CylindricalGear" substitutionGroup="RigidContour" type="CylindricalGearType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Kontur eines Stirnrades.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="CylindricalGearType">
    <xs:complexContent>
      <xs:extension base="RigidContourType">
        <xs:sequence>
          <xs:element name="numberOfTeeth" type="pv:integerFullEval">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Definiert die Anzahl der Zähne des Stirnrades.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="width" type="pv:lengthScalar">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Definiert die Breite des Stirnrades.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="helixAngle" type="pv:angleScalar" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Definiert den Schrägungswinkel des Stirnrades.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="module" type="pv:lengthScalar" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Definiert den Modul des Stirnrades.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="pressureAngle" type="pv:angleScalar" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Definiert den Normeingriffswinkel des Stirnrades.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="backlash" type="pv:lengthScalar" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Definiert das Zahnspiel des Stirnrades.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="externalToothed" type="pv:booleanFullEval" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Definiert, ob das Stirnrad außen oder innen verzahnt ist.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="outsideRadius" type="pv:lengthScalar" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Definiert den Außenradius, wenn das Stirnrad innen verzahnt ist (Hohlrad).
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="enableOpenMBV" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Aktiviert die Visualisierung der Kontur.
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:group ref="OpenMBVColoredBodyParameters"/>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="Rack" substitutionGroup="RigidContour" type="RackType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Kontur einer Zahnstange.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="RackType">
    <xs:complexContent>
      <xs:extension base="RigidContourType">
        <xs:sequence>
          <xs:element name="numberOfTeeth" type="pv:integerFullEval">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Definiert die Anzahl der Zähne der Zahnstange.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="height" type="pv:lengthScalar">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Definiert die Höhe der Zahnstange.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="width" type="pv:lengthScalar">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Definiert die Breite der Zahnstange.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="helixAngle" type="pv:angleScalar" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Definiert den Schrägungswinkel der Zahnstange.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="module" type="pv:lengthScalar" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Definiert den Modul der Zahnstange.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="pressureAngle" type="pv:angleScalar" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Definiert den Normeingriffswinkel der Zahnstange.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="backlash" type="pv:lengthScalar" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Definiert das Zahnspiel der Zahnstange.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="enableOpenMBV" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Aktiviert die Visualisierung der Kontur.
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:group ref="OpenMBVColoredBodyParameters"/>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="BevelGear" substitutionGroup="RigidContour" type="BevelGearType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Kontur eines Kegelrades.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="BevelGearType">
    <xs:complexContent>
      <xs:extension base="RigidContourType">
        <xs:sequence>
          <xs:element name="numberOfTeeth" type="pv:integerFullEval">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Definiert die Anzahl der Zähne des Kegelrades.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="width" type="pv:lengthScalar">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Definiert die Breite des Kegelrades.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="helixAngle" type="pv:angleScalar" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Definiert den Schrägungswinkel des Kegelrades.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="pitchAngle" type="pv:angleScalar" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Definiert den Kegelwinkel des Kegelrades.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="module" type="pv:lengthScalar" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Definiert den Modul des Kegelrades.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="pressureAngle" type="pv:angleScalar" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Definiert den Normeingriffswinkel des Kegelrades.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="backlash" type="pv:lengthScalar" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Definiert das Zahnspiel des Kegelrades.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="enableOpenMBV" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Aktiviert die Visualisierung der Kontur.
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:group ref="OpenMBVColoredBodyParameters"/>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="PlanarGear" substitutionGroup="RigidContour" type="PlanarGearType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Kontur eines Planrades.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="PlanarGearType">
    <xs:complexContent>
      <xs:extension base="RigidContourType">
        <xs:sequence>
          <xs:element name="numberOfTeeth" type="pv:integerFullEval">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Definiert die Anzahl der Zähne des Planrades.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="height" type="pv:lengthScalar">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Definiert die Höhe des Planrades.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="width" type="pv:lengthScalar">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Definiert die Breite des Planrades.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="helixAngle" type="pv:angleScalar" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Definiert den Schrägungswinkel des Planrades.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="module" type="pv:lengthScalar" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Definiert den Modul des Planrades.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="pressureAngle" type="pv:angleScalar" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Definiert den Normeingriffswinkel des Planrades.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="backlash" type="pv:lengthScalar" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Definiert das Zahnspiel des Planrades.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="enableOpenMBV" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Aktiviert die Visualisierung der Kontur.
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:group ref="OpenMBVColoredBodyParameters"/>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="Tyre" substitutionGroup="RigidContour" type="TyreType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
      tbd
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="TyreType">
    <xs:complexContent>
      <xs:extension base="RigidContourType">
        <xs:sequence>
          <xs:choice>
            <xs:element name="radius" type="pv:lengthScalar">
              <xs:annotation>
                <xs:documentation xml:lang="de" xmlns="">
                  Definiert den Außenradius des unbelasteten Reifens.
                </xs:documentation>
              </xs:annotation>
            </xs:element>
            <xs:element name="unloadedRadius" type="pv:lengthScalar">
              <xs:annotation>
                <xs:documentation xml:lang="de" xmlns="">
                  Definiert den Außenradius des unbelasteten Reifens.
                </xs:documentation>
              </xs:annotation>
            </xs:element>
          </xs:choice>
          <xs:element name="rimRadius" type="pv:lengthScalar" minOccurs="0">
            <xs:annotation>
               <xs:documentation xml:lang="de" xmlns="">
                 Definiert den Felgenradius des Reifens.
               </xs:documentation>
             </xs:annotation>
           </xs:element>
          <xs:element name="width" type="pv:lengthScalar" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Definiert die Breite des Reifens.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="shapeOfCrossSectionContour" type="pv:stringFullEval" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
	        tbd
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="contourParameters" type="pv:lengthVector" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Definiert die Parameter der Kontourellipse des Reifens.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="enableOpenMBV" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Aktiviert die Visualisierung der Kontur.
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:group ref="OpenMBVColoredBodyParameters"/>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="GeneralizedForceLaw" abstract="true" type="GeneralizedForceLawType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Abstrakte Oberklasse zur Beschreibung konstitutiver Gesetze auf Beschleunigungsebene.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="GeneralizedForceLawType"/>

  <xs:element name="BilateralConstraint" substitutionGroup="GeneralizedForceLaw" type="BilateralConstraintType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Konstitutives Gesetz zur Beschreibung einer mengenwertigen zweiseitigen Bindung auf Beschleunigungsebene. 
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="BilateralConstraintType">
    <xs:complexContent>
      <xs:extension base="GeneralizedForceLawType"/>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="UnilateralConstraint" substitutionGroup="GeneralizedForceLaw" type="UnilateralConstraintType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Konstitutives Gesetz auf Beschleunigunssebene zur Beschreibung einer mengenwertigen einseitigen Bindung. 
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="UnilateralConstraintType">
    <xs:complexContent>
      <xs:extension base="GeneralizedForceLawType"/>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="GeneralizedImpactLaw" abstract="true" type="GeneralizedImpactLawType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Abstrakte Oberklasse zur Beschreibung konstitutiver Gesetze auf Geschwindigkeitsebene.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="GeneralizedImpactLawType"/>

  <xs:element name="BilateralImpact" substitutionGroup="GeneralizedImpactLaw" type="BilateralImpactType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Konstitutives Gesetz auf Geschwindigkeitsebene zur Beschreibung einer mengenwertigen zweiseitigen Bindung. 
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="BilateralImpactType">
    <xs:complexContent>
      <xs:extension base="GeneralizedImpactLawType"/>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="UnilateralNewtonImpact" substitutionGroup="GeneralizedImpactLaw" type="UnilateralNewtonImpactType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Konstitutives Gesetz auf Geschwindigkeitsebene zur Beschreibung eines Newton-Stoßes. 
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="UnilateralNewtonImpactType">
    <xs:complexContent>
      <xs:extension base="GeneralizedImpactLawType">
        <xs:sequence>
          <xs:element name="restitutionCoefficient" type="pv:nounitScalar">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Stoßzahl. Wert zwischen 0 (plastisch) und 1 (vollelastisch).
              </xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence> 
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="RegularizedConstraint" substitutionGroup="GeneralizedForceLaw" type="RegularizedConstraintType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Konstitutives Gesetz zur Beschreibung einer regularisierten Bindung.
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="RegularizedConstraintType">
    <xs:complexContent>
      <xs:extension base="GeneralizedForceLawType">
        <xs:sequence>
          <xs:element name="forceFunction">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Konstitutive zweiparametrige Funktion <object class="inlineeqn">\lambda=\lambda\left(g,\dot{g}\right)</object> zur Auswertung der Reaktion basierend auf relativer Distanz g und Geschwindigkeit <object class="inlineeqn">\dot{g}</object>.  
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:choice>
                <xs:element ref="Function"/>
                <xs:element ref="pv:Embed"/>
              </xs:choice>
            </xs:complexType> 
          </xs:element>
        </xs:sequence> 
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="RegularizedBilateralConstraint" substitutionGroup="RegularizedConstraint" type="RegularizedBilateralConstraintType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Konstitutives Gesetz zur Beschreibung einer regularisierten zweiseitigen Bindung.
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="RegularizedBilateralConstraintType">
    <xs:complexContent>
      <xs:extension base="RegularizedConstraintType"/>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="RegularizedUnilateralConstraint" substitutionGroup="RegularizedConstraint" type="RegularizedUnilateralConstraintType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Konstitutives Gesetz zur Beschreibung einer regularisierten einseitigen Bindung. 
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="RegularizedUnilateralConstraintType">
    <xs:complexContent>
      <xs:extension base="RegularizedConstraintType"/>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="FrictionForceLaw" abstract="true" type="FrictionForceLawType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Abstrakte Oberklasse zur Beschreibung von Reibgesetzen auf Beschleunigungsebene. 
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="FrictionForceLawType"/>

  <xs:element name="RegularizedFriction" substitutionGroup="FrictionForceLaw" type="RegularizedFrictionType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Definiert beliebige regularisierte und damit funktionale Reibgesetze.
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="RegularizedFrictionType">
    <xs:complexContent>
      <xs:extension base="FrictionForceLawType">
        <xs:sequence>
          <xs:element name="frictionForceFunction">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Reibgesetze der Form <object class="inlineeqn">\boldsymbol{F}_R=\boldsymbol{F}_R\left(\dot{\boldsymbol{g}}_T,\left\|\boldsymbol{F}_N\right\|\right)</object> basierend auf tangentialer relativer Geschwindigkeit und Betrag der Normalkraft
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:choice>
                <xs:element ref="Function"/>
                <xs:element ref="pv:Embed"/>
              </xs:choice>
            </xs:complexType> 
          </xs:element>
        </xs:sequence> 
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="RegularizedPlanarFriction" substitutionGroup="RegularizedFriction" type="RegularizedPlanarFrictionType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Definiert beliebige ebene regularisierte und damit funktionale Reibgesetze.
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="RegularizedPlanarFrictionType">
    <xs:complexContent>
      <xs:extension base="RegularizedFrictionType"/>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="RegularizedSpatialFriction" substitutionGroup="RegularizedFriction" type="RegularizedSpatialFrictionType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Definiert beliebige räumliche regularisierte und damit funktionale Reibgesetze. 
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="RegularizedSpatialFrictionType">
    <xs:complexContent>
      <xs:extension base="RegularizedFrictionType"/>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="SpatialCoulombFriction" substitutionGroup="FrictionForceLaw" type="SpatialCoulombFrictionType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Definiert räumliche Coulomb-Reibung auf Beschleunigungsebene. 
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="SpatialCoulombFrictionType">
    <xs:complexContent>
      <xs:extension base="FrictionForceLawType">
        <xs:sequence>
          <xs:element name="frictionCoefficient" type="pv:nounitScalar">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Konstanter Reibkoeffizient. 
            </xs:documentation></xs:annotation>
          </xs:element>
        </xs:sequence> 
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="PlanarCoulombFriction" substitutionGroup="FrictionForceLaw" type="PlanarCoulombFrictionType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Definiert ebene Coulomb-Reibung auf Beschleunigungsebene. 
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="PlanarCoulombFrictionType">
    <xs:complexContent>
      <xs:extension base="FrictionForceLawType">
        <xs:sequence>
          <xs:element name="frictionCoefficient" type="pv:nounitScalar">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Konstanter Reibkoeffizient. 
            </xs:documentation></xs:annotation>
          </xs:element>
        </xs:sequence> 
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="SpatialStribeckFriction" substitutionGroup="FrictionForceLaw" type="SpatialStribeckFrictionType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Definiert räumliche Stribeck-Reibung auf Beschleunigungsebene.
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="SpatialStribeckFrictionType">
    <xs:complexContent>
      <xs:extension base="FrictionForceLawType">
        <xs:sequence>
          <xs:element name="frictionFunction">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Definiert den Reibkoeffizienten in Abhängigkeit der Relativgeschwindigkeit.
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:choice>
                <xs:element ref="Function"/>
                <xs:element ref="pv:Embed"/>
              </xs:choice>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="PlanarStribeckFriction" substitutionGroup="FrictionForceLaw" type="PlanarStribeckFrictionType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Definiert ebene Stribeck-Reibung auf Beschleunigungsebene.
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="PlanarStribeckFrictionType">
    <xs:complexContent>
      <xs:extension base="FrictionForceLawType">
        <xs:sequence>
          <xs:element name="frictionFunction">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Definiert den Reibkoeffizienten in Abhängigkeit der Relativgeschwindigkeit.
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:choice>
                <xs:element ref="Function"/>
                <xs:element ref="pv:Embed"/>
              </xs:choice>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="FrictionImpactLaw" abstract="true" type="FrictionImpactLawType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Abstrakte Oberklasse zur Beschreibung von Reibgesetzen auf Geschwindigkeitsebene. 
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="FrictionImpactLawType"/>

  <xs:element name="SpatialCoulombImpact" substitutionGroup="FrictionImpactLaw" type="SpatialCoulombImpactType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Definiert räumliche Coulomb-Reibung auf Geschwindigkeitssebene. 
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="SpatialCoulombImpactType">
    <xs:complexContent>
      <xs:extension base="FrictionImpactLawType">
        <xs:sequence>
          <xs:element name="frictionCoefficient" type="pv:nounitScalar">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Konstanter Reibkoeffizient. 
            </xs:documentation></xs:annotation>
          </xs:element>
        </xs:sequence> 
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="PlanarCoulombImpact" substitutionGroup="FrictionImpactLaw" type="PlanarCoulombImpactType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Definiert ebene Coulomb-Reibung auf Geschwindigkeitssebene. 
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="PlanarCoulombImpactType">
    <xs:complexContent>
      <xs:extension base="FrictionImpactLawType">
        <xs:sequence>
          <xs:element name="frictionCoefficient" type="pv:nounitScalar">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Konstanter Reibkoeffizient. 
            </xs:documentation></xs:annotation>
          </xs:element>
        </xs:sequence> 
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="SpatialStribeckImpact" substitutionGroup="FrictionImpactLaw" type="SpatialStribeckImpactType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Definiert räumliche Stribeck-Reibung auf Geschwindigkeitssebene.
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="SpatialStribeckImpactType">
    <xs:complexContent>
      <xs:extension base="FrictionImpactLawType">
        <xs:sequence>
          <xs:element name="frictionFunction">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Definiert den Reibkoeffizienten in Abhängigkeit der Relativgeschwindigkeit.
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:choice>
                <xs:element ref="Function"/>
                <xs:element ref="pv:Embed"/>
              </xs:choice>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="PlanarStribeckImpact" substitutionGroup="FrictionImpactLaw" type="PlanarStribeckImpactType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Definiert ebene Stribeck-Reibung auf Geschwindigkeitssebene.
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="PlanarStribeckImpactType">
    <xs:complexContent>
      <xs:extension base="FrictionImpactLawType">
        <xs:sequence>
          <xs:element name="frictionFunction">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Definiert den Reibkoeffizienten in Abhängigkeit der Relativgeschwindigkeit.
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:choice>
                <xs:element ref="Function"/>
                <xs:element ref="pv:Embed"/>
              </xs:choice>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="TyreModel" abstract="true" type="TyreModelType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Abstrakte Oberklasse zur Beschreibung von Reifenmodellen.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="TyreModelType"/>

  <xs:element name="LinearTyreModel" substitutionGroup="TyreModel" type="LinearTyreModelType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
      tbd
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="LinearTyreModelType">
    <xs:complexContent>
      <xs:extension base="TyreModelType">
        <xs:sequence>
          <xs:element name="cz" type="pv:stiffnessScalar">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="dz" type="pv:dampingScalar">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="cka" type="pv:unknownScalar">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="cal" type="pv:unknownScalar">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="cga" type="pv:unknownScalar">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="cMzga" type="pv:unknownScalar">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="t" type="pv:unknownScalar">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="scaleFactorForLongitudinalForce" type="pv:nounitScalar" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="scaleFactorForLateralForce" type="pv:nounitScalar" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="scaleFactorForAligningMoment" type="pv:nounitScalar" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name="MagicFormulaSharp" substitutionGroup="TyreModel" type="MagicFormulaSharpType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
      tbd
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="MagicFormulaSharpType">
    <xs:complexContent>
      <xs:extension base="TyreModelType">
        <xs:sequence>
          <xs:element name="cz" type="pv:stiffnessScalar">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="dz" type="pv:dampingScalar">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="Fz0" type="pv:forceScalar">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="R0" type="pv:lengthScalar">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="pKy1" type="pv:unknownScalar">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="pKy2" type="pv:unknownScalar">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="pKy3" type="pv:unknownScalar">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="pKy4" type="pv:unknownScalar">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="pKy5" type="pv:unknownScalar">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="pKy6" type="pv:unknownScalar">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="pKy7" type="pv:unknownScalar">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="pDx1" type="pv:unknownScalar">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="pDx2" type="pv:unknownScalar">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="pEx1" type="pv:unknownScalar">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="pEx2" type="pv:unknownScalar">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="pEx3" type="pv:unknownScalar">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="pEx4" type="pv:unknownScalar">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="pKx1" type="pv:unknownScalar">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="pKx2" type="pv:unknownScalar">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="pKx3" type="pv:unknownScalar">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="Cx" type="pv:unknownScalar">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="Cy" type="pv:unknownScalar">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="rBx1" type="pv:unknownScalar">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="rBx2" type="pv:unknownScalar">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="Cxal" type="pv:unknownScalar">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="pDy1" type="pv:unknownScalar">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="pDy2" type="pv:unknownScalar">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="pDy3" type="pv:unknownScalar">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="pEy1" type="pv:unknownScalar">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="pEy2" type="pv:unknownScalar">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="pEy4" type="pv:unknownScalar">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="Cga" type="pv:unknownScalar">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="Ega" type="pv:unknownScalar">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="rBy1" type="pv:unknownScalar">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="rBy2" type="pv:unknownScalar">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="rBy3" type="pv:unknownScalar">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="Cyka" type="pv:unknownScalar">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="qHz3" type="pv:unknownScalar">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="qHz4" type="pv:unknownScalar">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="qBz1" type="pv:unknownScalar">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="qBz2" type="pv:unknownScalar">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="qBz5" type="pv:unknownScalar">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="qBz6" type="pv:unknownScalar">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="qBz9" type="pv:unknownScalar">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="qBz10" type="pv:unknownScalar">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="qDz1" type="pv:unknownScalar">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="qDz2" type="pv:unknownScalar">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="qDz3" type="pv:unknownScalar">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="qDz4" type="pv:unknownScalar">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="qDz8" type="pv:unknownScalar">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="qDz9" type="pv:unknownScalar">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="qDz10" type="pv:unknownScalar">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="qDz11" type="pv:unknownScalar">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="qEz1" type="pv:unknownScalar">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="qEz2" type="pv:unknownScalar">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="qEz5" type="pv:unknownScalar">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="Ct" type="pv:unknownScalar">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="c1Rel" type="pv:unknownScalar">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="c2Rel" type="pv:unknownScalar">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="c3Rel" type="pv:unknownScalar">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="scaleFactorForCamberStiffness" type="pv:nounitScalar" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="scaleFactorForLongitudinalForce" type="pv:nounitScalar" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="scaleFactorForLateralForce" type="pv:nounitScalar" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="scaleFactorForAligningMoment" type="pv:nounitScalar" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="MagicFormula62" substitutionGroup="TyreModel" type="MagicFormula62Type">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
      tbd
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="MagicFormula62Type">
    <xs:complexContent>
      <xs:extension base="TyreModelType">
        <xs:sequence>
	  <xs:element name="inputDataFileName" type="pv:filenameFullEval">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Name der Datei mit den Eingabedaten.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="tyreSide" type="pv:stringFullEval" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
	        tbd
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="motorcycleKinematics" type="pv:booleanFullEval" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="contactPointTransformation" type="pv:booleanFullEval" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="turnSlip" type="pv:booleanFullEval" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="inflationPressure" type="pv:pressureScalar" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="verticalStiffness" type="pv:stiffnessScalar" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="verticalDamping" type="pv:dampingScalar" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="relaxationLengthForLongitudinalSlip" type="pv:lengthScalar" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="relaxationLengthForSideslip" type="pv:lengthScalar" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="scaleFactorForLongitudinalForce" type="pv:nounitScalar" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="referenceTreadWidth" type="pv:lengthScalar" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="scaleFactorForLateralForce" type="pv:nounitScalar" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="scaleFactorForOverturningMoment" type="pv:nounitScalar" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="scaleFactorRollingResistanceMoment" type="pv:nounitScalar" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="scaleFactorForAligningMoment" type="pv:nounitScalar" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="scaleFactorForMomentArmOfLongitudinalForce" type="pv:nounitScalar" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="scaleFactorForLongitudinalFricitionCoefficient" type="pv:nounitScalar" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="scaleFactorForLateralFricitionCoefficient" type="pv:nounitScalar" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="scaleFactorForLongitudinalSlipStiffness" type="pv:nounitScalar" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="scaleFactorForCorneringStiffness" type="pv:nounitScalar" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="scaleFactorForLateralForceCamberStiffness" type="pv:nounitScalar" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="scaleFactorForAligningMomentCamberStiffness" type="pv:nounitScalar" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="Function" abstract="true" substitutionGroup="Element" type="FunctionType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Abstrakte Klasse von Funktionen mit beliebig vielen Parametern.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="FunctionType">
    <xs:complexContent>
      <xs:extension base="ElementType"/>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="TranslationAlongXAxis" substitutionGroup="Function" type="TranslationAlongXAxisType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
      tbd
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="TranslationAlongXAxisType">
    <xs:complexContent>
      <xs:extension base="FunctionType"/>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="TranslationAlongYAxis" substitutionGroup="Function" type="TranslationAlongYAxisType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
      tbd
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="TranslationAlongYAxisType">
    <xs:complexContent>
      <xs:extension base="FunctionType"/>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="TranslationAlongZAxis" substitutionGroup="Function" type="TranslationAlongZAxisType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
      tbd
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="TranslationAlongZAxisType">
    <xs:complexContent>
      <xs:extension base="FunctionType"/>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="TranslationAlongAxesXY" substitutionGroup="Function" type="TranslationAlongAxesXYType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
      tbd
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="TranslationAlongAxesXYType">
    <xs:complexContent>
      <xs:extension base="FunctionType"/>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="TranslationAlongAxesYZ" substitutionGroup="Function" type="TranslationAlongAxesYZType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
      tbd
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="TranslationAlongAxesYZType">
    <xs:complexContent>
      <xs:extension base="FunctionType"/>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="TranslationAlongAxesXZ" substitutionGroup="Function" type="TranslationAlongAxesXZType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
      tbd
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="TranslationAlongAxesXZType">
    <xs:complexContent>
      <xs:extension base="FunctionType"/>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="TranslationAlongAxesXYZ" substitutionGroup="Function" type="TranslationAlongAxesXYZType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
      tbd
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="TranslationAlongAxesXYZType">
    <xs:complexContent>
      <xs:extension base="FunctionType"/>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="TranslationAlongFixedAxis" substitutionGroup="Function" type="TranslationAlongFixedAxisType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
      tbd
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="TranslationAlongFixedAxisType">
    <xs:complexContent>
      <xs:extension base="FunctionType">
        <xs:sequence>
          <xs:element name="axisOfTranslation" type="pv:nounitVector">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
              tbd
              </xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence> 
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="LinearTranslation" substitutionGroup="Function" type="LinearTranslationType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
      tbd
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="LinearTranslationType">
    <xs:complexContent>
      <xs:extension base="FunctionType">
        <xs:sequence>
          <xs:element name="translationVectors" type="pv:unknownMatrix">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
              tbd
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="offset" type="pv:unknownVector" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
              tbd
              </xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence> 
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="RotationAboutXAxis" substitutionGroup="Function" type="RotationAboutXAxisType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
      tbd
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="RotationAboutXAxisType">
    <xs:complexContent>
      <xs:extension base="FunctionType"/>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="RotationAboutYAxis" substitutionGroup="Function" type="RotationAboutYAxisType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
      tbd
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="RotationAboutYAxisType">
    <xs:complexContent>
      <xs:extension base="FunctionType"/>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="RotationAboutZAxis" substitutionGroup="Function" type="RotationAboutZAxisType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
      tbd
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="RotationAboutZAxisType">
    <xs:complexContent>
      <xs:extension base="FunctionType"/>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="RotationAboutFixedAxis" substitutionGroup="Function" type="RotationAboutFixedAxisType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
      tbd
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="RotationAboutFixedAxisType">
    <xs:complexContent>
      <xs:extension base="FunctionType">
        <xs:sequence>
          <xs:element name="axisOfRotation" type="pv:nounitVector">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
              tbd
              </xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence> 
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="RotationAboutAxesXY" substitutionGroup="Function" type="RotationAboutAxesXYType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
      tbd
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="RotationAboutAxesXYType">
    <xs:complexContent>
      <xs:extension base="FunctionType"/>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="RotationAboutAxesYZ" substitutionGroup="Function" type="RotationAboutAxesYZType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
      tbd
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="RotationAboutAxesYZType">
    <xs:complexContent>
      <xs:extension base="FunctionType"/>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="RotationAboutAxesXZ" substitutionGroup="Function" type="RotationAboutAxesXZType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
      tbd
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="RotationAboutAxesXZType">
    <xs:complexContent>
      <xs:extension base="FunctionType"/>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="RotationAboutAxesXYZ" substitutionGroup="Function" type="RotationAboutAxesXYZType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
      tbd
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="RotationAboutAxesXYZType">
    <xs:complexContent>
      <xs:extension base="FunctionType"/>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="RotationAboutAxesZXZ" substitutionGroup="Function" type="RotationAboutAxesZXZType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
      tbd
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="RotationAboutAxesZXZType">
    <xs:complexContent>
      <xs:extension base="FunctionType"/>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="RotationAboutAxesZYX" substitutionGroup="Function" type="RotationAboutAxesZYXType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
      tbd
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="RotationAboutAxesZYXType">
    <xs:complexContent>
      <xs:extension base="FunctionType"/>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="SymbolicFunction" substitutionGroup="Function" type="SymbolicFunctionType"/>
  <xs:complexType name="SymbolicFunctionType">
    <xs:complexContent>
      <xs:extension base="FunctionType">
        <xs:sequence>
          <xs:element name="definition">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Definition der Function.
              </xs:documentation>
            </xs:annotation>
            <xs:complexType mixed="true">
              <xs:group ref="pv:symbolicFunctionXMLElement" minOccurs="0"/>
              <xs:attributeGroup ref="pv:symbolicFunctionXMLAttribute"/>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="IdentityFunction" substitutionGroup="Function" type="IdentityFunctionType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Identische Abbildung: <object class="inlineeqn">\boldsymbol{y}=\boldsymbol{y}</object>.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="IdentityFunctionType">
    <xs:complexContent>
      <xs:extension base="FunctionType">
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="ConstantFunction" substitutionGroup="Function" type="ConstantFunctionType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Konstanter Funktionswert: <object class="inlineeqn">\boldsymbol{y}=\boldsymbol{c}</object>.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="ConstantFunctionType">
    <xs:complexContent>
      <xs:extension base="FunctionType">
        <xs:sequence>
          <xs:element name="a0" type="pv:unknownScalar">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Konstanter Funktionswert: <object class="inlineeqn">\boldsymbol{y}=\boldsymbol{c}</object>.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence> 
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="LinearFunction" substitutionGroup="Function" type="LinearFunctionType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
      tbd
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="LinearFunctionType">
    <xs:complexContent>
      <xs:extension base="FunctionType">
        <xs:sequence>
          <xs:element name="a0" type="pv:unknownScalar" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
              tbd
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="a1" type="pv:unknownScalar">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
              tbd
              </xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence> 
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="QuadraticFunction" substitutionGroup="Function" type="QuadraticFunctionType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Quadratische Funktion mit <object class="inlineeqn">\boldsymbol{y}= \boldsymbol{a}_{0} + \boldsymbol{a}_{1} \, x + \boldsymbol{a}_{2} \, x^2</object>.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="QuadraticFunctionType">
    <xs:complexContent>
      <xs:extension base="FunctionType">
        <xs:sequence>
          <xs:element name="a0" type="pv:unknownScalar" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Faktor <object class="inlineeqn">\boldsymbol{a}_0</object>.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="a1" type="pv:unknownScalar" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Faktor <object class="inlineeqn">\boldsymbol{a}_1</object>.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="a2" type="pv:unknownScalar">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Faktor <object class="inlineeqn">\boldsymbol{a}_2</object>.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence> 
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="PolynomFunction" substitutionGroup="Function" type="PolynomFunctionType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Polynomfunktion <object class="inlineeqn">y=\sum_{i=0}^n a_i \, x^i</object>.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="PolynomFunctionType">
    <xs:complexContent>
      <xs:extension base="FunctionType">
        <xs:sequence>
          <xs:element name="coefficients" type="pv:unknownVector">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Vektor mit den Koeffizienten <object class="inlineeqn">a_i</object>.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="SinusoidalFunction" substitutionGroup="Function" type="SinusoidalFunctionType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Vektorwertige periodische Funktion mit <object class="inlineeqn">y_i= A_i \, \sin \left( 2 \, \pi \, f_i \, x + \varphi_i \right) + o_i</object>.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="SinusoidalFunctionType">
    <xs:complexContent>
      <xs:extension base="FunctionType">
        <xs:sequence>
          <xs:element name="amplitude" type="pv:unknownScalar">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Amplitude <object class="inlineeqn">A</object>.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="frequency" type="pv:unknownScalar">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Frequenz <object class="inlineeqn">f</object>.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="phase" type="pv:angleScalar" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Phasenwinkel <object class="inlineeqn">\varphi</object>.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="offset" type="pv:unknownScalar" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Offset <object class="inlineeqn">o</object>.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence> 
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="AbsoluteValueFunction" substitutionGroup="Function" type="AbsoluteValueFunctionType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
      tbd
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="AbsoluteValueFunctionType">
    <xs:complexContent>
      <xs:extension base="FunctionType"/>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="ModuloFunction" substitutionGroup="Function" type="ModuloFunctionType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
      tbd
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="ModuloFunctionType">
    <xs:complexContent>
      <xs:extension base="FunctionType">
        <xs:sequence>
          <xs:element name="denominator" type="pv:unknownScalar">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Vektor der zugehörigen Funktionswerte <object class="inlineeqn">\boldsymbol{c}</object>.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence> 
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="SignumFunction" substitutionGroup="Function" type="SignumFunctionType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
      tbd
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="SignumFunctionType">
    <xs:complexContent>
      <xs:extension base="FunctionType"/>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="BoundedFunction" substitutionGroup="Function" type="BoundedFunctionType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
      tbd
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="BoundedFunctionType">
    <xs:complexContent>
      <xs:extension base="FunctionType">
        <xs:sequence>
          <xs:element name="lowerBound" minOccurs="0" type="pv:unknownScalar">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Untere Grenze.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="upperBound" minOccurs="0" type="pv:unknownScalar">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Obere Grenze.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence> 
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="VectorValuedFunction" substitutionGroup="Function" type="VectorValuedFunctionType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
      tbd
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="VectorValuedFunctionType">
    <xs:complexContent>
      <xs:extension base="FunctionType">
        <xs:sequence>
          <xs:element name="components">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                tbd
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:choice minOccurs="0" maxOccurs="unbounded">
                <xs:element ref="Function"/>
                <xs:element ref="pv:Embed"/>
              </xs:choice>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="CompositeFunction" substitutionGroup="Function" type="CompositeFunctionType"/>
  <xs:complexType name="CompositeFunctionType">
    <xs:complexContent>
      <xs:extension base="FunctionType">
        <xs:sequence>
          <xs:element name="outerFunction">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
            tbd
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:choice>
                <xs:element ref="Function"/>
                <xs:element ref="pv:Embed"/>
              </xs:choice>
            </xs:complexType>
          </xs:element>
          <xs:choice>
          <xs:element name="innerFunction">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
            tbd
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:choice>
                <xs:element ref="Function"/>
                <xs:element ref="pv:Embed"/>
              </xs:choice>
            </xs:complexType>
          </xs:element>
          <xs:element name="innerFunctions">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
            tbd
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:choice minOccurs="2" maxOccurs="2">
                <xs:element ref="Function"/>
                <xs:element ref="pv:Embed"/>
              </xs:choice>
            </xs:complexType>
          </xs:element>
          </xs:choice>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="LimitedFunction" type="LimitedFunctionType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
    tbd
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="LimitedFunctionType">
    <xs:sequence>
      <xs:element name="function">
        <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        tbd
        </xs:documentation></xs:annotation>
        <xs:complexType>
          <xs:choice>
            <xs:element ref="Function"/>
            <xs:element ref="pv:Embed"/>
          </xs:choice>
        </xs:complexType>
      </xs:element>
      <xs:element name="limit" type="pv:unknownScalar">
        <xs:annotation>
          <xs:documentation xml:lang="de" xmlns="">
          tbd
          </xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:sequence>
  </xs:complexType> 

  <xs:element name="PiecewiseDefinedFunction" substitutionGroup="Function" type="PiecewiseDefinedFunctionType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
      tbd
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="PiecewiseDefinedFunctionType">
    <xs:complexContent>
      <xs:extension base="FunctionType">
        <xs:sequence>
          <xs:element name="limitedFunctions">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                tbd
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:choice minOccurs="1" maxOccurs="unbounded">
                <xs:element ref="LimitedFunction"/>
                <xs:element ref="pv:Embed"/>
              </xs:choice>
            </xs:complexType>
          </xs:element>
          <xs:element name="shiftAbscissa" type="pv:booleanFullEval" minOccurs="0"/>
          <xs:element name="shiftOrdinate" type="pv:booleanFullEval" minOccurs="0"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="TabularFunction" substitutionGroup="Function" type="TabularFunctionType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Vektorwertige Funktion generiert aus linearer Interpolation von Tabellenwerten <object class="inlineeqn">\boldsymbol{y}=\begin{cases}\boldsymbol{c_0}\ \text{bei}\ x\leq x_0\\\frac{\boldsymbol{c}_{i+1}-\boldsymbol{c}_{i}}{x_{i+1}-x_i}\left(x-x_i\right)\ \text{bei}\ x_i \leq x\leq x_{i+1}\ \text{und}\ 0\leq i\leq n-1\\\boldsymbol{c_n}\ \text{bei}\ x_n \leq x\end{cases}</object>.<br/>
        Zum einen ist es möglich, die Parameter <object class="inlineeqn">\mathbf{x}</object> als (Spalten-)Vektor und die Punkte <object class="inlineeqn">\mathbf{c}</object> -zeilenweise in einer Matrix angeordnet- in getrennten Matrizen vorzugeben, zum anderen ist deren Angabe auch in einer Matrix möglich.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="TabularFunctionType">
    <xs:complexContent>
      <xs:extension base="FunctionType">
        <xs:choice>
          <xs:sequence>
            <xs:element name="x" type="pv:unknownVector">
              <xs:annotation>
                <xs:documentation xml:lang="de" xmlns="">
                  Parameter-(Spalten-)vektor der zu interpolierenden Punkte.
                </xs:documentation>
              </xs:annotation>
            </xs:element>
            <xs:element name="y" type="pv:unknownMatrix">
              <xs:annotation>
                <xs:documentation xml:lang="de" xmlns="">
                  Zeilenweises Arrangement der zu interpolierenden Punkte in einer Matrix.
                </xs:documentation>
              </xs:annotation>
            </xs:element>
          </xs:sequence>
          <xs:element name="xy" type="pv:unknownMatrix">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Parameter-(Spalten-)vektor und die zu interpolierenden Punkte sind in einer Matrix zusammengefasst.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:choice>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="TwoDimensionalTabularFunction" substitutionGroup="Function" type="TwoDimensionalTabularFunctionType">
    <xs:annotation>
      <xs:documentation  xml:lang="de" xmlns="">
        Lineare Interpolation einer Funktion <object class="inlineeqn">z=f(x, y)</object>, die als Kennfeld hinterlegt ist.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="TwoDimensionalTabularFunctionType">
    <xs:complexContent>
      <xs:extension base="FunctionType">
        <xs:choice>
          <xs:sequence>
            <xs:element name="x" type="pv:unknownVector">
              <xs:annotation>
                <xs:documentation xml:lang="de" xmlns="">
                  x-Werte. Die Werte müssen streng mononton steigend sein.
                </xs:documentation>
              </xs:annotation>
            </xs:element>
            <xs:element name="y" type="pv:unknownVector">
              <xs:annotation>
                <xs:documentation xml:lang="de" xmlns="">
                  y-Werte. Die Werte müssen streng mononton steigend sein.
                </xs:documentation>
              </xs:annotation>
            </xs:element>
            <xs:element name="z" type="pv:unknownMatrix">
              <xs:annotation>
                <xs:documentation xml:lang="de" xmlns="">
                  z-Werte. Die Anzahl der Spalten der Matrix muss mit der Größe des x-Vektors und die Anzahl der Zeilen der Matrix muss mit der Größe des y-Vektors übereinstimmen.
                </xs:documentation>
              </xs:annotation>
            </xs:element>
          </xs:sequence>
          <xs:element name="xyz" type="pv:unknownMatrix">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Die Stützstellen und die Stützwerte sind in einer Matrix zusammengefasst.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:choice>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="PiecewisePolynomFunction" substitutionGroup="Function" type="PiecewisePolynomFunctionType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Klasse zur Definition von vektorwertigen, univariaten Funktionen über Spline-Interpolation.<br/>
        Die zu interpolierenden Punkte <object class="inlineeqn">\mathbf{Y}_i</object> werden dabei bez. des Spline mit der skalaren Größe <object class="inlineeqn">x_i</object> parametrisiert.<br/>
        Zum einen ist es möglich, die Parameter <object class="inlineeqn">\mathbf{x}</object> als (Spalten-)Vektor und die Punkte <object class="inlineeqn">\mathbf{Y}</object> -zeilenweise in einer Matrix angeordnet- in getrennten Matrizen vorzugeben, zum anderen ist deren Angabe auch in einer Matrix möglich.
        Die Angabe von verschiedenen interpolationsmethoden und Randbedingungen ist dabei über interpolationMethod möglich.

        Alternativ kann auch direkt die Stützwerte (breaks) und die Spline Koeffizienten angeben werden. Daruch können beliebige polynom-splines definiert werden.
        Vorzugsweise werden die Koeffizenten dabei z.B. mittels Python scipy berechnet. Siehe dazu die definition von breaks und coefficients.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="PiecewisePolynomFunctionType">
    <xs:complexContent>
      <xs:extension base="FunctionType">
        <xs:sequence>
          <xs:choice>
            <xs:sequence>
              <xs:choice>
                <xs:sequence>
                  <xs:element name="x" type="pv:unknownVector">
                    <xs:annotation>
                      <xs:documentation xml:lang="de" xmlns="">
                        Parameter-(Spalten-)vektor der zu interpolierenden Punkte.
                      </xs:documentation>
                    </xs:annotation>
                  </xs:element>
                  <xs:element name="y" type="pv:unknownMatrix">
                    <xs:annotation>
                      <xs:documentation xml:lang="de" xmlns="">
                        Zeilenweises Arrangement der zu interpolierenden Punkte in einer Matrix.
                      </xs:documentation>
                    </xs:annotation>
                  </xs:element>
                </xs:sequence>
                <xs:element name="xy" type="pv:unknownMatrix">
                  <xs:annotation>
                    <xs:documentation xml:lang="de" xmlns="">
                      Parameter-(Spalten-)vektor und die zu interpolierenden Punkte sind in einer Matrix zusammengefasst.
                    </xs:documentation>
                  </xs:annotation>
                </xs:element>
              </xs:choice>
              <xs:element name="interpolationMethod" minOccurs="0" type="pv:stringFullEval">
                  <xs:annotation>
                    <xs:documentation xml:lang="de" xmlns="">
                      <dl>
                        <dt>"cSplinePeriodic"</dt> <dd>Interpolation mit periodischem Spline s vom lokalem Polynomgrad 3 (<object class="inlineeqn"> s'(0)=s'(l);\ s''(0)=s''(l)</object>).</dd>
                        <dt>"cSplineNatural"</dt> <dd>Interpolation mit natürlichem Spline s vom lokalem Polynomgrad 3 (<object class="inlineeqn"> s''(0)=0;\ s''(l)=0</object>).</dd>
                        <dt>"piecewiseLinear"</dt> <dd>Interpolation mit stückweise linearem Spline.</dd>
                      </dl>
                    </xs:documentation>
                  </xs:annotation>
              </xs:element>
            </xs:sequence> 
            <xs:sequence> 
              <xs:element name="breaks" type="pv:unknownVector">
                <xs:annotation>
                  <xs:documentation xml:lang="de" xmlns="">
                    Polynom Stützpunkte.

                    Bei Verwendung des Python evaluators und Nutzung von scipy entspricht der Wert des Vectors breaks = scipy.interpolate.PPoly.x
                  </xs:documentation>
                </xs:annotation>
              </xs:element>
              <xs:element name="coefficients" type="pv:unknownMatrix" minOccurs="1" maxOccurs="unbounded">
                <xs:annotation>
                  <xs:documentation xml:lang="de" xmlns="">
                    Das piecewise Polynom wird mittels "local power basis" dargestellt.
                    <object class="eqn">
                      <![CDATA[
                      y = \sum_{m=0}^{k} C_{i,m} * (x - breaks_i)^{k-m}
                      ]]>
                    </object>
                    Wobei i die Werte für das Spline-interval x[i] bis x[i+1] darstellen.
                    Und k ist der Polynomgrad.

                    Die Matrix C entspricht dabei dem Wert dieses XML elements.

                    Wenn das PiecewisePolynomFunction anstatt eines Scalars einen Vector zurückliefert müssen die XML Element coefficients mehrfach angegeben werden: für jede Komponente des Vectors.

                    Bei Verwendung des Python evaluators und Nutzung von scipy entspricht für skalare PiecewisePolynomFunction
                    der Wert der Matrix C = scipy.interpolate.PPoly.c.T und für vektorielle PiecewisePolynomFunction
                    der Wert der Matrix C = scipy.interpolate.PPoly.c[:,:,comp].T wobei comp die Komponente des Vectors ist oder 0 für ein Skalar.
                  </xs:documentation>
                </xs:annotation>
              </xs:element>
            </xs:sequence> 
          </xs:choice> 
          <xs:element name="extrapolationMethod" minOccurs="0" type="pv:stringFullEval">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Definiert wie vor dem Start und nach dem Ende des Splineintervals extrapoliert wird:_
                <dl>
                  <dt>"error"</dt> <dd>[Default] Es findet keine extrapolation statt sondern es wird bei Auswertung außerhalb des Bereichs eine error generiert.</dd>
                  <dt>"continuePolynom"</dt> <dd>Das Polynom an Ende des Bereichs wird auserhalb des Bereichs ausgewertet.</dd>
                  <dt>"linear"</dt> <dd>Linear fortsetzung des Splines auserhalb des Bereichs. Der Spline is an den Bereichsgrenzen somit nur noch C^1 stetig.</dd>
                </dl>
              </xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence> 
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="TwoDimensionalPiecewisePolynomFunction" substitutionGroup="Function" type="TwoDimensionalPiecewisePolynomFunctionType">
    <xs:annotation>
      <xs:documentation  xml:lang="de" xmlns="">
        Spline-Interpolation einer Funktion <object class="inlineeqn">z=f(x, y)</object>, die als Kennfeld hinterlegt ist.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="TwoDimensionalPiecewisePolynomFunctionType">
    <xs:complexContent>
      <xs:extension base="FunctionType">
        <xs:sequence>
          <xs:choice>
            <xs:sequence>
              <xs:element name="x" type="pv:unknownVector">
                <xs:annotation>
                  <xs:documentation xml:lang="de" xmlns="">
                    x-Werte.
                  </xs:documentation>
                </xs:annotation>
              </xs:element>
              <xs:element name="y" type="pv:unknownVector">
                <xs:annotation>
                  <xs:documentation xml:lang="de" xmlns="">
                    y-Werte.
                  </xs:documentation>
                </xs:annotation>
              </xs:element>
              <xs:element name="z" type="pv:unknownMatrix">
                <xs:annotation>
                  <xs:documentation xml:lang="de" xmlns="">
                    z-Werte. Die Anzahl der Spalten der Matrix muss mit der Größe des x-Vektors und die Anzahl der Zeilen der Matrix muss mit der Größe des y-Vektors übereinstimmen.
                  </xs:documentation>
                </xs:annotation>
              </xs:element>
            </xs:sequence>
            <xs:element name="xyz" type="pv:unknownMatrix">
              <xs:annotation>
                <xs:documentation xml:lang="de" xmlns="">
                  Die Stützstellen und die Stützwerte sind in einer Matrix zusammengefasst.
                </xs:documentation>
              </xs:annotation>
            </xs:element>
          </xs:choice>
          <xs:element name="interpolationMethodFirstDimension" minOccurs="0" type="pv:stringFullEval">
              <xs:annotation>
                <xs:documentation xml:lang="de" xmlns="">
                  <dl>
                    <dt>"cSplinePeriodic"</dt> <dd>Interpolation mit periodischem Spline s vom lokalem Polynomgrad 3 (<object class="inlineeqn"> s'(0)=s'(l);\ s''(0)=s''(l)</object>).</dd>
                    <dt>"cSplineNatural"</dt> <dd>Interpolation mit natürlichem Spline s vom lokalem Polynomgrad 3 (<object class="inlineeqn"> s''(0)=0;\ s''(l)=0</object>).</dd>
                    <dt>"piecewiseLinear"</dt> <dd>Interpolation mit stückweise linearem Spline.</dd>
                  </dl>
                </xs:documentation>
              </xs:annotation>
          </xs:element>
          <xs:element name="interpolationMethodSecondDimension" minOccurs="0" type="pv:stringFullEval">
              <xs:annotation>
                <xs:documentation xml:lang="de" xmlns="">
                  <dl>
                    <dt>"cSplinePeriodic"</dt> <dd>Interpolation mit periodischem Spline s vom lokalem Polynomgrad 3 (<object class="inlineeqn"> s'(0)=s'(l);\ s''(0)=s''(l)</object>).</dd>
                    <dt>"cSplineNatural"</dt> <dd>Interpolation mit natürlichem Spline s vom lokalem Polynomgrad 3 (<object class="inlineeqn"> s''(0)=0;\ s''(l)=0</object>).</dd>
                    <dt>"piecewiseLinear"</dt> <dd>Interpolation mit stückweise linearem Spline.</dd>
                  </dl>
                </xs:documentation>
              </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="FourierFunction" substitutionGroup="Function" type="FourierFunctionType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Fourierreihe <object class="inlineeqn">y=\frac{a_0}{2}+\sum_{i=1}^n a_i\,\cos(i*2*pi*f*t)+b_i\,\sin(i*2*pi*f*t)</object>.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="FourierFunctionType">
    <xs:complexContent>
      <xs:extension base="FunctionType">
        <xs:sequence>
          <xs:element name="frequency" type="pv:unknownScalar">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Grundfrequenz <object class="inlineeqn">f</object>.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="a0" type="pv:unknownScalar" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Koeffizient <object class="inlineeqn">a_0</object>.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:choice>
            <xs:sequence>
              <xs:element name="a" type="pv:unknownVector">
                <xs:annotation>
                  <xs:documentation xml:lang="de" xmlns="">
                    Vektor mit den Koeffizienten <object class="inlineeqn">a_i</object>.
                  </xs:documentation>
                </xs:annotation>
              </xs:element>
              <xs:element name="b" type="pv:unknownVector">
                <xs:annotation>
                  <xs:documentation xml:lang="de" xmlns="">
                    Vektor mit den Koeffizienten <object class="inlineeqn">b_i</object>.
                  </xs:documentation>
                </xs:annotation>
              </xs:element>
            </xs:sequence>
            <xs:element name="ab" type="pv:unknownMatrix">
              <xs:annotation>
                <xs:documentation xml:lang="de" xmlns="">
                    Matrix mit den Koeffizienten <object class="inlineeqn">a_i</object> und <object class="inlineeqn">b_i</object>.
                </xs:documentation>
              </xs:annotation>
            </xs:element>
          </xs:choice>
          <xs:element name="amplitudePhaseForm" minOccurs="0" type="pv:booleanFullEval">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Definiert, ob die Koeffizienten <object class="inlineeqn">a_i</object> und <object class="inlineeqn">b_i</object> als Amplitude <object class="inlineeqn">A_i</object> und Phasenwinkel <object class="inlineeqn">\varphi_i</object> interpretiert werden sollen. Die Fourierreihe hat dann die Form <object class="inlineeqn">y=\frac{a_0}{2}+\sum_{i=1}^n a_i\,\cos(i*2*pi*f*t - b_i)</object>.
            </xs:documentation></xs:annotation>
          </xs:element>
        </xs:sequence> 
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="BidirectionalFunction" substitutionGroup="Function" type="BidirectionalFunctionType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Bidirektionale Funktion.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="BidirectionalFunctionType">
    <xs:complexContent>
      <xs:extension base="FunctionType">
        <xs:sequence>
          <xs:element name="negativeDirectionalFunction">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
            tbd
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:choice>
                <xs:element ref="Function"/>
                <xs:element ref="pv:Embed"/>
              </xs:choice>
            </xs:complexType>
          </xs:element>
          <xs:element name="positiveDirectionalFunction">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
            tbd
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:choice>
                <xs:element ref="Function"/>
                <xs:element ref="pv:Embed"/>
              </xs:choice>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="ContinuedFunction" substitutionGroup="Function" type="ContinuedFunctionType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Fortsetzung einer Funktion mit eingeschränktem Definitionsbereich.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="ContinuedFunctionType">
    <xs:complexContent>
      <xs:extension base="FunctionType">
        <xs:sequence>
          <xs:element name="function">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Funktion mit eingeschränktem Definitionsbereich.
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:choice>
                <xs:element ref="Function"/>
                <xs:element ref="pv:Embed"/>
              </xs:choice>
            </xs:complexType>
          </xs:element>
          <xs:element name="continuationRule">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Forsetzungsregel.
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:choice>
                <xs:element ref="Function"/>
                <xs:element ref="pv:Embed"/>
              </xs:choice>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="LinearSpringDamperForce" substitutionGroup="Function" type="LinearSpringDamperForceType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Lineares funktionelles Feder- / Dämpfergesetz.<br/>
        Die resultierende Kraft ergibt sich zu <object class="inlineeqn">f=c\,s+d\,\dot{s}</object> mit der Auslenkung <object class="inlineeqn">s</object> und der relativen Geschwindigkeit <object class="inlineeqn">\dot{s}</object>.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="LinearSpringDamperForceType">
    <xs:complexContent>
      <xs:extension base="FunctionType">
        <xs:sequence>
          <xs:element name="stiffnessCoefficient" type="pv:stiffnessScalar">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Steifigkeit <object class="inlineeqn">c</object>.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="dampingCoefficient" type="pv:dampingScalar">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Dämpfungskoeffizient <object class="inlineeqn">d</object>.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence> 
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="NonlinearSpringDamperForce" substitutionGroup="Function" type="NonlinearSpringDamperForceType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Nichtlineares funktionelles Feder- / Dämpfergesetz.<br/>
        Die resultierende Kraft ergibt sich zu <object class="inlineeqn">f=f_s\left(s\right)+f_{\dot{s}}\left(\dot{s}\right)</object> mit der Auslenkung <object class="inlineeqn">s</object> und der relativen Geschwindigkeit <object class="inlineeqn">\dot{s}</object>.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="NonlinearSpringDamperForceType">
    <xs:complexContent>
      <xs:extension base="FunctionType">
        <xs:sequence>
          <xs:element name="forceDeflectionFunction">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Lagereaktion <object class="inlineeqn">f_s\left(s\right)</object> (Feder).
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:choice>
                <xs:element ref="Function"/>
                <xs:element ref="pv:Embed"/>
              </xs:choice>
            </xs:complexType>
          </xs:element>
          <xs:element name="forceVelocityFunction">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Geschwindigkeitsreaktion <object class="inlineeqn">f_{\dot{s}}\left(\dot{s}\right)</object> (Dämpfer).
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:choice>
                <xs:element ref="Function"/>
                <xs:element ref="pv:Embed"/>
              </xs:choice>
            </xs:complexType>
          </xs:element>
        </xs:sequence> 
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="LinearElasticFunction" substitutionGroup="Function" type="LinearElasticFunctionType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
      tbd
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="LinearElasticFunctionType">
    <xs:complexContent>
      <xs:extension base="FunctionType">
        <xs:sequence>
          <xs:element name="stiffnessMatrix" type="pv:unknownMatrix">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Steifigkeitsmatrix.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="dampingMatrix" type="pv:unknownMatrix" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Dämpfungsmatrix.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="LinearRegularizedUnilateralConstraint" substitutionGroup="Function" type="LinearRegularizedUnilateralConstraintType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Konstitutive Funktion für einseitige Bindungen.<br/>
        Die Bindungskraft ergibt sich zu <object class="inlineeqn">\lambda=\begin{cases}0\ \text{bei}\ g\geq 0\\-cg-d\dot{g}\ \text{bei}\ g\leq 0\ \text{und}\ \dot{g}\leq 0\\-cg\ \text{bei}\ g\leq 0\ \text{und}\ \dot{g}\geq 0\end{cases}</object> mit dem Abstand g und der relativen Geschwindigkeit <object class="inlineeqn">\dot{g}</object>.
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:complexType name="LinearRegularizedUnilateralConstraintType">
    <xs:complexContent>
      <xs:extension base="FunctionType">
        <xs:sequence>
          <xs:element name="stiffnessCoefficient" type="pv:stiffnessScalar">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Steifigkeit c.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="dampingCoefficient" type="pv:dampingScalar">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Dämpfungskoeffizient d.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence> 
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="LinearRegularizedBilateralConstraint" substitutionGroup="Function" type="LinearRegularizedBilateralConstraintType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Konstitutive Funktion für zweiseitige Bindungen.<br/>
        Die Bindungskraft ergibt sich zu <object class="inlineeqn">\lambda=-cg-d\dot{g}</object> mit dem Abstand g und der relativen Geschwindigkeit <object class="inlineeqn">\dot{g}</object>.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="LinearRegularizedBilateralConstraintType">
    <xs:complexContent>
      <xs:extension base="FunctionType">
        <xs:sequence>
          <xs:element name="stiffnessCoefficient" type="pv:stiffnessScalar">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Steifigkeit c.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="dampingCoefficient" type="pv:dampingScalar">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Dämpfungskoeffizient d.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence> 
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="LinearRegularizedCoulombFriction" substitutionGroup="Function" type="LinearRegularizedCoulombFrictionType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Klasse für Coulomb Reibung, die durch eine lineare Funktion innerhalb von Grenzen um den Haftreibungsbereich regularisiert ist.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="LinearRegularizedCoulombFrictionType">
    <xs:complexContent>
      <xs:extension base="FunctionType">
        <xs:sequence>
          <xs:element name="marginalVelocity" type="pv:velocityScalar" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Grenze für die Regularisierung.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="frictionCoefficient" type="pv:nounitScalar">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Reibkoeffizient.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence> 
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="LinearRegularizedStribeckFriction" substitutionGroup="Function" type="LinearRegularizedStribeckFrictionType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Klasse für Stribeck Reibung, die durch eine lineare Funktion innerhalb von Grenzen um den Haftreibungsbereich regularisiert ist.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="LinearRegularizedStribeckFrictionType">
    <xs:complexContent>
      <xs:extension base="FunctionType">
        <xs:sequence>
          <xs:element name="marginalVelocity" type="pv:velocityScalar" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Grenze für die Regularisierung.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="frictionFunction">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Funktion für den geschwindigkeitsabhängigen Reibkoeffizienten.
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:choice>
                <xs:element ref="Function"/>
                <xs:element ref="pv:Embed"/>
              </xs:choice>
            </xs:complexType> 
          </xs:element>
        </xs:sequence> 
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>   
  
  <xs:element name="InfluenceFunction" abstract="true" type="InfluenceFunctionType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
         Koppelt den Einfluss zwischen zwei Kontouren durch eine Einflussfunktion.
      </xs:documentation>
    </xs:annotation>
  </xs:element> 
  <xs:complexType name="InfluenceFunctionType">
    <xs:complexContent>
      <xs:extension base="FunctionType">
        <xs:attribute name="contourName1" type="ContourReferenceType" use="required"/>
        <xs:attribute name="contourName2" type="ContourReferenceType" use="required"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  <xs:element name="FlexibilityInfluenceFunction" substitutionGroup="InfluenceFunction" type="FlexibilityInfluenceFunctionType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
         Koppelt den Einfluss auf nur einer Kontur durch ihre Felxibilität.
      </xs:documentation>
    </xs:annotation>
  </xs:element>  
  <xs:complexType name="FlexibilityInfluenceFunctionType">
    <xs:complexContent>
      <xs:extension base="InfluenceFunctionType">
        <xs:sequence>
          <xs:element name="Flexibility" type="pv:unknownScalar"> <!-- Einheit eigentlich m/N -->
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Flexibilität (Kehrwert der Steifigkeit) der Kontur.
              </xs:documentation>
            </xs:annotation>
          </xs:element>            
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType> 

  <xs:element name="ConstantInfluenceFunction" substitutionGroup="InfluenceFunction" type="ConstantInfluenceFunctionType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
         Koppelt den Einfluss zweier Konturen konsant.
      </xs:documentation>
    </xs:annotation>
  </xs:element> 
  <xs:complexType name="ConstantInfluenceFunctionType">
    <xs:complexContent>
      <xs:extension base="InfluenceFunctionType">
        <xs:sequence>
          <xs:element name="CouplingValue" type="pv:unknownScalar"> <!-- Einheit eigentlich m/N -->
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Kopplungswert zwischen zwei Konturen.
              </xs:documentation>
            </xs:annotation>
          </xs:element>            
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType> 

  <xs:element name="PolarContourFunction" substitutionGroup="Function" type="PolarContourFunctionType"/>
  <xs:complexType name="PolarContourFunctionType">
    <xs:complexContent>
      <xs:extension base="FunctionType">
        <xs:sequence>
          <xs:element name="radiusFunction">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
            tbd
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:choice>
                <xs:element ref="Function"/>
                <xs:element ref="pv:Embed"/>
              </xs:choice>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="Observer" substitutionGroup="Element" type="ObserverType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
    tbd.
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="ObserverType">
    <xs:complexContent>
      <xs:extension base="ElementType"/>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="MechanicalLinkObserver" substitutionGroup="Observer" type="MechanicalLinkObserverType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
    tbd.
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="MechanicalLinkObserverType">
    <xs:complexContent>
      <xs:extension base="ObserverType">
        <xs:sequence>
          <xs:element name="mechanicalLink">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
              tbd.
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:attribute name="ref" type="LinkReferenceType" use="required"/>
            </xs:complexType>
          </xs:element>
          <xs:element name="outputFrame" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Alle kartesischen Plotausgaben werden in diesem Koordinatensystemen ausgegeben. Wenn nicht angegeben wird das I-System von DynamicSystemSolver verwendet.
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:attribute name="ref" type="FrameReferenceType" use="required"/>
            </xs:complexType>
          </xs:element>
          <xs:element name="enableOpenMBVForce" minOccurs="0">  
            <xs:complexType>
              <xs:group ref="OpenMBVInteractionArrowParameters"/>
            </xs:complexType> 
          </xs:element>
          <xs:element name="enableOpenMBVMoment" minOccurs="0">  
            <xs:complexType>
              <xs:group ref="OpenMBVInteractionArrowParameters"/>
            </xs:complexType> 
          </xs:element>
        </xs:sequence> 
      </xs:extension>
    </xs:complexContent>
  </xs:complexType> 

  <xs:element name="ContactObserver" substitutionGroup="Observer" type="ContactObserverType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
    tbd.
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="ContactObserverType">
    <xs:complexContent>
      <xs:extension base="ObserverType">
        <xs:sequence>
          <xs:element name="contact">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
              tbd.
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:attribute name="ref" type="LinkReferenceType" use="required"/>
            </xs:complexType>
          </xs:element>
          <xs:element name="outputFrame" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Alle kartesischen Plotausgaben werden in diesem Koordinatensystemen ausgegeben. Wenn nicht angegeben wird das I-System von DynamicSystemSolver verwendet.
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:attribute name="ref" type="FrameReferenceType" use="required"/>
            </xs:complexType>
          </xs:element>
          <xs:element name="enableOpenMBVForce" minOccurs="0">
            <xs:complexType>
              <xs:group ref="OpenMBVInteractionArrowParameters"/>
            </xs:complexType>
          </xs:element>
          <xs:element name="enableOpenMBVMoment" minOccurs="0">
            <xs:complexType>
              <xs:group ref="OpenMBVInteractionArrowParameters"/>
            </xs:complexType>
          </xs:element>
          <xs:element name="enableOpenMBVContactPoints" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Aktiviert die Visualisierung von zwei OpenMBV Koordinatensystemen in den jeweiligen Kontaktpunkten zur Repräsentation der begleitenden Dreibeine <object class="inlineeqn">\left(\boldsymbol{n},\boldsymbol{t}_1,\boldsymbol{t}_2\right)</object> bestehend aus Normale und den beiden Tangenten.<br/>
                Bei geschlossenem Kontakt fallen die Kontaktpunkte zusammen.<br/>
                Bei offenem Kontakt liegen die Kontaktpunkte auf den Konturen und haben minimalen Abstand.
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:group ref="OpenMBVFrameParameters"/>
            </xs:complexType> 
          </xs:element>
          <xs:element name="enableOpenMBVNormalForce" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Wenn angegeben, wird die Kontaktkraft in Normalenrichtung durch einen OpenMBV Pfeil mit Wirkung auf die Kontur des zweiten Körpers in OpenMBV visualisiert.
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:group ref="OpenMBVInteractionArrowParameters"/>
            </xs:complexType> 
          </xs:element>
          <xs:element name="enableOpenMBVTangentialForce" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Wenn angegeben, wird die Reibkraft durch einen OpenMBV Pfeil mit Wirkung auf die Kontur des zweiten Körpers in OpenMBV visualisiert.
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:group ref="OpenMBVInteractionArrowParameters"/>
            </xs:complexType> 
          </xs:element>
        </xs:sequence> 
      </xs:extension>
    </xs:complexContent>
  </xs:complexType> 

  <xs:element name="MaxwellContactObserver" substitutionGroup="Observer" type="MaxwellContactObserverType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
    tbd.
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="MaxwellContactObserverType">
    <xs:complexContent>
      <xs:extension base="ObserverType">
        <xs:sequence>
          <xs:element name="maxwellContact">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
              tbd.
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:attribute name="ref" type="LinkReferenceType" use="required"/>
            </xs:complexType>
          </xs:element>
          <xs:element name="outputFrame" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Alle kartesischen Plotausgaben werden in diesem Koordinatensystemen ausgegeben. Wenn nicht angegeben wird das I-System von DynamicSystemSolver verwendet.
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:attribute name="ref" type="FrameReferenceType" use="required"/>
            </xs:complexType>
          </xs:element>
          <xs:element name="enableOpenMBVForce" minOccurs="0">
            <xs:complexType>
              <xs:group ref="OpenMBVArrowParameters"/>
            </xs:complexType>
          </xs:element>
          <xs:element name="enableOpenMBVMoment" minOccurs="0">
            <xs:complexType>
              <xs:group ref="OpenMBVArrowParameters"/>
            </xs:complexType>
          </xs:element>
          <xs:element name="enableOpenMBVContactPoints" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Aktiviert die Visualisierung von zwei OpenMBV Koordinatensystemen in den jeweiligen Kontaktpunkten zur Repräsentation der begleitenden Dreibeine <object class="inlineeqn">\left(\boldsymbol{n},\boldsymbol{t}_1,\boldsymbol{t}_2\right)</object> bestehend aus Normale und den beiden Tangenten.<br/>
                Bei geschlossenem Kontakt fallen die Kontaktpunkte zusammen.<br/>
                Bei offenem Kontakt liegen die Kontaktpunkte auf den Konturen und haben minimalen Abstand.
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:group ref="OpenMBVFrameParameters"/>
            </xs:complexType>
          </xs:element>
          <xs:element name="enableOpenMBVNormalForce" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Wenn angegeben, wird die Kontaktkraft in Normalenrichtung durch einen OpenMBV Pfeil mit Wirkung auf die Kontur des zweiten Körpers in OpenMBV visualisiert.
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:group ref="OpenMBVArrowParameters"/>
            </xs:complexType>
          </xs:element>
          <xs:element name="enableOpenMBVTangentialForce" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Wenn angegeben, wird die Reibkraft durch einen OpenMBV Pfeil mit Wirkung auf die Kontur des zweiten Körpers in OpenMBV visualisiert.
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:group ref="OpenMBVArrowParameters"/>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="MechanicalConstraintObserver" substitutionGroup="Observer" type="MechanicalConstraintObserverType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
    tbd.
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="MechanicalConstraintObserverType">
    <xs:complexContent>
      <xs:extension base="ObserverType">
        <xs:sequence>
          <xs:element name="mechanicalConstraint">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
              tbd.
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:attribute name="ref" type="ConstraintReferenceType" use="required"/>
            </xs:complexType>
          </xs:element>
          <xs:element name="outputFrame" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Alle kartesischen Plotausgaben werden in diesem Koordinatensystemen ausgegeben. Wenn nicht angegeben wird das I-System von DynamicSystemSolver verwendet.
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:attribute name="ref" type="FrameReferenceType" use="required"/>
            </xs:complexType>
          </xs:element>
          <xs:element name="enableOpenMBVForce" minOccurs="0">  
            <xs:complexType>
              <xs:group ref="OpenMBVInteractionArrowParameters"/>
            </xs:complexType> 
          </xs:element>
          <xs:element name="enableOpenMBVMoment" minOccurs="0">  
            <xs:complexType>
              <xs:group ref="OpenMBVInteractionArrowParameters"/>
            </xs:complexType> 
          </xs:element>
        </xs:sequence> 
      </xs:extension>
    </xs:complexContent>
  </xs:complexType> 

  <xs:element name="RigidBodyObserver" substitutionGroup="Observer" type="RigidBodyObserverType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
    tbd.
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="RigidBodyObserverType">
    <xs:complexContent>
      <xs:extension base="ObserverType">
        <xs:sequence>
          <xs:element name="rigidBody">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
              tbd.
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:attribute name="ref" type="ObjectReferenceType" use="required"/>
            </xs:complexType>
          </xs:element>
          <xs:element name="frameOfReference" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                tbd.
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:attribute name="ref" type="FrameReferenceType" use="required"/>
            </xs:complexType>
          </xs:element>
          <xs:element name="outputFrame" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Alle kartesischen Plotausgaben werden in diesem Koordinatensystemen ausgegeben. Wenn nicht angegeben wird das I-System von DynamicSystemSolver verwendet.
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:attribute name="ref" type="FrameReferenceType" use="required"/>
            </xs:complexType>
          </xs:element>
          <xs:element name="enableOpenMBVWeight" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Wenn angegeben, wird die Gewichtskraft durch einen OpenMBV Pfeil in OpenMBV visualisiert.
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:group ref="OpenMBVArrowParameters"/>
            </xs:complexType> 
          </xs:element>
          <xs:element name="enableOpenMBVJointForce" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Wenn angegeben, wird die Gelenkkraft durch einen OpenMBV Pfeil in OpenMBV visualisiert.
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:group ref="OpenMBVInteractionArrowParameters"/>
            </xs:complexType> 
          </xs:element>
          <xs:element name="enableOpenMBVJointMoment" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Wenn angegeben, wird das Gelenkmoment durch einen OpenMBV Pfeil in OpenMBV visualisiert.
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:group ref="OpenMBVInteractionArrowParameters"/>
            </xs:complexType> 
          </xs:element>
          <xs:element name="enableOpenMBVAxisOfRotation" minOccurs="0">
            <xs:complexType>
              <xs:group ref="OpenMBVArrowParameters"/>
            </xs:complexType>
          </xs:element>
          <xs:element name="enableOpenMBVMomentum" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Wenn angegeben, wird der Impuls durch einen OpenMBV Pfeil in OpenMBV visualisiert.
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:group ref="OpenMBVArrowParameters"/>
            </xs:complexType>
          </xs:element>
          <xs:element name="enableOpenMBVAngularMomentum" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Wenn angegeben, wird der Drehimpuls durch einen OpenMBV Pfeil in OpenMBV visualisiert.
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:group ref="OpenMBVArrowParameters"/>
            </xs:complexType>
          </xs:element>
          <xs:element name="enableOpenMBVDerivativeOfMomentum" minOccurs="0">
            <xs:complexType>
              <xs:group ref="OpenMBVArrowParameters"/>
            </xs:complexType>
          </xs:element>
          <xs:element name="enableOpenMBVDerivativeOfAngularMomentum" minOccurs="0">
            <xs:complexType>
              <xs:group ref="OpenMBVArrowParameters"/>
            </xs:complexType>
          </xs:element>
        </xs:sequence> 
      </xs:extension>
    </xs:complexContent>
  </xs:complexType> 

  <xs:element name="FrameObserver" substitutionGroup="Observer" type="FrameObserverType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
    tbd.
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="FrameObserverType">
    <xs:complexContent>
      <xs:extension base="ObserverType">
        <xs:sequence>
          <xs:element name="frame">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
              tbd.
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:attribute name="ref" type="FrameReferenceType" use="required"/>
            </xs:complexType>
          </xs:element>
          <xs:element name="outputFrame" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Alle kartesischen Plotausgaben werden in diesem Koordinatensystemen ausgegeben. Wenn nicht angegeben wird das I-System von DynamicSystemSolver verwendet.
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:attribute name="ref" type="FrameReferenceType" use="required"/>
            </xs:complexType>
          </xs:element>
          <xs:element name="enableOpenMBVPosition" minOccurs="0">
            <xs:complexType>
              <xs:group ref="OpenMBVArrowParameters"/>
            </xs:complexType>
          </xs:element>
          <xs:element name="enableOpenMBVVelocity" minOccurs="0">
            <xs:complexType>
              <xs:group ref="OpenMBVArrowParameters"/>
            </xs:complexType>
          </xs:element>
          <xs:element name="enableOpenMBVAngularVelocity" minOccurs="0">
            <xs:complexType>
              <xs:group ref="OpenMBVArrowParameters"/>
            </xs:complexType>
          </xs:element>
          <xs:element name="enableOpenMBVAcceleration" minOccurs="0">
            <xs:complexType>
              <xs:group ref="OpenMBVArrowParameters"/>
            </xs:complexType>
          </xs:element>
          <xs:element name="enableOpenMBVAngularAcceleration" minOccurs="0">
            <xs:complexType>
              <xs:group ref="OpenMBVArrowParameters"/>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="InverseKinematicsConstraintObserver" substitutionGroup="Observer" type="InverseKinematicsConstraintObserverType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
    tbd.
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="InverseKinematicsConstraintObserverType">
    <xs:complexContent>
      <xs:extension base="ObserverType">
        <xs:sequence>
          <xs:element name="inverseKinematicsConstraint">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
              tbd.
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:attribute name="ref" type="ConstraintReferenceType" use="required"/>
            </xs:complexType>
          </xs:element>
          <xs:element name="outputFrame" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Alle kartesischen Plotausgaben werden in diesem Koordinatensystemen ausgegeben. Wenn nicht angegeben wird das I-System von DynamicSystemSolver verwendet.
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:attribute name="ref" type="FrameReferenceType" use="required"/>
            </xs:complexType>
          </xs:element>
          <xs:element name="enableOpenMBV" minOccurs="0">
            <xs:complexType>
              <xs:group ref="OpenMBVArrowParameters"/>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="TyreContactObserver" substitutionGroup="MechanicalLinkObserver" type="TyreContactObserverType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
    tbd.
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="TyreContactObserverType">
    <xs:complexContent>
      <xs:extension base="MechanicalLinkObserverType">
        <xs:sequence>
          <xs:element name="enableOpenMBVContactPoints" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Aktiviert die Visualisierung von zwei OpenMBV Koordinatensystemen in den jeweiligen Kontaktpunkten zur Repräsentation der begleitenden Dreibeine <object class="inlineeqn">\left(\boldsymbol{n},\boldsymbol{t}_1,\boldsymbol{t}_2\right)</object> bestehend aus Normale und den beiden Tangenten.<br/>
                Bei geschlossenem Kontakt fallen die Kontaktpunkte zusammen.<br/>
                Bei offenem Kontakt liegen die Kontaktpunkte auf den Konturen und haben minimalen Abstand.
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:group ref="OpenMBVFrameParameters"/>
            </xs:complexType>
          </xs:element>
          <xs:element name="enableOpenMBVNormalForce" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:group ref="OpenMBVInteractionArrowParameters"/>
            </xs:complexType>
          </xs:element>
          <xs:element name="enableOpenMBVLongitudinalForce" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:group ref="OpenMBVInteractionArrowParameters"/>
            </xs:complexType>
          </xs:element>
          <xs:element name="enableOpenMBVLateralForce" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:group ref="OpenMBVInteractionArrowParameters"/>
            </xs:complexType>
          </xs:element>
          <xs:element name="enableOpenMBVOverturningMoment" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:group ref="OpenMBVInteractionArrowParameters"/>
            </xs:complexType>
          </xs:element>
          <xs:element name="enableOpenMBVRollingResistanceMoment" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:group ref="OpenMBVInteractionArrowParameters"/>
            </xs:complexType>
          </xs:element>
          <xs:element name="enableOpenMBVAligningMoment" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                tbd
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:group ref="OpenMBVInteractionArrowParameters"/>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="Solver" abstract="true" type="SolverType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
    tbd
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="SolverType">
  </xs:complexType> 

  <xs:element name="Integrator" abstract="true" substitutionGroup="Solver" type="IntegratorType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Abstrakte Oberklasse für Zeitintegratoren.
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="IntegratorType">
    <xs:complexContent>
      <xs:extension base="SolverType">
        <xs:sequence>
          <xs:element name="startTime" type="pv:timeScalar">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Startzeitpunkt der Integration.
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="endTime" type="pv:timeScalar">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Endzeitpunkt der Integration.
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="plotStepSize" type="pv:timeScalar">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Schrittweite zur Ausgabe von Plotdaten.<br/>
                Die Schrittweite zur Ausgabe von Plotdaten darf nicht kleiner als die Integrationsschrittweite sein.
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="initialState" type="pv:unknownVector" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Anfangszustand der Differentialinklusion.
            </xs:documentation></xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="RootFindingIntegrator" substitutionGroup="Integrator" type="RootFindingIntegratorType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Livermore Solver for Ordinary Differential Equations. Integrator zur Lösung von Anfangswertproblemen für gewöhnliche Differentialgleichungssysteme. Das Verfahren enthält eine Schrittweitensteuerung und ist für steife und nicht-steife DGL-Systeme geeignet.
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="RootFindingIntegratorType">
    <xs:complexContent>
      <xs:extension base="IntegratorType">
        <xs:sequence>
          <xs:element name="toleranceForPositionConstraints" type="pv:unknownScalar" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Definiert die Schanke ab welcher eine Projektion der Bindungsgleichung auf Lageebene durchgefürt wird wenn diese
              Schranke überschritten ist (Positions-Drift). Wird dise überschritten wird unmittelbar danach automatisch auch
              eine Projektion der Bindungsgleichungen auf Geschwindigkeitsebene durchgeführt.
              Ist der Wert &lt; 0 ist die Projektion auf Lageebene ausgeschaltet.
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="toleranceForVelocityConstraints" type="pv:unknownScalar" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Definiert die Schanke ab welcher eine Projektion der Bindungsgleichung auf Geschwindigkeitsebene durchgefürt wird wenn diese
              Schranke überschritten ist (Geschwindigkeits-Drift).
              Ist der Wert &lt; 0 ist die Projektion auf Geschwindigkeitsebene ausgeschaltet.
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="rootFindingAccuracy" type="pv:timeScalar" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Genauigkeit der Schaltpunktsuche.
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="plotOnRoot" type="pv:booleanFullEval" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Gibt an, ob eine Plot-Ausgabe geschrieben werden soll, wenn eine Indikatorfunktion einen Nulldurchgang hat.
            </xs:documentation></xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="DOPRI5Integrator" substitutionGroup="RootFindingIntegrator" type="DOPRI5IntegratorType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Explizites Runge-Kutta Verfahren der Ordnung 5(4) mit 'dense output' der Ordnung 4.<br/>
        Das Verfahren ist nur für nicht-steife Differentialgleichungen bestimmt und verwendet automatische Schrittweitenbestimmung.
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="DOPRI5IntegratorType">
    <xs:complexContent>
      <xs:extension base="RootFindingIntegratorType">
        <xs:sequence>
          <xs:choice>
            <xs:element name="absoluteTolerance" type="pv:unknownVector" minOccurs="0">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                  Absoluter Fehlertoleranzvektor bezogen auf die Zustandsgrößen der Differentialgleichung.
              </xs:documentation></xs:annotation>
            </xs:element>
            <xs:element name="absoluteToleranceScalar" type="pv:unknownScalar" minOccurs="0">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                  Absolute Fehlertoleranz ist für alle Zustandsgrößen der Differentialgleichung gemäß dem angegebenen Wert.
              </xs:documentation></xs:annotation>
            </xs:element>
          </xs:choice>
          <xs:choice>
            <xs:element name="relativeTolerance" type="pv:nounitVector" minOccurs="0">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                  Relativer Fehlertoleranzvektor bezogen auf die Zustandsgrößen der Differentialgleichung.
              </xs:documentation></xs:annotation>
            </xs:element>
            <xs:element name="relativeToleranceScalar" type="pv:nounitScalar" minOccurs="0">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                  Relative Fehlertoleranz ist für alle Zustandsgrößen der Differentialgleichung gemäß dem angegebenen Wert.
              </xs:documentation></xs:annotation>
            </xs:element>
          </xs:choice>
          <xs:element name="initialStepSize" type="pv:timeScalar" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Schrittweitenvorschlag zu Beginn der Integration.
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="maximumStepSize" type="pv:timeScalar" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Maximal zu verwendende Schrittweite.
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="stepLimit" type="pv:integerFullEval" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Maximale Anzahl von Integrationsschritten.
            </xs:documentation></xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="DOP853Integrator" substitutionGroup="RootFindingIntegrator" type="DOP853IntegratorType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Explizites Runge-Kutta Verfahren der Ordnung 8(5,3) mit 'dense output'.<br/>
        Das Verfahren ist nur für nicht-steife Differentialgleichungen bestimmt und verwendet automatische Schrittweitenbestimmung.
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="DOP853IntegratorType">
    <xs:complexContent>
      <xs:extension base="RootFindingIntegratorType">
        <xs:sequence>
          <xs:choice>
            <xs:element name="absoluteTolerance" type="pv:unknownVector" minOccurs="0">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                  Absoluter Fehlertoleranzvektor bezogen auf die Zustandsgrößen der Differentialgleichung.
              </xs:documentation></xs:annotation>
            </xs:element>
            <xs:element name="absoluteToleranceScalar" type="pv:unknownScalar" minOccurs="0">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                  Absolute Fehlertoleranz ist für alle Zustandsgrößen der Differentialgleichung gemäß dem angegebenen Wert.
              </xs:documentation></xs:annotation>
            </xs:element>
          </xs:choice>
          <xs:choice>
            <xs:element name="relativeTolerance" type="pv:nounitVector" minOccurs="0">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                  Relativer Fehlertoleranzvektor bezogen auf die Zustandsgrößen der Differentialgleichung.
              </xs:documentation></xs:annotation>
            </xs:element>
            <xs:element name="relativeToleranceScalar" type="pv:nounitScalar" minOccurs="0">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                  Relative Fehlertoleranz ist für alle Zustandsgrößen der Differentialgleichung gemäß dem angegebenen Wert.
              </xs:documentation></xs:annotation>
            </xs:element>
          </xs:choice>
          <xs:element name="initialStepSize" type="pv:timeScalar" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Schrittweitenvorschlag zu Beginn der Integration.
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="maximumStepSize" type="pv:timeScalar" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Maximal zu verwendende Schrittweite.
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="stepLimit" type="pv:integerFullEval" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Maximale Anzahl von Integrationsschritten.
            </xs:documentation></xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="ODEXIntegrator" substitutionGroup="RootFindingIntegrator" type="ODEXIntegratorType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Extrapolations-Verfahren (GBS), basierend auf der 'explicit midpoint rule'.<br/>
        Das Verfahren ist nur für nicht-steife Differentialgleichungen bestimmt und verwendet automatische Schrittweitenbestimmung.
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="ODEXIntegratorType">
    <xs:complexContent>
      <xs:extension base="RootFindingIntegratorType">
        <xs:sequence>
          <xs:choice>
            <xs:element name="absoluteTolerance" type="pv:unknownVector" minOccurs="0">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                  Absoluter Fehlertoleranzvektor bezogen auf die Zustandsgrößen der Differentialgleichung.
              </xs:documentation></xs:annotation>
            </xs:element>
            <xs:element name="absoluteToleranceScalar" type="pv:unknownScalar" minOccurs="0">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                  Absolute Fehlertoleranz ist für alle Zustandsgrößen der Differentialgleichung gemäß dem angegebenen Wert.
              </xs:documentation></xs:annotation>
            </xs:element>
          </xs:choice>
          <xs:choice>
            <xs:element name="relativeTolerance" type="pv:nounitVector" minOccurs="0">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                  Relativer Fehlertoleranzvektor bezogen auf die Zustandsgrößen der Differentialgleichung.
              </xs:documentation></xs:annotation>
            </xs:element>
            <xs:element name="relativeToleranceScalar" type="pv:nounitScalar" minOccurs="0">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                  Relative Fehlertoleranz ist für alle Zustandsgrößen der Differentialgleichung gemäß dem angegebenen Wert.
              </xs:documentation></xs:annotation>
            </xs:element>
          </xs:choice>
          <xs:element name="initialStepSize" type="pv:timeScalar" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Schrittweitenvorschlag zu Beginn der Integration.
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="maximumStepSize" type="pv:timeScalar" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Maximal zu verwendende Schrittweite.
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="stepLimit" type="pv:integerFullEval" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Maximale Anzahl von Integrationsschritten.
            </xs:documentation></xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="RADAU5Integrator" substitutionGroup="RootFindingIntegrator" type="RADAU5IntegratorType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Implizites Runge-Kutta Verfahren der Ordnung 5 (Radau IIA) mit 'dense output'.<br/>
        Das Verfahren ist für steife Differentialgleichungen bestimmt und verwendet automatische Schrittweitenbestimmung.
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="RADAU5IntegratorType">
    <xs:complexContent>
      <xs:extension base="RootFindingIntegratorType">
        <xs:sequence>
          <xs:choice>
            <xs:element name="absoluteTolerance" type="pv:unknownVector" minOccurs="0">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                  Absoluter Fehlertoleranzvektor bezogen auf die Zustandsgrößen der Differentialgleichung.
              </xs:documentation></xs:annotation>
            </xs:element>
            <xs:element name="absoluteToleranceScalar" type="pv:unknownScalar" minOccurs="0">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                  Absolute Fehlertoleranz ist für alle Zustandsgrößen der Differentialgleichung gemäß dem angegebenen Wert.
              </xs:documentation></xs:annotation>
            </xs:element>
          </xs:choice>
          <xs:choice>
            <xs:element name="relativeTolerance" type="pv:nounitVector" minOccurs="0">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                  Relativer Fehlertoleranzvektor bezogen auf die Zustandsgrößen der Differentialgleichung.
              </xs:documentation></xs:annotation>
            </xs:element>
            <xs:element name="relativeToleranceScalar" type="pv:nounitScalar" minOccurs="0">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                  Relative Fehlertoleranz ist für alle Zustandsgrößen der Differentialgleichung gemäß dem angegebenen Wert.
              </xs:documentation></xs:annotation>
            </xs:element>
          </xs:choice>
          <xs:element name="initialStepSize" type="pv:timeScalar" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Schrittweitenvorschlag zu Beginn der Integration.
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="maximumStepSize" type="pv:timeScalar" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Maximal zu verwendende Schrittweite.
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="stepLimit" type="pv:integerFullEval" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Maximale Anzahl von Integrationsschritten.
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="formalism" type="pv:stringFullEval" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Auswahl des Formalismus.
              <ul>
                <li>ODE: gewöhnliches Differentialgleichungssystem</li>
                <li>DAE1: differential-algebraisches System vom Index 1</li>
                <li>DAE2: differential-algebraisches System vom Index 2</li>
                <li>DAE3: differential-algebraisches System vom Index 3</li>
                <li>GGL: differential-algebraisches System vom Index 2 mit Gear Gupta Leimkuhler Stabilisierung</li>
              </ul>
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="reducedForm" type="pv:booleanFullEval" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Lösen des nichtlinearen Gleichungssystems in reduzierter Form. Das differentielle System muss dazu die spezielle Struktur dq(i)/dt = u(i) für i=1,...,nq haben.
            </xs:documentation></xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="RADAUIntegrator" substitutionGroup="RootFindingIntegrator" type="RADAUIntegratorType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Implizites Runge-Kutta Verfahren (Radau IIA) mit variabler Ordnung (5,9,13) und 'dense output'.<br/>
        Das Verfahren ist für steife Differentialgleichungen bestimmt und verwendet automatische Schrittweitenbestimmung.
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="RADAUIntegratorType">
    <xs:complexContent>
      <xs:extension base="RootFindingIntegratorType">
        <xs:sequence>
          <xs:choice>
            <xs:element name="absoluteTolerance" type="pv:unknownVector" minOccurs="0">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                  Absoluter Fehlertoleranzvektor bezogen auf die Zustandsgrößen der Differentialgleichung.
              </xs:documentation></xs:annotation>
            </xs:element>
            <xs:element name="absoluteToleranceScalar" type="pv:unknownScalar" minOccurs="0">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                  Absolute Fehlertoleranz ist für alle Zustandsgrößen der Differentialgleichung gemäß dem angegebenen Wert.
              </xs:documentation></xs:annotation>
            </xs:element>
          </xs:choice>
          <xs:choice>
            <xs:element name="relativeTolerance" type="pv:nounitVector" minOccurs="0">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                  Relativer Fehlertoleranzvektor bezogen auf die Zustandsgrößen der Differentialgleichung.
              </xs:documentation></xs:annotation>
            </xs:element>
            <xs:element name="relativeToleranceScalar" type="pv:nounitScalar" minOccurs="0">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                  Relative Fehlertoleranz ist für alle Zustandsgrößen der Differentialgleichung gemäß dem angegebenen Wert.
              </xs:documentation></xs:annotation>
            </xs:element>
          </xs:choice>
          <xs:element name="initialStepSize" type="pv:timeScalar" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Schrittweitenvorschlag zu Beginn der Integration.
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="maximumStepSize" type="pv:timeScalar" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Maximal zu verwendende Schrittweite.
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="stepLimit" type="pv:integerFullEval" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Maximale Anzahl von Integrationsschritten.
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="formalism" type="pv:stringFullEval" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Auswahl des Formalismus.
              <ul>
                <li>ODE: gewöhnliches Differentialgleichungssystem</li>
                <li>DAE1: differential-algebraisches System vom Index 1</li>
                <li>DAE2: differential-algebraisches System vom Index 2</li>
                <li>DAE3: differential-algebraisches System vom Index 3</li>
                <li>GGL: differential-algebraisches System vom Index 2 mit Gear Gupta Leimkuhler Stabilisierung</li>
              </ul>
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="reducedForm" type="pv:booleanFullEval" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Lösen des nichtlinearen Gleichungssystems in reduzierter Form. Das differentielle System muss dazu die spezielle Struktur dq(i)/dt = u(i) für i=1,...,nq haben.
            </xs:documentation></xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="RODASIntegrator" substitutionGroup="RootFindingIntegrator" type="RODASIntegratorType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Eingebettetes Rosenbrock Verfahren der Ordnung (3)4 mit Schrittweitenkontrolle und 'dense output'.<br/>
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="RODASIntegratorType">
    <xs:complexContent>
      <xs:extension base="RootFindingIntegratorType">
        <xs:sequence>
          <xs:choice>
            <xs:element name="absoluteTolerance" type="pv:unknownVector" minOccurs="0">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                  Absoluter Fehlertoleranzvektor bezogen auf die Zustandsgrößen der Differentialgleichung.
              </xs:documentation></xs:annotation>
            </xs:element>
            <xs:element name="absoluteToleranceScalar" type="pv:unknownScalar" minOccurs="0">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                  Absolute Fehlertoleranz ist für alle Zustandsgrößen der Differentialgleichung gemäß dem angegebenen Wert.
              </xs:documentation></xs:annotation>
            </xs:element>
          </xs:choice>
          <xs:choice>
            <xs:element name="relativeTolerance" type="pv:nounitVector" minOccurs="0">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                  Relativer Fehlertoleranzvektor bezogen auf die Zustandsgrößen der Differentialgleichung.
              </xs:documentation></xs:annotation>
            </xs:element>
            <xs:element name="relativeToleranceScalar" type="pv:nounitScalar" minOccurs="0">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                  Relative Fehlertoleranz ist für alle Zustandsgrößen der Differentialgleichung gemäß dem angegebenen Wert.
              </xs:documentation></xs:annotation>
            </xs:element>
          </xs:choice>
          <xs:element name="initialStepSize" type="pv:timeScalar" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Schrittweitenvorschlag zu Beginn der Integration.
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="maximumStepSize" type="pv:timeScalar" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Maximal zu verwendende Schrittweite.
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="stepLimit" type="pv:integerFullEval" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Maximale Anzahl von Integrationsschritten.
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="formalism" type="pv:stringFullEval" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Auswahl des Formalismus.
              <ul>
                <li>ODE: gewöhnliches Differentialgleichungssystem</li>
                <li>DAE1: differential-algebraisches System vom Index 1</li>
              </ul>
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="reducedForm" type="pv:booleanFullEval" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Lösen des nichtlinearen Gleichungssystems in reduzierter Form. Das differentielle System muss dazu die spezielle Struktur dq(i)/dt = u(i) für i=1,...,nq haben.
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="autonomousSystem" type="pv:booleanFullEval" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Definiert, ob das System von der Zeit abhängt (nicht-autonomes System) oder nicht (autonomes System).
            </xs:documentation></xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="SEULEXIntegrator" substitutionGroup="RootFindingIntegrator" type="SEULEXIntegratorType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Extrapolations-Algorithmus, basierend auf dem linear implizten Euler-Verfahren.<br/>
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="SEULEXIntegratorType">
    <xs:complexContent>
      <xs:extension base="RootFindingIntegratorType">
        <xs:sequence>
          <xs:choice>
            <xs:element name="absoluteTolerance" type="pv:unknownVector" minOccurs="0">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                  Absoluter Fehlertoleranzvektor bezogen auf die Zustandsgrößen der Differentialgleichung.
              </xs:documentation></xs:annotation>
            </xs:element>
            <xs:element name="absoluteToleranceScalar" type="pv:unknownScalar" minOccurs="0">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                  Absolute Fehlertoleranz ist für alle Zustandsgrößen der Differentialgleichung gemäß dem angegebenen Wert.
              </xs:documentation></xs:annotation>
            </xs:element>
          </xs:choice>
          <xs:choice>
            <xs:element name="relativeTolerance" type="pv:nounitVector" minOccurs="0">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                  Relativer Fehlertoleranzvektor bezogen auf die Zustandsgrößen der Differentialgleichung.
              </xs:documentation></xs:annotation>
            </xs:element>
            <xs:element name="relativeToleranceScalar" type="pv:nounitScalar" minOccurs="0">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                  Relative Fehlertoleranz ist für alle Zustandsgrößen der Differentialgleichung gemäß dem angegebenen Wert.
              </xs:documentation></xs:annotation>
            </xs:element>
          </xs:choice>
          <xs:element name="initialStepSize" type="pv:timeScalar" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Schrittweitenvorschlag zu Beginn der Integration.
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="maximumStepSize" type="pv:timeScalar" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Maximal zu verwendende Schrittweite.
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="stepLimit" type="pv:integerFullEval" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Maximale Anzahl von Integrationsschritten.
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="formalism" type="pv:stringFullEval" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Auswahl des Formalismus.
              <ul>
                <li>ODE: gewöhnliches Differentialgleichungssystem</li>
                <li>DAE1: differential-algebraisches System vom Index 1</li>
              </ul>
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="reducedForm" type="pv:booleanFullEval" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Lösen des nichtlinearen Gleichungssystems in reduzierter Form. Das differentielle System muss dazu die spezielle Struktur dq(i)/dt = u(i) für i=1,...,nq haben.
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="autonomousSystem" type="pv:booleanFullEval" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Definiert, ob das System von der Zeit abhängt (nicht-autonomes System) oder nicht (autonomes System).
            </xs:documentation></xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="PHEM56Integrator" substitutionGroup="RootFindingIntegrator" type="PHEM56IntegratorType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Halb-explizites Verfahren nach Murua der Ordnung 5 mit 'dense output' der Ordnung 4.<br/>
        Das Verfahren ist nur für nicht-steife Differentialgleichungen bestimmt und verwendet automatische Schrittweitenbestimmung.
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="PHEM56IntegratorType">
    <xs:complexContent>
      <xs:extension base="RootFindingIntegratorType">
        <xs:sequence>
          <xs:choice>
            <xs:element name="absoluteTolerance" type="pv:unknownVector" minOccurs="0">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                  Absoluter Fehlertoleranzvektor bezogen auf die Zustandsgrößen der Differentialgleichung.
              </xs:documentation></xs:annotation>
            </xs:element>
            <xs:element name="absoluteToleranceScalar" type="pv:unknownScalar" minOccurs="0">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                  Absolute Fehlertoleranz ist für alle Zustandsgrößen der Differentialgleichung gemäß dem angegebenen Wert.
              </xs:documentation></xs:annotation>
            </xs:element>
          </xs:choice>
          <xs:choice>
            <xs:element name="relativeTolerance" type="pv:nounitVector" minOccurs="0">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                  Relativer Fehlertoleranzvektor bezogen auf die Zustandsgrößen der Differentialgleichung.
              </xs:documentation></xs:annotation>
            </xs:element>
            <xs:element name="relativeToleranceScalar" type="pv:nounitScalar" minOccurs="0">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                  Relative Fehlertoleranz ist für alle Zustandsgrößen der Differentialgleichung gemäß dem angegebenen Wert.
              </xs:documentation></xs:annotation>
            </xs:element>
          </xs:choice>
          <xs:element name="initialStepSize" type="pv:timeScalar" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Schrittweitenvorschlag zu Beginn der Integration.
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="maximumStepSize" type="pv:timeScalar" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Maximal zu verwendende Schrittweite.
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="stepLimit" type="pv:integerFullEval" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Maximale Anzahl von Integrationsschritten.
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="linearAlgebra" type="pv:stringFullEval" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Auswahl der linearen Algebra.
              <ul>
                <li>DEC: Interne Routine</li>
                <li>DGETRF: LAPACK-Routine</li>
              </ul>
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="generalVMatrix" type="pv:booleanFullEval" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Gibt an, ob eine allgemeine V-Matrix vorliegt, z.B. im Fall von Trockenreibung.
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="initialProjection" type="pv:booleanFullEval" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Gibt an, ob zu Beginn der Integration eine Projektion auf die Index-3-Nebenbedingungen (Nebenbedingungen auf Lageebene) durchgeführt werden soll.
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="numberOfStepsBetweenProjections" type="pv:integerFullEval" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Gibt an, nach wievielen Schritten die nächste Projektion auf die Index-3-Nebenbedingungen (Nebenbedingungen auf Lageebene) durchgeführt werden soll. Bei Angabe von 0 wird keine Projektion durchgeführt.
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="projectOntoIndex1ConstraintManifold" type="pv:booleanFullEval" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Gibt an, ob eine Projektion auf die Index-1-Nebenbedingungen (Nebenbedingungen auf Beschleunigungsebene) durchgeführt werden soll.
            </xs:documentation></xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="LSODEIntegrator" substitutionGroup="RootFindingIntegrator" type="LSODEIntegratorType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Livermore Solver for Ordinary Differential Equations. Integrator zur Lösung von Anfangswertproblemen für gewöhnliche Differentialgleichungssysteme. Das Verfahren enthält eine Schrittweitensteuerung und ist für steife und nicht-steife DGL-Systeme geeignet.
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="LSODEIntegratorType">
    <xs:complexContent>
      <xs:extension base="RootFindingIntegratorType">
        <xs:sequence>
          <xs:element name="method" type="pv:stringFullEval" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Auswahl der Integrationsmethode.
              <ul>
                <li>nonstiff: Nichtsteifes Verfahren (Adams Verfahren)</li>
                <li>Adams: siehe nonstiff</li>
                <li>stiff: Steifes Verfahren (bachward differentiation formula)</li>
                <li>BDF: siehe stiff</li>
              </ul>
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:choice>
            <xs:element name="absoluteTolerance" type="pv:unknownVector" minOccurs="0">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                  Absoluter Fehlertoleranzvektor bezogen auf die Zustandsgrößen der Differentialgleichung.
              </xs:documentation></xs:annotation>
            </xs:element>
            <xs:element name="absoluteToleranceScalar" type="pv:unknownScalar" minOccurs="0">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                  Absolute Fehlertoleranz ist für alle Zustandsgrößen der Differentialgleichung gemäß dem angegebenen Wert.
              </xs:documentation></xs:annotation>
            </xs:element>
          </xs:choice>
          <xs:choice>
            <xs:element name="relativeTolerance" type="pv:unknownVector" minOccurs="0">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                  Relative Fehlertoleranzvektor bezogen auf die Zustandsgrößen der Differentialgleichung.
              </xs:documentation></xs:annotation>
            </xs:element>
            <xs:element name="relativeToleranceScalar" type="pv:nounitScalar" minOccurs="0">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                  Relative Fehlertoleranz ist für alle Zustandsgrößen der Differentialgleichung gemäß dem angegebenen Wert.
              </xs:documentation></xs:annotation>
            </xs:element>
          </xs:choice>
          <xs:element name="initialStepSize" type="pv:timeScalar" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Schrittweitenvorschlag zu Beginn der Integration.
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="maximumStepSize" type="pv:timeScalar" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Maximal zu verwendende Schrittweite.
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="minimumStepSize" type="pv:timeScalar" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Minimal zu verwendende Schrittweite.
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="stepLimit" type="pv:integerFullEval" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Maximale Anzahl von Integrationsschritten.
            </xs:documentation></xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="LSODAIntegrator" substitutionGroup="RootFindingIntegrator" type="LSODAIntegratorType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Livermore Solver for Ordinary Differential Equations. Integrator zur Lösung von Anfangswertproblemen für gewöhnliche Differentialgleichungssysteme. Das Verfahren enthält eine Schrittweitensteuerung und wählt automatisch die Integrationsmethode, je nach dem ob ein steifes oder nicht-steifes DGL-System vorliegt.
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="LSODAIntegratorType">
    <xs:complexContent>
      <xs:extension base="RootFindingIntegratorType">
        <xs:sequence>
          <xs:choice>
            <xs:element name="absoluteTolerance" type="pv:unknownVector" minOccurs="0">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                  Absoluter Fehlertoleranzvektor bezogen auf die Zustandsgrößen der Differentialgleichung.
              </xs:documentation></xs:annotation>
            </xs:element>
            <xs:element name="absoluteToleranceScalar" type="pv:unknownScalar" minOccurs="0">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                  Absolute Fehlertoleranz ist für alle Zustandsgrößen der Differentialgleichung gemäß dem angegebenen Wert.
              </xs:documentation></xs:annotation>
            </xs:element>
          </xs:choice>
          <xs:choice>
            <xs:element name="relativeTolerance" type="pv:unknownVector" minOccurs="0">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                  Relative Fehlertoleranzvektor bezogen auf die Zustandsgrößen der Differentialgleichung.
              </xs:documentation></xs:annotation>
            </xs:element>
            <xs:element name="relativeToleranceScalar" type="pv:nounitScalar" minOccurs="0">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                  Relative Fehlertoleranz ist für alle Zustandsgrößen der Differentialgleichung gemäß dem angegebenen Wert.
              </xs:documentation></xs:annotation>
            </xs:element>
          </xs:choice>
          <xs:element name="initialStepSize" type="pv:timeScalar" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Schrittweitenvorschlag zu Beginn der Integration.
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="maximumStepSize" type="pv:timeScalar" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Maximal zu verwendende Schrittweite.
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="minimumStepSize" type="pv:timeScalar" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Minimal zu verwendende Schrittweite.
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="stepLimit" type="pv:integerFullEval" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Maximale Anzahl von Integrationsschritten.
            </xs:documentation></xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="LSODIIntegrator" substitutionGroup="RootFindingIntegrator" type="LSODIIntegratorType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Livermore Solver for Ordinary Differential Equations (Implicit form). Integrator zur Lösung von Anfangswertproblemen für differential-algebraische Systeme vom Index 2.
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="LSODIIntegratorType">
    <xs:complexContent>
      <xs:extension base="RootFindingIntegratorType">
        <xs:sequence>
          <xs:choice>
            <xs:element name="absoluteTolerance" type="pv:unknownVector" minOccurs="0">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                  Absoluter Fehlertoleranzvektor bezogen auf die Zustandsgrößen der Differentialgleichung.
              </xs:documentation></xs:annotation>
            </xs:element>
            <xs:element name="absoluteToleranceScalar" type="pv:unknownScalar" minOccurs="0">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                  Absolute Fehlertoleranz ist für alle Zustandsgrößen der Differentialgleichung gemäß dem angegebenen Wert.
              </xs:documentation></xs:annotation>
            </xs:element>
          </xs:choice>
          <xs:choice>
            <xs:element name="relativeTolerance" type="pv:unknownVector" minOccurs="0">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                  Relative Fehlertoleranzvektor bezogen auf die Zustandsgrößen der Differentialgleichung.
              </xs:documentation></xs:annotation>
            </xs:element>
            <xs:element name="relativeToleranceScalar" type="pv:nounitScalar" minOccurs="0">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                  Relative Fehlertoleranz ist für alle Zustandsgrößen der Differentialgleichung gemäß dem angegebenen Wert.
              </xs:documentation></xs:annotation>
            </xs:element>
          </xs:choice>
          <xs:element name="initialStepSize" type="pv:timeScalar" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Schrittweitenvorschlag zu Beginn der Integration.
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="maximumStepSize" type="pv:timeScalar" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Maximal zu verwendende Schrittweite.
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="minimumStepSize" type="pv:timeScalar" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Minimal zu verwendende Schrittweite.
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="stepLimit" type="pv:integerFullEval" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Maximale Anzahl von Integrationsschritten.
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="formalism" type="pv:stringFullEval" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Auswahl des Formalismus.
              <ul>
                <li>ODE: gewöhnliches Differentialgleichungssystem</li>
                <li>DAE2: differential-algebraisches System vom Index 2</li>
                <li>GGL: differential-algebraisches System vom Index 2 mit Gear Gupta Leimkuhler Stabilisierung</li>
              </ul>
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="excludeAlgebraicVariablesFromErrorTest" type="pv:booleanFullEval" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
               Algebraische Variablen vom Fehlertest ausschließen.
            </xs:documentation></xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="TimeSteppingIntegrator" substitutionGroup="Integrator" type="TimeSteppingIntegratorType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Halb-explizite Timestepping Integration für Maßdifferentialinklusionen.
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="TimeSteppingIntegratorType">
    <xs:complexContent>
      <xs:extension base="IntegratorType">
        <xs:sequence>
          <xs:element name="stepSize" type="pv:timeScalar" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Integrationsschrittweite.
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="toleranceForPositionConstraints" type="pv:unknownScalar" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Toleranz für Bindungsgleichungen auf Lageebene.
            </xs:documentation></xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="ThetaTimeSteppingIntegrator" substitutionGroup="Integrator" type="ThetaTimeSteppingIntegratorType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Halb-explizite Theta-Timestepping Integration für Maßdifferentialinklusionen.
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="ThetaTimeSteppingIntegratorType">
    <xs:complexContent>
      <xs:extension base="IntegratorType">
        <xs:sequence>
          <xs:element name="stepSize" type="pv:timeScalar" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Integrationsschrittweite.
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="theta" type="pv:nounitScalar" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Theta.
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="toleranceForPositionConstraints" type="pv:unknownScalar" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Toleranz für Bindungsgleichungen auf Lageebene.
            </xs:documentation></xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="TimeSteppingSSCIntegrator" substitutionGroup="Integrator" type="TimeSteppingSSCIntegratorType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
       Halb-explizite Timestepping Integration für Maßdifferentialinklusionen mit Schrittweitensteuerung und höherer Ordnung.
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="TimeSteppingSSCIntegratorType">
    <xs:complexContent>
      <xs:extension base="IntegratorType">
        <xs:sequence>
          <xs:element name="method" type="pv:stringFullEval" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Auswahl der Integrationsmethode.
              <ul>
                <li>extrapolation: Fehlerschätzung mittels Extrapolationsverfahren (default)</li>
                <li>embedded: Embedded Verfahren zur Fehlerschätzung: Fortsetzen der Integration mit niedrigerer Ordnung</li>
                <li>embeddedHigherOrder: Embedded Verfahren zur Fehlerschätzung: Fortsetzen der Integration mit höherer Ordnung</li>
              </ul>
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="stepSizeControl" type="pv:booleanFullEval" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Schrittweitenkontrolle verwenden (default true)
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:choice>
            <xs:element name="absoluteTolerance" type="pv:unknownVector" minOccurs="0">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                  Absoluter Fehlertoleranzvektor bezogen auf die Zustandsgrößen der Differentialgleichung.
              </xs:documentation></xs:annotation>
            </xs:element>
            <xs:element name="absoluteToleranceScalar" type="pv:unknownScalar" minOccurs="0">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                  Absolute Fehlertoleranz ist für alle Zustandsgrößen der Differentialgleichung gemäß dem angegebenen Wert.
              </xs:documentation></xs:annotation>
            </xs:element>
          </xs:choice>
          <xs:choice>
            <xs:element name="relativeTolerance" type="pv:nounitVector" minOccurs="0">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                  Relativer Fehlertoleranzvektor bezogen auf die Zustandsgrößen der Differentialgleichung.
              </xs:documentation></xs:annotation>
            </xs:element>
            <xs:element name="relativeToleranceScalar" type="pv:nounitScalar" minOccurs="0">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                  Relative Fehlertoleranz ist für alle Zustandsgrößen der Differentialgleichung gemäß dem angegebenen Wert.
              </xs:documentation></xs:annotation>
            </xs:element>
          </xs:choice>
          <xs:element name="initialStepSize" type="pv:timeScalar" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Anfangsschrittweite (default: 1e-6)
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="maximumStepSize" type="pv:timeScalar" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                maximale Zeitschrittweite (default: 1e-4)
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="minimumStepSize" type="pv:timeScalar" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                minimale Zeitschrittweite (default: sqrt(eps))
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="maximumOrder" type="pv:integerFullEval" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Auswahl der maximalen Integrationsordnung: default: 1; 1,2,3 bei Fehlerschätzung mittels Extrapolation; 1 bis 4 bei embedded Verfahren.
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="outputInterpolation" type="pv:booleanFullEval" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Flag zur Steuerung, ob für die Plotausgabe die vom Integrator angefahrenen Zeitpunkte verwendet werden oder ob auf die vorgegebenen Plotzeitpunkte interpoliert werden soll (default: false)
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="gapControl" type="pv:stringFullEval" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Definiert die gap control Strategie.
              <ul>
                <li>noGapControl: GapContol wird vollständig deaktiviert</li>
                <li>biggestRoot: Größte Nullstelle/Ereignis wird verwendet (maximaler Integrationsforschritt)</li>
                <li>scoring: Scoring Verfahren zur Auswahl der Nullstelle (Gewichtetes Mittel aus Eindringgeschwindigkeit und -zeit</li>
                <li>smallestRoot: Kleinste Nullstelle/Ereignis wird verwendet (am genauesten aber geringster Integrationsforschritt)</li>
                <li>gapTolerance: Zeitschrittweite werden so gewählt, dass Eindringtiefe gapTol nicht überschreitet</li>
              </ul>
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="gapTolerance" type="pv:nounitScalar" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Toleranz für Eindringtiefe; nur in Verbindung mit richtiger GapControl Methode
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="errorTest" type="pv:stringFullEval" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Wie werden Geschwindigkeiten bei der Fehlertestung behandelt.
              <ul>
                <li>all: Geschwindigkeiten und Lagen werden gleich behandelt</li>
                <li>scale: Geschwindigkeiten werden mit Zeitschrittweite skaliert</li>
                <li>exclude: Fehlertest wird nur mit Lagen durchgeführt</li>
              </ul>
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="maximumGain" type="pv:nounitScalar" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Maximale Vergrößerung der Zeitschrittweite zwischen zwei Schritten (default 2.2)
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="safetyFactor" type="pv:nounitScalar" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Sicherheitsfaktor bei der Berechnung der neuen Zeitschrittweite (default 0.7)
            </xs:documentation></xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="HETS2Integrator" substitutionGroup="Integrator" type="HETS2IntegratorType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
       Integrationsverfahren für nich-glatte dynamische Systeme. Das Verfahren basiert auf der halb-expliziten Trapez-Regel.
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="HETS2IntegratorType">
    <xs:complexContent>
      <xs:extension base="IntegratorType">
        <xs:sequence>
          <xs:element name="stepSize" type="pv:timeScalar" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Integrationsschrittweite.
            </xs:documentation></xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="ExplicitEulerIntegrator" substitutionGroup="Integrator" type="ExplicitEulerIntegratorType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Explizites Einschritt-Integrationsverfahren mit fester Schrittweite.
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="ExplicitEulerIntegratorType">
    <xs:complexContent>
      <xs:extension base="IntegratorType">
        <xs:sequence>
          <xs:element name="stepSize" type="pv:timeScalar" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Integrationsschrittweite.
            </xs:documentation></xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="ImplicitEulerIntegrator" substitutionGroup="Integrator" type="ImplicitEulerIntegratorType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Implizites Einschritt-Integrationsverfahren mit fester Schrittweite.
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="ImplicitEulerIntegratorType">
    <xs:complexContent>
      <xs:extension base="IntegratorType">
        <xs:sequence>
          <xs:element name="stepSize" type="pv:timeScalar" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Integrationsschrittweite.
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="reducedForm" type="pv:booleanFullEval" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Lösen des nichtlinearen Gleichungssystems in reduzierter Form. Das differentielle System muss dazu die spezielle Struktur dq(i)/dt = u(i) für i=1,...,nq haben.
            </xs:documentation></xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="RKSuiteIntegrator" substitutionGroup="RootFindingIntegrator" type="RKSuiteIntegratorType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Runge-Kutta Integrationsverfahren.
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="RKSuiteIntegratorType">
    <xs:complexContent>
      <xs:extension base="RootFindingIntegratorType">
        <xs:sequence>
          <xs:element name="method" type="pv:stringFullEval" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Auswahl der Integrationsmethode.
              <ul>
                <li>RK23: explizites Runge-Kutta-Verfahren der Ordnung 3</li>
                <li>RK45: explizites Runge-Kutta-Verfahren der Ordnung 5</li>
                <li>RK78: explizites Runge-Kutta-Verfahren der Ordnung 8</li>
              </ul>
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="relativeToleranceScalar" type="pv:nounitScalar" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Relative Fehlertoleranz ist für alle Zustandsgrößen der Differentialgleichung gemäß dem angegebenen Wert.
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:choice>
            <xs:element name="threshold" type="pv:nounitVector" minOccurs="0">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                  Grenwertvektor bezogen auf die Zustandsgrößen der Differentialgleichung.
              </xs:documentation></xs:annotation>
            </xs:element>
            <xs:element name="thresholdScalar" type="pv:nounitScalar" minOccurs="0">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                  Grenzwert für alle Zustandsgrößen der Differentialgleichung gemäß dem angegebenen Wert.
              </xs:documentation></xs:annotation>
            </xs:element>
          </xs:choice>
          <xs:element name="initialStepSize" type="pv:timeScalar" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Integrationsschrittweite. (t=0: automatische Detektion)
            </xs:documentation></xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="BoostOdeintDOS" abstract="true" substitutionGroup="RootFindingIntegrator" type="BoostOdeintDOSType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
       Integrators from Boost OdeInt.
       This class can use all Boost OdeInt dense output steppers.
       These integrators support all MBSim features:
       <ul>
         <li>root finding</li>
         <li>plot at equidistant step size</li>
         <li>drift projection</li>
         <li>step size control (depends on the stepper)</li>
         <li>co-simulation</li>
         <li>multiple instances possible</li>
       </ul>
       All these features operate with best performance without evaluating the system additional for plotting or root finding.
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="BoostOdeintDOSType">
    <xs:complexContent>
      <xs:extension base="RootFindingIntegratorType">
        <xs:sequence>
          <xs:element name="absoluteToleranceScalar" type="pv:unknownScalar" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Absolute Fehlertoleranz ist für alle Zustandsgrößen der Differentialgleichung gemäß dem angegebenen Wert.
                (Nur für Stepper mit step-size-control)
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="relativeToleranceScalar" type="pv:nounitScalar" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Relative Fehlertoleranz ist für alle Zustandsgrößen der Differentialgleichung gemäß dem angegebenen Wert.
                (Nur für Stepper mit step-size-control)
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="initialStepSize" type="pv:timeScalar" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Schrittweitenvorschlag zu Beginn der Integration.
                (Nicht schrittweitengesteuerte Stepper nutzen diese Schrittweite während der gesamten integration)
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="maximumStepSize" type="pv:timeScalar" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Maximal zu verwendende Schrittweite.
                (Nur für Stepper mit step-size-control)
            </xs:documentation></xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="BoostOdeintDOS_RKDOPRI5" substitutionGroup="BoostOdeintDOS" type="BoostOdeintDOS_RKDOPRI5Type">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
       Explicit, step-size-controlled Runge-Kutta Dormand-Prince 5 integrator from Boost Odeint.
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="BoostOdeintDOS_RKDOPRI5Type">
    <xs:complexContent>
      <xs:extension base="BoostOdeintDOSType"/>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="BoostOdeintDOS_BulirschStoer" substitutionGroup="BoostOdeintDOS" type="BoostOdeintDOS_BulirschStoerType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
       Explicit, step-size-controlled Bulirsch Stoer integrator from Boost Odeint.
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="BoostOdeintDOS_BulirschStoerType">
    <xs:complexContent>
      <xs:extension base="BoostOdeintDOSType"/>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="BoostOdeintDOS_Euler" substitutionGroup="BoostOdeintDOS" type="BoostOdeintDOS_EulerType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
       Explicit, fixed step-size Euler integrator from Boost Odeint.
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="BoostOdeintDOS_EulerType">
    <xs:complexContent>
      <xs:extension base="BoostOdeintDOSType"/>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="BoostOdeintDOS_Rosenbrock4" substitutionGroup="BoostOdeintDOS" type="BoostOdeintDOS_Rosenbrock4Type">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
       Implicit, step-size-controlled Rosenbrock 4 integrator from Boost Odeint.
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="BoostOdeintDOS_Rosenbrock4Type">
    <xs:complexContent>
      <xs:extension base="BoostOdeintDOSType"/>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="DASPKIntegrator" substitutionGroup="RootFindingIntegrator" type="DASPKIntegratorType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Löser für differential algebraische Gleichungen, basierend auf dem Backward Differentiation Formula (BDF) Verfahren.
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="DASPKIntegratorType">
    <xs:complexContent>
      <xs:extension base="RootFindingIntegratorType">
        <xs:sequence>
          <xs:choice>
            <xs:element name="absoluteTolerance" type="pv:unknownVector" minOccurs="0">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                  Absoluter Fehlertoleranzvektor bezogen auf die Zustandsgrößen der Differentialgleichung.
              </xs:documentation></xs:annotation>
            </xs:element>
            <xs:element name="absoluteToleranceScalar" type="pv:unknownScalar" minOccurs="0">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                  Absolute Fehlertoleranz ist für alle Zustandsgrößen der Differentialgleichung gemäß dem angegebenen Wert.
              </xs:documentation></xs:annotation>
            </xs:element>
          </xs:choice>
          <xs:choice>
            <xs:element name="relativeTolerance" type="pv:unknownVector" minOccurs="0">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                  Relative Fehlertoleranzvektor bezogen auf die Zustandsgrößen der Differentialgleichung.
              </xs:documentation></xs:annotation>
            </xs:element>
            <xs:element name="relativeToleranceScalar" type="pv:nounitScalar" minOccurs="0">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                  Relative Fehlertoleranz ist für alle Zustandsgrößen der Differentialgleichung gemäß dem angegebenen Wert.
              </xs:documentation></xs:annotation>
            </xs:element>
          </xs:choice>
          <xs:element name="initialStepSize" type="pv:timeScalar" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Schrittweitenvorschlag zu Beginn der Integration.
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="maximumStepSize" type="pv:timeScalar" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Maximal zu verwendende Schrittweite.
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="formalism" type="pv:stringFullEval" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Auswahl des Formalismus.
              <ul>
                <li>ODE: gewöhnliches Differentialgleichungssystem</li>
                <li>DAE1: differential-algebraisches System vom Index 1</li>
                <li>DAE2: differential-algebraisches System vom Index 2</li>
                <li>GGL: differential-algebraisches System vom Index 2 mit Gear Gupta Leimkuhler Stabilisierung</li>
              </ul>
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="excludeAlgebraicVariablesFromErrorTest" type="pv:booleanFullEval" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
               Algebraische Variablen vom Fehlertest ausschließen.
            </xs:documentation></xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

</xs:schema>
