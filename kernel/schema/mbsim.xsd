<?xml version="1.0" encoding="UTF-8"?>
<xs:schema targetNamespace="http://www.mbsim-env.de/MBSim"
  elementFormDefault="qualified"
  attributeFormDefault="unqualified"
  xmlns="http://www.mbsim-env.de/MBSim"
  xmlns:mbsim="http://www.mbsim-env.de/MBSim"
  xmlns:pv="http://www.mbsim-env.de/MBXMLUtils"
  xmlns:ombv="http://www.mbsim-env.de/OpenMBV"
  xmlns:xml="http://www.w3.org/XML/1998/namespace"
  xmlns:xs="http://www.w3.org/2001/XMLSchema">

  <xs:annotation>
    <xs:documentation xml:lang="de" xmlns="">
      MBSim ist ein Simulationstool zur Analyse von dynamischen Systemen. Sein Ursprung liegt 
      in der Modellierung von nichtglatten Mehrkörpersystemen, woraus sich auch der Name "MBSim" ableitet.
      Der mathematische Hintergrund wurde in den letzten Jahrzehnten am Lehrstuhl für Angewandte Mechanik der
      Technischen Universität München entwickelt. Eine gute Zusammenfassung ist die Doktorarbeit und das Vorlesungsskript von Martin Förg [1,2]. Roland Zander
      diskutiert Erweiterungen hinsichtlich flexibler Körper [3]. In [4] erhält man einen Überblick über die Forschung am
      Lehrstuhl für Angewandte Mechanik auf dem Gebiet der
      nichtglatten Mechanik. Dort sind auch Simulationsergebnisse von akademischen und
      industriellen Beispielen zu finden. Erweiterungen bezüglich Hydraulik und Regelungstechnik sowie
      Parallelisierung und Co-Simulation sind einzigartig im Bereich der nichtglatten Dynamik.
      <ol>
        <li>Martin Förg. <i>Mehrkörpersysteme mit mengenwertigen Kraftgesetzen - Theorie und Numerik.</i>
          PhD thesis, TU München, 2007.</li>
        <li>Martin Förg. <i>Mehrkörpersimulation - Vorlesungsskript</i>, München, 2006, Version 19.06.2008.</li>
        <li>Roland Zander. <i>Flexible Multibody Systems with Set-Valued Force Laws.</i> PhD thesis,
          TU München, 2008.</li>
        <li>Roland Zander, Thorsten Schindler, Markus Friedrich, Robert Huber, Martin Förg, and Heinz
          Ulbrich. <i>Non-smooth dynamics in academia and industry: recent work at TU München.</i>
          Acta Mechanica, 195:167–183, 2008.</li>
      </ol>
    </xs:documentation>
  </xs:annotation>

  <xs:import namespace="http://www.mbsim-env.de/MBXMLUtils"/>

  <xs:import namespace="http://www.mbsim-env.de/OpenMBV"/>

  <xs:group name="OpenMBVFrameParameters">
    <xs:sequence>
      <xs:element name="size" type="pv:lengthScalar" minOccurs="0">
        <xs:annotation>
          <xs:documentation xml:lang="de" xmlns="">
            Länge der Achsen des KOS.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="offset" type="pv:nounitScalar" minOccurs="0">
        <xs:annotation>
          <xs:documentation xml:lang="de" xmlns="">
            Relative Verschiebung der Achsen (0=Achsenkreuz, 1=Rechtssystem).
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="transparency" type="pv:nounitScalar" minOccurs="0"/> 
    </xs:sequence>
  </xs:group>

  <xs:group name="OpenMBVArrowParameters">
    <xs:sequence>
      <xs:element name="scaleLength" type="pv:nounitScalar" minOccurs="0"/>
      <xs:element name="scaleSize" type="pv:nounitScalar" minOccurs="0"/>
      <xs:element name="referencePoint" minOccurs="0" type="pv:stringFullEval"/>
      <xs:element name="diffuseColor" type="pv:nounitVector" minOccurs="0"/>
      <xs:element name="transparency" type="pv:nounitScalar" minOccurs="0"/> 
    </xs:sequence>
  </xs:group>

  <xs:group name="OpenMBVCoilSpringParameters">
    <xs:sequence>
      <xs:element name="numberOfCoils" type="pv:nounitScalar" minOccurs="0"/>
      <xs:element name="springRadius" type="pv:lengthScalar" minOccurs="0"/>
      <xs:element name="crossSectionRadius" type="pv:lengthScalar" minOccurs="0"/>
      <xs:element name="nominalLength" type="pv:lengthScalar" minOccurs="0"/>
      <xs:element name="type" minOccurs="0" type="pv:stringFullEval"/>
      <xs:element name="diffuseColor" type="pv:nounitVector" minOccurs="0"/>
      <xs:element name="transparency" type="pv:nounitScalar" minOccurs="0"/> 
      <xs:element name="minimalColorValue" type="pv:nounitScalar" minOccurs="0"/>
      <xs:element name="maximalColorValue" type="pv:nounitScalar" minOccurs="0"/>
    </xs:sequence>
  </xs:group>

  <xs:simpleType name="PlotFeatureType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Bestimmt, welche Plotausgaben aktiviert bzw. deaktiviert werden. Die folgenden Werte sind
        jeweils mit einem vorangestellten '<b>+</b>' oder '<b>-</b>' zulässig. Ein '<b>+</b>' aktiviert das entsprechende
        Plotfeature, ein '<b>-</b>' deaktiviert es (Der default Wert ist in eckigen Klammern angegeben):
        <dl>
          <dt>plotRecursive</dt>       <dd>Aktiviert/Deaktiviert das Plotten unterhalb dieser hiearchy Gruppe [+]</dd>
          <dt>separateFilePerGroup</dt><dd>Erzeugt ein eigenes H5 File für diese Gruppe [-]</dd>
          <dt>state</dt>               <dd>Zustandsvektor plotten (x, q, u) [+]</dd>
          <dt>stateDerivative</dt>     <dd>Ableitung des Zustandsvektors plotten (xd, qd, ud) [-]</dd>
          <dt>notMinimalState</dt>     <dd>TODO</dd>
          <dt>rightHandSide</dt>       <dd>Glatte und nicht glatte rechte Seite plotten (h, r=W*l) [-]</dd>
          <dt>globalPosition</dt>      <dd>Globale (world) Positionen und Orientierungen plotten [-]</dd>
          <dt>globalVelocity</dt>      <dd>Globale (world) Geschwindigkeiten plotten [-]</dd>
          <dt>globalAcceleration</dt>  <dd>Globale (world) Beschleunigen plotten [-]</dd>
          <dt>energy</dt>              <dd>Energie plotten [-]</dd>
          <dt>openMBV</dt>             <dd>OpenMBV Visualisierung ausgeben [+]</dd>
          <dt>generalizedLinkForce</dt><dd>Glatte und nicht glatte generalisierte Link Kräfte plotten (l) [+]</dd>
          <dt>linkKinematics</dt>      <dd>Kinematic der Links plotten (g, gd) [+]</dd>
          <dt>stopVector</dt>          <dd>Stopvektor der Schaltpunktsuche ausgeben [-]</dd>
          <dt>debug</dt>               <dd>interne Größen ausgeben [-]</dd>
        </dl>
    </xs:documentation></xs:annotation>
    <xs:restriction base="pv:stringPartialEval"/>
  </xs:simpleType>

  <!-- A reference to a Frame at the same hierarchy -->
  <xs:simpleType name="CurrentFrameReferenceType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Definiert eine Pfadangabe zu einem <a class="link" href="mbsim:Frame"><span class="_element">&lt;Frame&gt;</span></a> im aktuellen Kontext.
        Gültige Werte sind <code>Frame[X]</code>, wobei <code>X</code> den <a class="link" href="pv:stringPartialEval">Element-Namen</a> des
        zu referenzierenden Frames darstellt.
    </xs:documentation></xs:annotation>
    <xs:restriction base="pv:stringPartialEval"/>
  </xs:simpleType>

  <!-- A reference to a Frame at the parent -->
  <xs:simpleType name="ParentFrameReferenceType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Definiert eine Pfadangabe zu einem <a class="link" href="mbsim:Frame"><span class="_element">&lt;Frame&gt;</span></a> des Vorgängers
        des aktuellen Kontext (Vorgänger in der Hierarchieebene). Gültige Werte sind <code>../Frame[X]</code>, wobei <code>X</code> den
        <a class="link" href="pv:stringPartialEval">Element-Namen</a> des Frames des Vorgangers darstellt.
        <p>Die Hierarchieebenen entsprechend prinzipiell den Ebenen von XML. Als neue Hierarchieebenen zählen jedoch NUR
          Elemente die mit einem Großbuchstaben beginnen.</p>
    </xs:documentation></xs:annotation>
    <xs:restriction base="pv:stringPartialEval"/>
  </xs:simpleType>

  <!-- A reference from a Link|Object to a Frame somewhere in the hierarchy -->
  <xs:simpleType name="FrameReferenceType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Definiert eine Pfadangabe zu einem <a class="link" href="mbsim:Frame"><span class="_element">&lt;Frame&gt;</span></a> an beliebiger
        Position im Modell. Gültige Werte sind z.B. <code>../../Group[X]/Group[X]/Object[Y]/Frame[Z]</code>, wobei <code>X</code>,
        <code>Y</code> und <code>Z</code> geweils einen <a class="link" href="pv:stringPartialEval">Element-Namen</a> darstellt. Der Pfadteil
        <code>..</code> kann dabei beliebig oft auftreten und wechselt eine Hierarchieebene nach oben. Der Pfadteil
        <code>Group</code> kann beliebig oft oder nicht auftreten und wechselt eine Hierarchieebene tiefer in die
        <code>Group</code> mit dem Element-Namen <code>X</code>. Als letzter Pfadteil kann der <code>Frame Z</code> des
        <code>Object's Y</code> ausgewählt werden oder der <code>Frame Z</code> der <code>Group</code> wenn die Angabe von
        <code>Object</code> weggelassen wird. Alternativ kann die Pfadangabe anstatt mit <code>..</code> mit <code>/</code> beginnen,
        in diesem Fall beginnt die Referenzierung beim obersten Element
        (<a class="link" href="mbsim:DynamicSystemSolver"><code>DynamicSystemSolver</code></a>) des Modells.
        <p>Die Hierarchieebenen entsprechend prinzipiell den Ebenen von XML. Als neue Hierarchieebenen zählen jedoch NUR
          Elemente die mit einem Großbuchstaben beginnen.</p>
    </xs:documentation></xs:annotation>
    <xs:restriction base="pv:stringPartialEval"/>
  </xs:simpleType>

  <!-- A reference form a Link|Object to a Contour somewhere in the hierarchy -->
  <xs:simpleType name="ContourReferenceType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Definiert eine Pfadangabe zu einer <a class="link" href="mbsim:Contour"><span class="_element">&lt;Contour&gt;</span></a> an beliebiger
        Position im Modell. Gültige Werte sind z.B. <code>../../Group[X]/Group[X]/Object[Y]/Contour[Z]</code>, wobei <code>X</code>,
        <code>Y</code> und <code>Z</code> geweils einen <a class="link" href="pv:stringPartialEval">Element-Namen</a> darstellt. Der Pfadteil
        <code>..</code> kann dabei beliebig oft auftreten und wechselt eine Hierarchieebene nach oben. Der Pfadteil
        <code>Group</code> kann beliebig oft oder nicht auftreten und wechselt eine Hierarchieebene tiefer in die
        <code>Group</code> mit dem Element-Namen <code>X</code>. Als letzter Pfadteil kann die <code>Contour Z</code> des
        <code>Object's Y</code> ausgewählt werden oder die <code>Contour Z</code> der <code>Group</code> wenn die Angabe von
        <code>Object</code> weggelassen wird. Alternativ kann die Pfadangabe anstatt mit <code>..</code> mit <code>/</code> beginnen,
        in diesem Fall beginnt die Referenzierung beim obersten Element
        (<a class="link" href="mbsim:DynamicSystemSolver"><code>DynamicSystemSolver</code></a>) des Modells.
        <p>Die Hierarchieebenen entsprechend prinzipiell den Ebenen von XML. Als neue Hierarchieebenen zählen jedoch NUR
          Elemente die mit einem Großbuchstaben beginnen.</p>
    </xs:documentation></xs:annotation>
    <xs:restriction base="pv:stringPartialEval"/>
  </xs:simpleType>

  <!-- A reference form a Link to a Object somewhere in the hierarchy -->
  <xs:simpleType name="ObjectReferenceType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Definiert eine Pfadangabe zu einem <a class="link" href="mbsim:Object"><span class="_element">&lt;Object&gt;</span></a> an beliebiger
        Position im Modell. Gültige Werte sind z.B. <code>../../Group[X]/Group[X]/Object[Y]</code>, wobei <code>X</code> und
        <code>Y</code> geweils einen <a class="link" href="pv:stringPartialEval">Element-Namen</a> darstellt. Der Pfadteil <code>..</code>
        kann dabei beliebig oft auftreten und wechselt eine Hierarchieebene nach oben. Der Pfadteil <code>Group</code>
        kann beliebig oft oder nicht auftreten und wechselt eine Hierarchieebene tiefer in die <code>Group</code> mit dem
        Element-Namen <code>X</code>. Als letzter Pfadteil wird das <code>Object Y</code> ausgewählt. Alternativ kann die
        Pfadangabe anstatt mit <code>..</code> mit <code>/</code> beginnen, in diesem Fall beginnt die Referenzierung beim
        obersten Element (<a class="link" href="mbsim:DynamicSystemSolver"><code>DynamicSystemSolver</code></a>) des Modells.
        <p>Die Hierarchieebenen entsprechend prinzipiell den Ebenen von XML. Als neue Hierarchieebenen zählen jedoch NUR
          Elemente die mit einem Großbuchstaben beginnen.</p>
    </xs:documentation></xs:annotation>
    <xs:restriction base="pv:stringPartialEval"/>
  </xs:simpleType>

  <!-- A reference form a Link to a Link somewhere in the hierarchy -->
  <xs:simpleType name="LinkReferenceType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Definiert eine Pfadangabe zu einem <a class="link" href="mbsim:Link"><span class="_element">&lt;Link&gt;</span></a> an beliebiger
        Position im Modell. Gültige Werte sind z.B. <code>../../Group[X]/Group[X]/Link[Y]</code>, wobei <code>X</code> und
        <code>Y</code> geweils einen <a class="link" href="pv:stringPartialEval">Element-Namen</a> darstellt. Der Pfadteil <code>..</code>
        kann dabei beliebig oft auftreten und wechselt eine Hierarchieebene nach oben. Der Pfadteil <code>Group</code>
        kann beliebig oft oder nicht auftreten und wechselt eine Hierarchieebene tiefer in die <code>Group</code> mit dem
        Element-Namen <code>X</code>. Als letzter Pfadteil wird das <code>Link Y</code> ausgewählt. Alternativ kann die
        Pfadangabe anstatt mit <code>..</code> mit <code>/</code> beginnen, in diesem Fall beginnt die Referenzierung beim
        obersten Element (<a class="link" href="mbsim:DynamicSystemSolver"><code>DynamicSystemSolver</code></a>) des Modells.
        <p>Die Hierarchieebenen entsprechend prinzipiell den Ebenen von XML. Als neue Hierarchieebenen zählen jedoch NUR
          Elemente die mit einem Großbuchstaben beginnen.</p>
    </xs:documentation></xs:annotation>
    <xs:restriction base="pv:stringPartialEval"/>
  </xs:simpleType>

  <!-- A reference form a Link to a Contact somewhere in the hierarchy -->
  <xs:simpleType name="ContactReferenceType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Definiert eine Pfadangabe zu einem <a class="link" href="mbsim:Contact"><span class="_element">&lt;Contact&gt;</span></a> an beliebiger
        Position im Modell. Gültige Werte sind z.B. <code>../../Group[X]/Group[X]/Contact[Y]</code>, wobei <code>X</code> und
        <code>Y</code> geweils einen <a class="link" href="pv:stringPartialEval">Element-Namen</a> darstellt. Der Pfadteil <code>..</code>
        kann dabei beliebig oft auftreten und wechselt eine Hierarchieebene nach oben. Der Pfadteil <code>Group</code> kann
        beliebig oft oder nicht auftreten und wechselt eine Hierarchieebene tiefer in die <code>Group</code> mit dem
        Element-Namen <code>X</code>. Als letzter Pfadteil wird der <code>Contact Y</code> ausgewählt. Alternativ kann die
        Pfadangabe anstatt mit <code>..</code> mit <code>/</code> beginnen, in diesem Fall beginnt die Referenzierung beim
        obersten Element (<a class="link" href="mbsim:DynamicSystemSolver"><code>DynamicSystemSolver</code></a>) des Modells.
        <p>Die Hierarchieebenen entsprechend prinzipiell den Ebenen von XML. Als neue Hierarchieebenen zählen jedoch NUR
          Elemente die mit einem Großbuchstaben beginnen.</p>
    </xs:documentation></xs:annotation>
    <xs:restriction base="pv:stringPartialEval"/>
  </xs:simpleType>

  <xs:element name="Element" abstract="true" type="ElementType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        <p>Abstraktes (Top-Level) Basis Element von MBSim.</p>
        <p>Das Attribut <code>name</code> gibt den Namen des Elements an. Dieser Name wird für die Referenzierung des
          Elements benötig. Die Plotausgaben verwenden ebenfalls diese Namen.</p>
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="ElementType">
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:element name="plotFeature">  
        <xs:annotation><xs:documentation xml:lang="de" xmlns="">
            Definiert die Plotfeatures für dieses Element.
        </xs:documentation></xs:annotation>
        <xs:complexType>
          <xs:attribute name="feature" type="PlotFeatureType" use="required"/>
        </xs:complexType> 
      </xs:element>  
      <xs:element name="plotFeatureForChildren">
        <xs:annotation><xs:documentation xml:lang="de" xmlns="">
            Definiert die Plotfeatures für alle Kindelement.
        </xs:documentation></xs:annotation>
        <xs:complexType>
          <xs:attribute name="feature" type="PlotFeatureType" use="required"/>
        </xs:complexType> 
      </xs:element>  
      <xs:element name="plotFeatureRecursive">  
        <xs:annotation><xs:documentation xml:lang="de" xmlns="">
            Definiert die Plotfeatures für diese Element und alle Kindelement.
        </xs:documentation></xs:annotation>
        <xs:complexType>
          <xs:attribute name="feature" type="PlotFeatureType" use="required"/>
        </xs:complexType> 
      </xs:element>  
    </xs:choice> 
    <xs:attribute name="name" type="pv:stringPartialEval"/> <!-- is not required here since Function has not name attribute -->
  </xs:complexType> 

  <xs:element name="EmptyGroup" abstract="true" substitutionGroup="Element" type="EmptyGroupType"/>
  <xs:complexType name="EmptyGroupType">
    <xs:complexContent>
      <xs:extension base="ElementType"/>
    </xs:complexContent>
  </xs:complexType>   

  <!-- For usage in Group an RigidBody -->
  <xs:element name="frame" type="frameType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Lokale Gruppe eines Koordinatensystems.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="frameType"> <!-- use global type for parsing by the documentation generator -->
    <xs:sequence>
      <xs:element ref="Frame"/>
      <xs:element name="frameOfReference" minOccurs="0">
        <xs:annotation>
          <xs:documentation xml:lang="de" xmlns="">
            Koordinatensystem, in dem die Positionierung des KOS angegeben wird.<br/>
            Standardmässig "I"-System der Gruppe bzw. "C"-System des RigidBody.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="ref" type="CurrentFrameReferenceType" use="required"/>
        </xs:complexType>
      </xs:element>
      <xs:element name="position" type="pv:lengthVector">
        <xs:annotation>
          <xs:documentation xml:lang="de" xmlns="">
            Relative Lage des Koordinatensystems.<br/>
            Vektor von <code>frameOfReference</code> zum Ursprung des neuen KOS dargestellt
            im KOS <code>frameOfReference</code>.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="orientation" type="pv:rotationMatrix">
        <xs:annotation>
          <xs:documentation xml:lang="de" xmlns="">
            Relative Orientierung des Koordinatensystems.<br/>
            Transformationsmatrix vom neuen KOS ins KOS <code>frameOfReference</code>.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:sequence>
  </xs:complexType>

  <!-- For usage in Group an RigidBody -->
  <xs:element name="contour" type="contourType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Lokale Gruppe einer Kontaktkontur.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="contourType"> <!-- use global type for parsing by the documentation generator -->
    <xs:sequence>
      <xs:element ref="Contour"/>
      <xs:element name="frameOfReference" minOccurs="0">
        <xs:annotation>
          <xs:documentation xml:lang="de" xmlns="">
            Koordinatensystem, in dem die relative Positionierung der Kontur angegeben wird.<br/> 
            Standardmässig "I"-System der Gruppe bzw. "C"-System des RigidBody.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="ref" type="CurrentFrameReferenceType" use="required"/>
        </xs:complexType>
      </xs:element>
      <xs:element name="position" type="pv:lengthVector">
        <xs:annotation>
          <xs:documentation xml:lang="de" xmlns="">
            Relative Lage der Kontur.<br/>
            Vektor von <code>frameOfReference</code> zum Ursprung des kontureigenen KOS dargestellt
            im KOS <code>frameOfReference</code>.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="orientation" type="pv:rotationMatrix">
        <xs:annotation>
          <xs:documentation xml:lang="de" xmlns="">
            Relative Orientierung der Kontur.<br/>
            Transformationsmatrix vom kontureigenen KOS ins KOS <code>frameOfReference</code>.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:sequence>
  </xs:complexType>

  <xs:element name="Group" substitutionGroup="EmptyGroup" type="GroupType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Definiert eine neue Hierarchieebene in Form einer Gruppe.<br/>
        Eine Gruppe stellt dabei einen
        Kontainer für andere <code>Group</code>'s, <code>Object</code>'s (Körper) und <code>Link</code>'s
        (Verbindungselemente) bereit. Mithilfe von Gruppen können somit hierarchische Modelle erzeugt werden.
        <p>Jede Gruppe definiert automatisch ein statisches KOS mit den Namen "I".</p>
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="GroupType">
    <xs:complexContent>
      <xs:extension base="EmptyGroupType">
        <xs:sequence>
          <xs:element name="frameOfReference" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Koordinatensystem, in dem die Positionierung der Gruppe angegeben wird. Standardmäßig wird das "I"-System des übergeordneten Systems verwendet.
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:attribute name="ref" type="ParentFrameReferenceType" use="required"/>
            </xs:complexType>
          </xs:element>
          <xs:element name="position" type="pv:lengthVector" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Relative Lage der Gruppe. Vektor vom <code>frameOfReference</code> zum KOS "I" dieser Gruppe.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="orientation" type="pv:rotationMatrix" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Relative Orientierung der Gruppe. Transformationsmatrix vom KOS "I" dieser Gruppe in das KOS <code>frameOfReference</code>.
              </xs:documentation>
            </xs:annotation>
          </xs:element>           
          <xs:element name="frames">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Kontainer für ortsfeste (statische) Koordinatensysteme dieser Gruppe.
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:sequence>
                <xs:choice minOccurs="0" maxOccurs="unbounded">
                  <xs:element ref="FixedRelativeFrame"/>
                  <xs:element ref="pv:Embed"/>
                </xs:choice>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="contours">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Kontainer für ortsfeste (statische) Kontaktkonturen dieser Gruppe.
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:sequence>
                <xs:choice minOccurs="0" maxOccurs="unbounded">
                  <xs:element ref="Contour"/>
                  <xs:element ref="pv:Embed"/>
                </xs:choice>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="groups">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Kontainer für Untergruppen dieser Gruppe.
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:choice minOccurs="0" maxOccurs="unbounded">
                <xs:element ref="EmptyGroup">
                  <xs:annotation>
                    <xs:documentation xml:lang="de" xmlns="">
                      Lokale Definition.
                    </xs:documentation>
                  </xs:annotation>
                </xs:element>
                <xs:element ref="pv:Embed">
                  <xs:annotation>
                    <xs:documentation xml:lang="de" xmlns="">
                      Definition in externer Datei.
                    </xs:documentation>
                  </xs:annotation>
                </xs:element>
              </xs:choice>
            </xs:complexType>
          </xs:element>
          <xs:element name="objects">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Kontainer für <code>Object</code>'s (Körper, hydraulische Leitungen, ...).
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:choice minOccurs="0" maxOccurs="unbounded">
                <xs:element ref="Object">
                  <xs:annotation>
                    <xs:documentation xml:lang="de" xmlns="">
                      Lokale Definition.
                    </xs:documentation>
                  </xs:annotation>
                </xs:element>
                <xs:element ref="pv:Embed">
                  <xs:annotation>
                    <xs:documentation xml:lang="de" xmlns="">
                      Definition in externer Datei.
                    </xs:documentation>
                  </xs:annotation>
                </xs:element>
              </xs:choice>
            </xs:complexType>
          </xs:element>
          <xs:element name="links">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Kontainer für <code>Link</code>'s (Verbindungen, Kontakte, hydraulische Knoten, ...).
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:choice minOccurs="0" maxOccurs="unbounded">
                <xs:element ref="Link">
                  <xs:annotation>
                    <xs:documentation xml:lang="de" xmlns="">
                      Lokale Definition.
                    </xs:documentation>
                  </xs:annotation>
                </xs:element>
                <xs:element ref="pv:Embed">
                  <xs:annotation>
                    <xs:documentation xml:lang="de" xmlns="">
                      Definition in externer Datei.
                    </xs:documentation>
                  </xs:annotation>
                </xs:element>
              </xs:choice>
            </xs:complexType>
          </xs:element>
          <xs:element name="constraints" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Kontainer für <code>Constraint</code>'s (Zwangsbedingungen).
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:choice minOccurs="0" maxOccurs="unbounded">
                <xs:element ref="Constraint">
                  <xs:annotation>
                    <xs:documentation xml:lang="de" xmlns="">
                      Lokale Definition.
                    </xs:documentation>
                  </xs:annotation>
                </xs:element>
                <xs:element ref="pv:Embed">
                  <xs:annotation>
                    <xs:documentation xml:lang="de" xmlns="">
                      Definition in externer Datei.
                    </xs:documentation>
                  </xs:annotation>
                </xs:element>
              </xs:choice>
            </xs:complexType>
          </xs:element>
          <xs:element name="observers" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Kontainer für <code>Observer</code>'s (Beobachter für kinematische und kinetische Größen).
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:choice minOccurs="0" maxOccurs="unbounded">
                <xs:element ref="Observer">
                  <xs:annotation>
                    <xs:documentation xml:lang="de" xmlns="">
                      Lokale Definition.
                    </xs:documentation>
                  </xs:annotation>
                </xs:element>
                <xs:element ref="pv:Embed">
                  <xs:annotation>
                    <xs:documentation xml:lang="de" xmlns="">
                      Definition in externer Datei.
                    </xs:documentation>
                  </xs:annotation>
                </xs:element>
              </xs:choice>
            </xs:complexType>
          </xs:element>
          <xs:element name="enableOpenMBVFrameI" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Aktiviert die Visualisierung des Koordinatensystems "I" dieser Gruppe in OpenMBV.
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:group ref="OpenMBVFrameParameters"/>
            </xs:complexType> 
          </xs:element>
          <xs:element name="plotFeatureFrameI" minOccurs="0" maxOccurs="unbounded">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Definiert die Plotfeatures des Koordinatensystems "I" dieser Gruppe.
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:attribute name="feature" type="PlotFeatureType" use="required"/>
            </xs:complexType>
          </xs:element>
        </xs:sequence> 
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="Environment" abstract="true" type="EnvironmentType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Abstrakte Oberklasse für die Definition von Umgebungsgrößen verschiedener physikalischer Domains, z.b. die Erdbeschleunigung in der Mechanik.
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="EnvironmentType"/>

  <xs:element name="MBSimEnvironment" substitutionGroup="Environment" type="MBSimEnvironmentType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Definiert mechanische Umgebungsgrößen.
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="MBSimEnvironmentType">
    <xs:complexContent>
      <xs:extension base="EnvironmentType">
        <xs:sequence>
          <xs:element name="accelerationOfGravity" type="pv:accelerationVector">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Vektor der Erdbeschleunigung angegeben im KOS "I" von <a class="link" href="mbsim:DynamicSystemSolver"><span class="_element">&lt;DynamicSystemSolver&gt;</span></a>.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence> 
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="DynamicSystemSolver" substitutionGroup="Group" type="DynamicSystemSolverType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        DynamicSystemSolver ist das oberste Herarchie-Element eines Modells, ein Integrierbares Gesamtsystem.<br/>
        Da DynamicSystemSolver von Group abgeleitet ist, besitzt es Gruppenstruktur und kann mit anderen Gruppen, Objekten und Link's gefüllt werden. Darüberhinaus werden
        innerhalb von DynamicSystemSolver die Umgebungsgrößen der einzelnen verwendeten Domains definiert.
        <p>Da das oberste XML Element auch stets den <i>Namespace</i> der folgenden Elemente definieren muss,
          sind die ersten Zeilen eines Modells zumeist durch</p>
        <code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;</code><br/>
        <span class="_element">&lt;DynamicSystemSolver name="MBS" xmlns="http://www.mbsim-env.de/MBSim"</span><br/>
        <code>  xmlns:ombv="http://www.mbsim-env.de/OpenMBV"</code><br/>
        <code>  xmlns:pv="http://www.mbsim-env.de/MBXMLUtils"&gt;</code><br/>
        <code>  ...</code><br/>
        <p>gegeben</p>
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="DynamicSystemSolverType">
    <xs:complexContent>
      <xs:extension base="GroupType">
        <xs:sequence>
          <xs:element name="environments">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Kontainer für Umgebungsvariablen des physikalen Systems.
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:sequence>
                <xs:element ref="Environment" minOccurs="0" maxOccurs="unbounded"/>
              </xs:sequence> 
            </xs:complexType>
          </xs:element>
          <xs:element name="solverParameters" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Einstellung des Lösungsalgorithmus für die nichtlinearen Nebenbedingungsgleichungen.
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:sequence>
                <xs:element name="constraintSolver" minOccurs="0" type="pv:stringFullEval">
                  <xs:annotation>
                    <xs:documentation xml:lang="de" xmlns="">
                      <p>Nebenbedingungsgleichungen auf Beschleunigungsebene.</p>
                      <dl>
                        <dt>"FixedPointSingle"</dt> <dd>Gauss-Seidel-Verfahren mit Fixpunktsuche und Relaxationsstrategie (Anwendungsfall: Räumliche Coulombreibung; Eigenschaften: mäßige Konvergenz).</dd>
                        <dt>"GaussSeidel"</dt> <dd>Gauss-Seidel-Verfahren (Anwendungsfall: Ebene Coulombreibung; Eigenschaften: mäßige Konvergenz).</dd>
                        <dt>"LinearEquations"</dt> <dd>Cholesky-Zerlegung für reguläre Gleichungssysteme (Anwendungsfall: nur zweiseitige Bindungen; Eigenschaften: exakte Lösung in einem Schritt).</dd>
                        <dt>"RootFinding"</dt> <dd>Gedämpftes und globalisiertes Newton-Verfahren (Anwendungsfall: Räumliche Coulombreibung; Eigenschaften: sehr robust).</dd>
                      </dl>
                    </xs:documentation>
                  </xs:annotation>
                </xs:element>
                <xs:element name="impactSolver" minOccurs="0" type="pv:stringFullEval">
                  <xs:annotation>
                    <xs:documentation xml:lang="de" xmlns="">
                      <p>Nebenbedingungsgleichungen auf Geschwindigkeitssebene.</p>
                      <dl>
                        <dt>"FixedPointSingle"</dt> <dd>Gauss-Seidel-Verfahren mit Fixpunktsuche und Relaxationsstrategie (Anwendungsfall: Räumliche Coulombreibung; Eigenschaften: mäßige Konvergenz).</dd>
                        <dt>"GaussSeidel"</dt> <dd>Gauss-Seidel-Verfahren (Anwendungsfall: Ebene Coulombreibung; Eigenschaften: mäßige Konvergenz).</dd>
                        <dt>"LinearEquations"</dt> <dd>Cholesky-Zerlegung für reguläre Gleichungssysteme (Anwendungsfall: nur zweiseitige Bindungen; Eigenschaften: exakte Lösung in einem Schritt).</dd>
                        <dt>"RootFinding"</dt> <dd>Gedämpftes und globalisiertes Newton-Verfahren (Anwendungsfall: Räumliche Coulombreibung; Eigenschaften: sehr robust).</dd>
                      </dl>
                    </xs:documentation>
                  </xs:annotation>
                </xs:element>
                <xs:element name="numberOfMaximalIterations" type="pv:integerFullEval" minOccurs="0">
                  <xs:annotation>
                    <xs:documentation xml:lang="de" xmlns="">
                      Maximale Iterationszahl der Löser bis zum Abruch.
                    </xs:documentation>
                  </xs:annotation>
                </xs:element>
                <xs:element name="tolerances" minOccurs="0">
                  <xs:annotation>
                    <xs:documentation xml:lang="de" xmlns="">
                      allgemeine Toleranzangaben.
                    </xs:documentation>
                  </xs:annotation>
                  <xs:complexType>
                    <xs:sequence>
                      <xs:element name="projection" type="pv:nounitScalar" minOccurs="0">
                      </xs:element>
                      <xs:element name="g" type="pv:nounitScalar" minOccurs="0">
                      </xs:element>
                      <xs:element name="gd" type="pv:nounitScalar" minOccurs="0">
                      </xs:element>
                      <xs:element name="gdd" type="pv:nounitScalar" minOccurs="0">
                      </xs:element>
                      <xs:element name="la" type="pv:nounitScalar" minOccurs="0">
                      </xs:element>
                      <xs:element name="La" type="pv:nounitScalar" minOccurs="0">
                      </xs:element>
                    </xs:sequence>
                  </xs:complexType>
                </xs:element> 
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="inverseKinetics" minOccurs="0" type="pv:booleanFullEval">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Definiert, ob Gelenkreaktionen berechnet werden sollen.
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="initialProjection" minOccurs="0" type="pv:booleanFullEval">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Definiert, ob vor Beginn der Simulation eine Projektion der generalisierten Lagen und Geschwindigkeiten erfolgen soll.
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="useConstraintSolverForPlot" minOccurs="0" type="pv:booleanFullEval">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Definiert, ob die mengenwertigen Kraftgesetze auch in der Plot-Routine mit einem entsprechenden Lösungsverfahren berechnet werden sollen.
            </xs:documentation></xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="Object" abstract="true" substitutionGroup="Element" type="ObjectType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Abstrakte Klasse eines Objekts.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="ObjectType">
    <xs:complexContent>
      <xs:extension base="ElementType"/>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="Body" abstract="true" substitutionGroup="Object" type="BodyType">
    <xs:annotation>
      <!--<xs:documentation xml:lang="de" xmlns="">
        The following <b>part</b> is <i>only</i> a test for <code>equation</code> and image output for the XML documentation FROM XSM SCHEMA.
        Also links to other parts of the Documentation is possible <a class="link" href="mbsim:Element">like this</a>.
        <p>A paragraph with a line break<br/>here</p>
        <p>Other paragraph with a definition list:</p>
        <dl>
          <dt>Def1</dt><dd>The description of Def1</dd>
          <dt>Def2</dt><dd>The description of Def2</dd>
        </dl>
        A unordered list
        <ul>
          <li>Item 1</li>
          <li>Item 2</li>
        </ul>
        and a ordered list
        <ol>
          <li>Item 1</li>
          <li>Item 2</li>
        </ol>
        A not inline equation
        <object class="eqn">
          <![CDATA[\int_a^b\sin(x)dx +
          \left[\begin{array}{cc}
          1 & 2 \\
          3 & 4
          \end{array}\right]]]>
        </object>
        And a inline equation <object class="inlineeqn">x_a+\cos(x)</object>. And a image.
        <object class="figure" data="mbsim.svg">The image caption</object>
        End of the test. 
      </xs:documentation>-->
      <xs:documentation xml:lang="de" xmlns="">
        Abstrakte Oberklasse für beliebige mechanische Körper (starr, flexibel, ...).
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="BodyType">
    <xs:complexContent>
      <xs:extension base="ObjectType">
        <xs:sequence>
          <xs:element name="generalizedInitialPosition" minOccurs="0" type="pv:unknownVector">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Inertiale Lage in den generalisierten Freiheitsgraden.
                <p>An dieser Stelle werden die Anfangslagen von zustandsbehafteten Objekten angegeben. Bei Starrkörpern muss die Länge dieses Vektors der Anzahl der angegebenen Translations- und Rotationsrichtungen entsprechen, wobei zunächst die translatorischen Lagen und danach die rotatorischen Lagen anzugeben sind.</p>
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="generalizedInitialVelocity" minOccurs="0" type="pv:unknownVector">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Inertiale Geschwindigkeiten in den generalisierten Freiheitsgraden.
                <p>vgl. <i>generalizedInitialPosition</i> für die Zuordnung.</p>
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="frameOfReference" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Definiert das KOS bezüglich dessen die Bewegung (Kinematik; generalisierte Lagen) des Körpers angegeben wird.<br/>
                Ist dieses Referenz-KOS ein KOS einer Gruppe (statisches KOS) so wird der Körper mit absoluten Koordinaten parametriert.
                Ist das Referenz-KOS eine KOS eines anderen Körpers (bewegtes KOS),
                so handelt es sich um einen Körper mit relativer Parametrierung (Baumstruktur).
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:attribute name="ref" type="FrameReferenceType" use="required"/>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="RigidBody" substitutionGroup="Body" type="RigidBodyType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Definiert einen Starrkörper.<br/>
        Grundlage zur Definition aller kinematischen Zusammenhänge bei Starrkörpern sind zwei Koordinatensysteme, das <code>frameOfReference</code> (siehe <a class="link" href="mbsim:Object">&lt;Object&gt;</a>) und das <code>frameForKinematics</code>. Das <code>frameOfReference</code> gehört entweder zu einer Gruppe und ist somit inertial fest oder es gehört zu einem anderen Körper und kann somit bewegt sein. Das <code>frameForKinematics</code> ist ein beliebiges körperfestes Koordinatensystem. Schließlich wird die Bewegung des Starrkörpers mittels generalisierter Koordinaten oder zeitabhängiger Funktionen als Bewegung des <code>frameForKinematics</code> relativ zum <code>frameOfReference</code> definiert.<br/>
        Zur rekursiven Definition weiterer körperfester Koordinatensystem hat jeder Starrkörper automatisch ein Koordinatensystem "C" in seinem Schwerpunkt.
        <object class="figure" data="rigid_body.svg">Kinematische Beschreibung eines Starrkörpers</object>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="RigidBodyType">
    <xs:complexContent>
      <xs:extension base="BodyType">
        <xs:sequence>
          <xs:element name="frameForKinematics" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Definiert das KOS, dessen relative Bewegung bezüglich des <code>frameOfReference</code>
                (siehe <a class="link" href="mbsim:Object"><code>Object</code></a>) sich unmittelbar aus den
                generalisierten Koordinaten dieses Körpers ergibt.
                <p>Es kann sich somit entsprechend der angegebenen translatorischen und rotatorischen Freiheitsgrade
                  relativ gegenüber dem <code>frameOfReference</code> bewegen und ist zu Beginn der Simulation um die
                  angegebenen generalisierten Startwerte gegenüber dem <code>frameOfReference</code> ausgelenkt.</p>
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:attribute name="ref" type="CurrentFrameReferenceType" use="required"/>
            </xs:complexType> 
          </xs:element>
          <xs:element name="mass" type="pv:massScalar">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Masse des Körpers.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="inertiaTensor" type="pv:inertiaMatrix">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Trägheitstensor des Körpers bezüglich des <code>frameForInertiaTensor</code> (standardmäßig das Schwerpunktkoordinatensystem "C").
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="frameForInertiaTensor" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Definiert das KOS für den Trägheitstensor (standardmäßig das Schwerpunktkoordinatensystem "C").
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:attribute name="ref" type="CurrentFrameReferenceType" use="required"/>
            </xs:complexType> 
          </xs:element>
          <xs:choice minOccurs="0">
            <xs:element name="generalTranslation">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                  Gibt die Vorschrift zur Berechnung des Translationsvektors
                  <object class="inlineeqn">\boldsymbol{r}_q=f(\boldsymbol{q},t)</object> in Abhängigkeit der 
                  generalisierten Lagen und der Zeit an.<br/>
                  Der Translationsvektor <object class="inlineeqn">\boldsymbol{r}_q</object> ist
                  im KOS <code>frameOfReference</code> dargestellt und stellt die
                  Relativverschiebung zwischen dem KOS <code>frameOfReference</code> und dem KOS <code>frameForKinematics</code> dar.
                  <p>Wird <code>Translation</code> nicht angegeben, so besitzt der Körper keine translatorischen Freiheitsgrade.</p>
              </xs:documentation></xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:element ref="Function"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
            <xs:element name="timeDependentTranslation">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                  Gibt die Vorschrift zur Berechnung des Translationsvektors
                  <object class="inlineeqn">\boldsymbol{r}_q=f(t)</object> in Abhängigkeit der 
                  generalisierten Lagen und der Zeit an.<br/>
                  Der Translationsvektor <object class="inlineeqn">\boldsymbol{r}_q</object> ist
                  im KOS <code>frameOfReference</code> dargestellt und stellt die
                  Relativverschiebung zwischen dem KOS <code>frameOfReference</code> und dem KOS <code>frameForKinematics</code> dar.
                  <p>Wird <code>Translation</code> nicht angegeben, so besitzt der Körper keine translatorischen Freiheitsgrade.</p>
              </xs:documentation></xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:element ref="Function"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
            <xs:element name="stateDependentTranslation">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                  Gibt die Vorschrift zur Berechnung des Translationsvektors
                  <object class="inlineeqn">\boldsymbol{r}_q=f(\boldsymbol{q})</object> in Abhängigkeit der 
                  generalisierten Lagen und der Zeit an.<br/>
                  Der Translationsvektor <object class="inlineeqn">\boldsymbol{r}_q</object> ist
                  im KOS <code>frameOfReference</code> dargestellt und stellt die
                  Relativverschiebung zwischen dem KOS <code>frameOfReference</code> und dem KOS <code>frameForKinematics</code> dar.
                  <p>Wird <code>Translation</code> nicht angegeben, so besitzt der Körper keine translatorischen Freiheitsgrade.</p>
              </xs:documentation></xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:element ref="Function"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
          </xs:choice>
          <xs:choice minOccurs="0">
            <xs:element name="generalRotation">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                  Gibt die Vorschrift zur Berechnung der Transformationsmatrix
                  <object class="inlineeqn">\boldsymbol{A}_q=f(\boldsymbol{q},t)</object> in Abhängigkeit der 
                  generalisierten Lagen und der Zeit an.<br/>
                  Die Transformationsmatrix <object class="inlineeqn">\boldsymbol{A}_q</object> stellt dabei die
                  Transformation vom KOS <code>frameForKinematics</code> in das KOS <code>frameOfReference</code> dar.
                  <p>Wird <code>Rotation</code> nicht angegeben, so besitzt der Körper keine rotatorischen Freiheitsgrade.</p>
              </xs:documentation></xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:element ref="Function"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
            <xs:element name="timeDependentRotation">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                  Gibt die Vorschrift zur Berechnung der Transformationsmatrix
                  <object class="inlineeqn">\boldsymbol{A}_q=f(t)</object> in Abhängigkeit der 
                  generalisierten Lagen und der Zeit an.<br/>
                  Die Transformationsmatrix <object class="inlineeqn">\boldsymbol{A}_q</object> stellt dabei die
                  Transformation vom KOS <code>frameForKinematics</code> in das KOS <code>frameOfReference</code> dar.
                  <p>Wird <code>Rotation</code> nicht angegeben, so besitzt der Körper keine rotatorischen Freiheitsgrade.</p>
              </xs:documentation></xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:element ref="Function"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
            <xs:element name="stateDependentRotation">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                  Gibt die Vorschrift zur Berechnung der Transformationsmatrix
                  <object class="inlineeqn">\boldsymbol{A}_q=f(\boldsymbol{q})</object> in Abhängigkeit der 
                  generalisierten Lagen und der Zeit an.<br/>
                  Die Transformationsmatrix <object class="inlineeqn">\boldsymbol{A}_q</object> stellt dabei die
                  Transformation vom KOS <code>frameForKinematics</code> in das KOS <code>frameOfReference</code> dar.
                  <p>Wird <code>Rotation</code> nicht angegeben, so besitzt der Körper keine rotatorischen Freiheitsgrade.</p>
              </xs:documentation></xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:element ref="Function"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
          </xs:choice>
          <xs:element name="translationDependentRotation" minOccurs="0" type="pv:booleanFullEval">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Definiert, ob die Rotation von der Translation abhängt. In diesem Fall werden für Translation und Rotation dieselben Koordinaten verwendet.
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="coordinateTransformationForRotation" minOccurs="0" type="pv:booleanFullEval">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Definiert, ob für die Beschreibung der Rotation eine Koordinatentransformation durchgeführt werden soll (standardmäßig an). Mit Koordinatentransformation werden für die generalisierten Koordinaten der Rotation kartesische Winkelgeschwindigkeiten verwendet. Ohne Koordinatentransformation werden die Ableitungen der Winkelkoordinaten verwendet.
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="bodyFixedRepresentationOfAngularVelocity" minOccurs="0" type="pv:booleanFullEval">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Definiert, ob bei aktivierter Koordinatentransformation für die Rotation eine Darstellung der Winkelgeschwindigkeiten bzgl. des körperfesten Koordinatensystems verwendet werden soll (standardmäßig aus). Bei absoluten räumlichen Drehungen hat dies den Vorteil einer konstante Massenmatrix. Standarmäßig wird eine Darstellung bzgl. des Referenzsystems verwendet.
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="frames">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Kontainer für lokale Koordinatensysteme dieses Körpers.<br/>
                Da es sich um einen Starrkörper
                handelt, ist die relative Lage dieser KOS untereinander (und auch zum KOS "C") während
                der gesamten Simulation konstant.
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:sequence>
                <xs:choice minOccurs="0" maxOccurs="unbounded">
                  <xs:element ref="FixedRelativeFrame"/>
                  <xs:element ref="pv:Embed"/>
                </xs:choice>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="contours">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Kontainer für lokale Kontaktkonturen dieses Körpers.<br/>
                Da es sich um einen Starrkörper handelt, ist die relative Lage dieser Kontaktkonturen
                untereinander (und auch zum KOS "C") während der gesamten Simulation konstant.
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:sequence>
              <xs:choice minOccurs="0" maxOccurs="unbounded">
                <xs:element ref="Contour"/>
                <xs:element ref="pv:Embed"/>
              </xs:choice>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:sequence minOccurs="0">
            <xs:element name="openMBVRigidBody">
              <xs:annotation>
                <xs:documentation xml:lang="de" xmlns="">
                  Aktiviert die Visualisierung dieses Körpers in OpenMBV durch den unten angegebenen OpenMBV Körper.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:element ref="ombv:RigidBody"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
            <xs:element name="openMBVFrameOfReference" minOccurs="0">
              <xs:annotation>
                <xs:documentation xml:lang="de" xmlns="">
                  Definiert das MBSim KOS, mit dem das Referenz-KOS des OpenMBV Körpers zusammenfällt.<br/>
                  Wird dieses Element nicht angegeben, so wird das KOS "C" verwendet.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:attribute name="ref" type="CurrentFrameReferenceType" use="required"/>
              </xs:complexType>
            </xs:element>
          </xs:sequence>
          <xs:element name="enableOpenMBVFrameC" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Aktiviert die Visualisierung des Schwerpunktskoordinatensystems "C" dieses Körpers in OpenMBV.
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:group ref="OpenMBVFrameParameters"/>
            </xs:complexType> 
          </xs:element>
          <xs:element name="enableOpenMBVWeight" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Wenn angegeben, wird die Gewichtskraft durch einen OpenMBV Pfeil in OpenMBV visualisiert.
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:group ref="OpenMBVArrowParameters"/>
            </xs:complexType> 
          </xs:element>
          <xs:element name="enableOpenMBVJointForce" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Wenn angegeben, wird die Gelenkkraft durch einen OpenMBV Pfeil in OpenMBV visualisiert.
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:group ref="OpenMBVArrowParameters"/>
            </xs:complexType> 
          </xs:element>
          <xs:element name="enableOpenMBVJointMoment" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Wenn angegeben, wird das Gelenkmoment durch einen OpenMBV Pfeil in OpenMBV visualisiert.
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:group ref="OpenMBVArrowParameters"/>
            </xs:complexType> 
          </xs:element>
          <xs:element name="plotFeatureFrameC" minOccurs="0" maxOccurs="unbounded">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Definiert die Plotfeatures des Schwerpunktskoordinatensystems "C" dieses Körpers.
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:attribute name="feature" type="PlotFeatureType" use="required"/>
            </xs:complexType>
          </xs:element>
        </xs:sequence> 
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>   
  
  <xs:element name="Constraint" abstract="true" substitutionGroup="Element" type="ConstraintType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Kinematische Zwangsbedingungen.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="ConstraintType">
    <xs:complexContent>
      <xs:extension base="ElementType"/>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="GeneralizedConstraint" abstract="true" substitutionGroup="Constraint" type="GeneralizedConstraintType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Kinematische Zwangsbedingungen für generalisierte Koordinaten.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="GeneralizedConstraintType">
    <xs:complexContent>
      <xs:extension base="ConstraintType">
        <xs:sequence>
          <xs:element name="supportFrame" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Definiert das KOS an dem die Stützkraft und das Stützmoment eingeleitet werden.
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:attribute name="ref" type="FrameReferenceType" use="required"/>
            </xs:complexType>
          </xs:element>
          <xs:element name="enableOpenMBVForce" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Wenn angegeben, wird die Zwangskraft durch einen OpenMBV Pfeil in OpenMBV visualisiert.
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:group ref="OpenMBVArrowParameters"/>
            </xs:complexType>
          </xs:element>
          <xs:element name="enableOpenMBVMoment" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Wenn angegeben, wird das Zwangsmoment durch einen OpenMBV Pfeil in OpenMBV visualisiert.
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:group ref="OpenMBVArrowParameters"/>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="GeneralizedDualConstraint" substitutionGroup="GeneralizedConstraint" type="GeneralizedDualConstraintType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        TODO <br/>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="GeneralizedDualConstraintType">
    <xs:complexContent>
      <xs:extension base="GeneralizedConstraintType">
        <xs:sequence>
          <xs:element name="dependentRigidBody">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Starrkörper, dessen generalisierte Koordinaten durch eine Zeitfunktion bestimmt werden kann.
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:attribute name="ref" type="ObjectReferenceType" use="required"/>
            </xs:complexType> 
          </xs:element>
          <xs:element name="independentRigidBody" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Starrkörper, dessen generalisierte Koordinaten durch eine Zeitfunktion bestimmt werden kann.
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:attribute name="ref" type="ObjectReferenceType" use="required"/>
            </xs:complexType>
          </xs:element>
        </xs:sequence> 
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="GeneralizedPositionConstraint" substitutionGroup="GeneralizedDualConstraint" type="GeneralizedPositionConstraintType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        TODO <br/>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="GeneralizedPositionConstraintType">
    <xs:complexContent>
      <xs:extension base="GeneralizedDualConstraintType">
        <xs:sequence>
          <xs:element name="constraintFunction">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              TODO
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:sequence>
                <xs:element ref="Function"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
        </xs:sequence> 
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="GeneralizedVelocityConstraint" substitutionGroup="GeneralizedDualConstraint" type="GeneralizedVelocityConstraintType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        TODO <br/>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="GeneralizedVelocityConstraintType">
    <xs:complexContent>
      <xs:extension base="GeneralizedDualConstraintType">
        <xs:sequence>
          <xs:element name="initialState" minOccurs="0" type="pv:unknownVector">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
              tbd
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:choice>
            <xs:element name="generalConstraintFunction">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                TODO
              </xs:documentation></xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:element ref="Function"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
            <xs:element name="timeDependentConstraintFunction">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                TODO
              </xs:documentation></xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:element ref="Function"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
            <xs:element name="stateDependentConstraintFunction">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                TODO
              </xs:documentation></xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:element ref="Function"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
          </xs:choice>
        </xs:sequence> 
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="GeneralizedAccelerationConstraint" substitutionGroup="GeneralizedDualConstraint" type="GeneralizedAccelerationConstraintType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        TODO <br/>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="GeneralizedAccelerationConstraintType">
    <xs:complexContent>
      <xs:extension base="GeneralizedDualConstraintType">
        <xs:sequence>
          <xs:element name="initialState" minOccurs="0" type="pv:unknownVector">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
              tbd
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:choice>
            <xs:element name="generalConstraintFunction">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                TODO
              </xs:documentation></xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:element ref="Function"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
            <xs:element name="timeDependentConstraintFunction">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                TODO
              </xs:documentation></xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:element ref="Function"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
            <xs:element name="stateDependentConstraintFunction">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                TODO
              </xs:documentation></xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:element ref="Function"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
          </xs:choice>
        </xs:sequence> 
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="GeneralizedGearConstraint" substitutionGroup="GeneralizedConstraint" type="GeneralizedGearConstraintType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        TODO <br/>
        Kinematische Zwangsbedingung durch Angabe eines Übersetzungsverhältnisses.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="GeneralizedGearConstraintType">
    <xs:complexContent>
      <xs:extension base="GeneralizedConstraintType">
        <xs:sequence>
          <xs:element name="dependentRigidBody">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Getriebeausgang
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:attribute name="ref" type="ObjectReferenceType" use="required"/>
            </xs:complexType> 
          </xs:element>
          <xs:element name="independentRigidBody" minOccurs="1" maxOccurs="unbounded">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Getriebeeingang
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:attribute name="ref" type="ObjectReferenceType" use="required"/>
              <xs:attribute name="ratio" type="pv:floatFullEval" use="required"/>
            </xs:complexType> 
          </xs:element>
        </xs:sequence> 
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="JointConstraint" substitutionGroup="Constraint" type="JointConstraintType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        TODO <br/>
        Kinematische Zwangsbedingung durch geschlossene Schleifen. Die  Auflösung der kinematischen Schleife erfolgt durch die Lösung eines Gleichungssystems. Durch die inertiale generalisierte Lage kann ein Startvektor für den Lösungsalgorithmus vorgegeben werden.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="JointConstraintType">
    <xs:complexContent>
      <xs:extension base="ConstraintType">
        <xs:sequence>
          <xs:element name="dependentRigidBodyOnFirstSide" minOccurs="0" maxOccurs="unbounded">
            <xs:complexType>
              <xs:attribute name="ref" type="ObjectReferenceType" use="required">
                <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                  Liste der Körper auf Seite A des Lagers.
                </xs:documentation></xs:annotation>
              </xs:attribute>
            </xs:complexType>
          </xs:element>
          <xs:element name="dependentRigidBodyOnSecondSide" minOccurs="0" maxOccurs="unbounded">
            <xs:complexType>
              <xs:attribute name="ref" type="ObjectReferenceType" use="required">
                <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                  Liste der Körper auf Seite B des Lagers.
                </xs:documentation></xs:annotation>
              </xs:attribute>
            </xs:complexType>
          </xs:element>
          <xs:element name="independentRigidBody" minOccurs="1" maxOccurs="unbounded">
            <xs:complexType>
              <xs:attribute name="ref" type="ObjectReferenceType" use="required">
                <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                  Angabe der Körper, deren Freiheitsgrade erhalten bleiben. Die Lagen und Geschwindigkeiten aller anderen Körper in der kinematischen Schleife können aus den generalisierten Koordinate dieser Körper bestimmt werden.
                </xs:documentation></xs:annotation>
              </xs:attribute>
            </xs:complexType>
          </xs:element>
          <xs:element name="connect">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Angabe der beiden Koordinatensysteme, welche in Übereinstimmung gebracht werden sollen.
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:attribute name="ref1" type="FrameReferenceType" use="required"/>
              <xs:attribute name="ref2" type="FrameReferenceType" use="required"/>
            </xs:complexType> 
          </xs:element>
          <xs:element name="frameOfReferenceID" minOccurs="0" type="pv:integerFullEval">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
               tbd
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="forceDirection" type="pv:nounitMatrix" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Angabe der Richtungen, für die eine Übereinstimmung im Gelenk für translatorische Freiheitsgrade erzeugt werden soll.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="momentDirection" type="pv:nounitMatrix" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Angabe der Richtungen, für die eine Übereinstimmung im Gelenk für rotatorische Freiheitsgrade erzeugt werden soll.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="initialGuess" minOccurs="0" type="pv:unknownVector">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Anfangswerte für Newton-Löser.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="enableOpenMBVForce" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Wenn angegeben, wird die Reibkraft durch einen OpenMBV Pfeil mit Wirkung auf die Kontur des zweiten Körpers in OpenMBV visualisiert.
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:group ref="OpenMBVArrowParameters"/>
            </xs:complexType> 
          </xs:element>
          <xs:element name="enableOpenMBVMoment" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Wenn angegeben, wird die Reibkraft durch einen OpenMBV Pfeil mit Wirkung auf die Kontur des zweiten Körpers in OpenMBV visualisiert.
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:group ref="OpenMBVArrowParameters"/>
            </xs:complexType> 
          </xs:element>
        </xs:sequence> 
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="GeneralizedConnectionConstraint" substitutionGroup="GeneralizedConstraint" type="GeneralizedConnectionConstraintType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
      tbd
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="GeneralizedConnectionConstraintType">
    <xs:complexContent>
      <xs:extension base="GeneralizedConstraintType">
        <xs:sequence>
          <xs:element name="dependentRigidBody">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Starrkörper, dessen generalisierte Koordinaten von den generalisierten Koordinaten eines anderen Körper abhängig sind.
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:attribute name="ref" type="ObjectReferenceType" use="required"/>
            </xs:complexType>
          </xs:element>
          <xs:element name="independentRigidBody" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Starrkörper, dessen generalisierte Koordinaten unabhängig sind.
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:attribute name="ref" type="ObjectReferenceType" use="required"/>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="Link" abstract="true" substitutionGroup="Element" type="LinkType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Abstrakte Oberklasse eines Verbindungselements zwischen Objekten.
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="LinkType">
    <xs:complexContent>
      <xs:extension base="ElementType"/>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="FrameLink" substitutionGroup="Link" type="FrameLinkType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Abstrakte Oberklasse für mechanische Verbindungselemente zwischen Körpern.
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="FrameLinkType">
    <xs:complexContent>
      <xs:extension base="LinkType">
        <xs:sequence>
          <xs:element name="connect">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Definiert die Angriffspunkte des Feder-Dämpfer Elements auf den beiden Körpern. Als Angriffspunkt
                muss dabei ein KOS des entsprechenden Körpers angegeben werden.
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:attribute name="ref1" type="FrameReferenceType" use="required"/>
              <xs:attribute name="ref2" type="FrameReferenceType" use="required"/>
            </xs:complexType>
          </xs:element>
          <xs:element name="enableOpenMBVForce" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Wenn angegeben, wird die Gelenkkraft durch einen OpenMBV Pfeil in OpenMBV visualisiert.
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:group ref="OpenMBVArrowParameters"/>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="FloatingFrameLink" substitutionGroup="Link" type="FloatingFrameLinkType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Abstrakte Oberklasse für mechanische Verbindungselemente zwischen Körpern.
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="FloatingFrameLinkType">
    <xs:complexContent>
      <xs:extension base="LinkType">
        <xs:sequence>
          <xs:element name="connect">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Definiert den Angriffspunkt dieser kinetischen Anregung auf einen Körper. Als Angriffspunkt
                muss dabei ein KOS des entsprechenden Körpers angegeben werden.
                Bei inneren Kräften und Momenten können alternativ die KOS beider Schnittufer angegeben werden.
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:attribute name="ref1" type="FrameReferenceType" default="../Frame[I]"/>
              <xs:attribute name="ref2" type="FrameReferenceType"/>
            </xs:complexType>
          </xs:element>
          <xs:element name="frameOfReferenceID" minOccurs="0" type="pv:integerFullEval">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Gibt an, in welchem Koordinatensystem der Kraft- und Momentvektor dargestellt ist. 0 definiert den unter ref1 und 1 den unter
              ref2 angegebenen Frame.
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="enableOpenMBVForce" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Wenn angegeben, wird die Reibkraft durch einen OpenMBV Pfeil mit Wirkung auf die Kontur des zweiten Körpers in OpenMBV visualisiert.
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:group ref="OpenMBVArrowParameters"/>
            </xs:complexType>
          </xs:element>
          <xs:element name="enableOpenMBVMoment" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Wenn angegeben, wird die Reibkraft durch einen OpenMBV Pfeil mit Wirkung auf die Kontur des zweiten Körpers in OpenMBV visualisiert.
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:group ref="OpenMBVArrowParameters"/>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="ContourLink" substitutionGroup="Link" type="ContourLinkType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Abstrakte Oberklasse für mechanische Verbindungselemente zwischen Körpern.
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="ContourLinkType">
    <xs:complexContent>
      <xs:extension base="LinkType">
        <xs:sequence>
          <xs:element name="connect">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Bindet zwei Konturen an einen Kontakt.
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:attribute name="ref1" type="ContourReferenceType" use="required"/>
              <xs:attribute name="ref2" type="ContourReferenceType" use="required"/>
            </xs:complexType>
          </xs:element>
          <xs:element name="enableOpenMBVForce" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Wenn angegeben, wird die Reibkraft durch einen OpenMBV Pfeil mit Wirkung auf die Kontur des zweiten Körpers in OpenMBV visualisiert.
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:group ref="OpenMBVArrowParameters"/>
            </xs:complexType>
          </xs:element>
          <xs:element name="enableOpenMBVMoment" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Wenn angegeben, wird die Reibkraft durch einen OpenMBV Pfeil mit Wirkung auf die Kontur des zweiten Körpers in OpenMBV visualisiert.
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:group ref="OpenMBVArrowParameters"/>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="RigidBodyLink" substitutionGroup="Link" type="RigidBodyLinkType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Abstrakte Oberklasse für mechanische Verbindungselemente zwischen Starrkörpern.
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="RigidBodyLinkType">
    <xs:complexContent>
      <xs:extension base="LinkType">
        <xs:sequence>
          <xs:element name="supportFrame" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Definiert das KOS an dem die Stützkraft und das Stützmoment eingeleitet werden. Wird kein KOS angegeben, wird das Referenzsystem des ersten Körpers verwendet.
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:attribute name="ref" type="FrameReferenceType" use="required"/>
            </xs:complexType>
          </xs:element>
          <xs:element name="enableOpenMBVForce" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Wenn angegeben, wird die Reibkraft durch einen OpenMBV Pfeil mit Wirkung auf die Kontur des zweiten Körpers in OpenMBV visualisiert.
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:group ref="OpenMBVArrowParameters"/>
            </xs:complexType>
          </xs:element>
          <xs:element name="enableOpenMBVMoment" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Wenn angegeben, wird die Reibkraft durch einen OpenMBV Pfeil mit Wirkung auf die Kontur des zweiten Körpers in OpenMBV visualisiert.
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:group ref="OpenMBVArrowParameters"/>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="DualRigidBodyLink" substitutionGroup="RigidBodyLink" type="DualRigidBodyLinkType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
      tbd
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="DualRigidBodyLinkType">
    <xs:complexContent>
      <xs:extension base="RigidBodyLinkType">
        <xs:sequence>
          <xs:element name="connect">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              tbd
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:attribute name="ref" type="FrameReferenceType"/>
              <xs:attribute name="ref1" type="FrameReferenceType"/>
              <xs:attribute name="ref2" type="FrameReferenceType"/>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="KineticExcitation" substitutionGroup="FloatingFrameLink" type="KineticExcitationType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Definiert eine externe, kinetische Anregung auf einen Körper.
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="KineticExcitationType">
    <xs:complexContent>
      <xs:extension base="FloatingFrameLinkType">
        <xs:sequence>
          <xs:sequence minOccurs="0">
            <xs:element name="forceDirection" type="pv:nounitMatrix">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                  Definiert die Wirkrichtung der Kraftanregung(en).
                  Die Spalte i dieser Matrix definiert den Wirkrichtungsvektor des i-ten Eintrags der Kraftfunktion angegeben
                  im KOS <code>frameOfReferenceID</code>. Um eine Skalierung der skalaren Kraft (i-ter Eintrag der Kraftfunktion)
                  zu umgehen, sollte jede Spalte dieser Matrix normiert sein.
              </xs:documentation></xs:annotation>
            </xs:element>
            <xs:element name="forceFunction">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                  Definiert die Kraftfunktion in Abhängigkeit der Zeit.
              </xs:documentation></xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:element ref="Function"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
          </xs:sequence>
          <xs:sequence minOccurs="0">
            <xs:element name="momentDirection" type="pv:nounitMatrix">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                  Definiert die Wirkrichtung der Momentenanregung(en).
                  Die Spalte i dieser Matrix definiert den Wirkrichtungsvektor des i-ten Eintrags der Momentfunktion angegeben
                  im KOS <code>frameOfReferenceID</code>. Um eine Skalierung des skalaren Moments (i-ter Eintrag der Momentfunktion)
                  zu umgehen, sollte jede Spalte dieser Matrix normiert sein.
              </xs:documentation></xs:annotation>
            </xs:element>
            <xs:element name="momentFunction">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                  Definiert die Momentfunktion in Abhängigkeit der Zeit.
              </xs:documentation></xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:element ref="Function"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
          </xs:sequence>
        </xs:sequence> 
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="SpringDamper" substitutionGroup="FrameLink" type="SpringDamperType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Definiert ein Feder-Dämpfer Element als Verbindung zwischen zwei Körpern. Es wird zwischen einer gerichteten Verbindung und einer Punkt-zu-Punkt-Verbindung unterschieden.
        <p>
          <i>Punkt-zu-Punkt-Verbindung.</i> Die Kraft des Feder-Dämpfer-Elements wird aus dem Abstand der verbundenen Punkte und der in diese Richtung projezierten relativen Geschwindigkeit berechnet. Der Abstand ist dabei immer positiv. Die Kraft wird ebenfalls in diese Richtung aufgebracht.
        </p>
        <p>
          <i>Gerichtete Verbindung.</i> Die Kraft des Feder-Dämpfer-Elements wird aus dem in die Richtung der angegebenen Projektionsrichtung projezierten Verbindungsvektor der beiden verbundenen Punkte sowie der in diese Richtung projezierten Relativgeschwindigkeit berechnet. Die Kraft wird in der angegebenen Projektionsrichtung aufgebracht. <br/>
          <b>Achtung!</b> Durch eine falsche Wahl der Projektionsrichtung wird unter Umständen das Momentengleichgewicht nicht mehr erfüllt.
        </p>
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="SpringDamperType">
    <xs:complexContent>
      <xs:extension base="FrameLinkType">
        <xs:sequence>
          <xs:element name="forceFunction">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Definiert die Kraftfunktion in Abhängigkeit der relativen Auslenkung der Kraftangriffspunkte
                und der relativen Geschwindigkeit zwischen den Kraftangriffspunkten.
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:sequence>
                <xs:element ref="Function"/>
              </xs:sequence>
            </xs:complexType> 
          </xs:element>
          <xs:element name="unloadedLength" type="pv:lengthScalar">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Entspannte Federlänge <object class="inlineeqn">l_0</object>.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="enableOpenMBVCoilSpring" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Wenn angegeben, wird das Feder-Dämpfer Element durch eine OpenMBV Feder in OpenMBV visualisiert.
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:group ref="OpenMBVCoilSpringParameters"/>
            </xs:complexType> 
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="DirectionalSpringDamper" substitutionGroup="FloatingFrameLink" type="DirectionalSpringDamperType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Definiert ein Feder-Dämpfer Element als Verbindung zwischen zwei Körpern. Es wird zwischen einer gerichteten Verbindung und einer Punkt-zu-Punkt-Verbindung unterschieden.
        <p>
          <i>Punkt-zu-Punkt-Verbindung.</i> Die Kraft des Feder-Dämpfer-Elements wird aus dem Abstand der verbundenen Punkte und der in diese Richtung projezierten relativen Geschwindigkeit berechnet. Der Abstand ist dabei immer positiv. Die Kraft wird ebenfalls in diese Richtung aufgebracht.
        </p>
        <p>
          <i>Gerichtete Verbindung.</i> Die Kraft des Feder-Dämpfer-Elements wird aus dem in die Richtung der angegebenen Projektionsrichtung projezierten Verbindungsvektor der beiden verbundenen Punkte sowie der in diese Richtung projezierten Relativgeschwindigkeit berechnet. Die Kraft wird in der angegebenen Projektionsrichtung aufgebracht. <br/>
          <b>Achtung!</b> Durch eine falsche Wahl der Projektionsrichtung wird unter Umständen das Momentengleichgewicht nicht mehr erfüllt.
        </p>
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="DirectionalSpringDamperType">
    <xs:complexContent>
      <xs:extension base="FloatingFrameLinkType">
        <xs:sequence>
          <xs:element name="forceDirection" type="pv:nounitVector">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Definiert die Wirkrichtung der Kraftanregung(en).
                Die Spalte i dieser Matrix definiert den Wirkrichtungsvektor des i-ten Eintrags der Kraftfunktion angegeben
                im KOS <code>frameOfReference</code>. Um eine Skalierung der skalaren Kraft (i-ter Eintrag der Kraftfunktion)
                zu umgehen, sollte jede Spalte dieser Matrix normiert sein.
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="forceFunction">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Definiert die Kraftfunktion in Abhängigkeit der relativen Auslenkung der Kraftangriffspunkte
                und der relativen Geschwindigkeit zwischen den Kraftangriffspunkten.
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:sequence>
                <xs:element ref="Function"/>
              </xs:sequence>
            </xs:complexType> 
          </xs:element>
          <xs:element name="unloadedLength" type="pv:lengthScalar">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Entspannte Federlänge <object class="inlineeqn">l_0</object>.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="enableOpenMBVCoilSpring" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Wenn angegeben, wird das Feder-Dämpfer Element durch eine OpenMBV Feder in OpenMBV visualisiert.
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:group ref="OpenMBVCoilSpringParameters"/>
            </xs:complexType> 
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="GeneralizedSpringDamper" substitutionGroup="DualRigidBodyLink" type="GeneralizedSpringDamperType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
    tbd
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="GeneralizedSpringDamperType">
    <xs:complexContent>
      <xs:extension base="DualRigidBodyLinkType">
        <xs:sequence>
          <xs:element name="generalizedForceFunction">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
            tbd
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:sequence>
                <xs:element ref="Function"/>
              </xs:sequence>
            </xs:complexType> 
          </xs:element>
          <xs:element name="generalizedUnloadedLength" type="pv:unknownScalar">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Entspannte Federlänge <object class="inlineeqn">l_0</object>.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="GeneralizedFriction" substitutionGroup="DualRigidBodyLink" type="GeneralizedFrictionType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
    tbd
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="GeneralizedFrictionType">
    <xs:complexContent>
      <xs:extension base="DualRigidBodyLinkType">
        <xs:sequence>
          <xs:element name="generalizedFrictionForceLaw">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
            tbd
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:sequence>
                <xs:element ref="FrictionForceLaw"/>
              </xs:sequence>
            </xs:complexType> 
          </xs:element>
          <xs:element name="generalizedNormalForceFunction">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
            tbd
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:sequence>
                <xs:element ref="Function"/>
              </xs:sequence>
            </xs:complexType> 
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="GeneralizedConnection" substitutionGroup="DualRigidBodyLink" type="GeneralizedConnectionType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
    tbd
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="GeneralizedConnectionType">
    <xs:complexContent>
      <xs:extension base="DualRigidBodyLinkType">
        <xs:sequence>
          <xs:element name="generalizedForceLaw">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
            tbd
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:sequence>
                <xs:element ref="GeneralizedForceLaw"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="GeneralizedElasticConnection" substitutionGroup="DualRigidBodyLink" type="GeneralizedElasticConnectionType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
    tbd
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="GeneralizedElasticConnectionType">
    <xs:complexContent>
      <xs:extension base="DualRigidBodyLinkType">
        <xs:sequence>
          <xs:element name="generalizedForceFunction">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
            tbd
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:sequence>
                <xs:element ref="Function"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="GeneralizedGear" substitutionGroup="RigidBodyLink" type="GeneralizedGearType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        TODO <br/>
        Kinematische Zwangsbedingung durch Angabe eines Übersetzungsverhältnisses.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="GeneralizedGearType">
    <xs:complexContent>
      <xs:extension base="RigidBodyLinkType">
        <xs:sequence>
          <xs:element name="gearOutput">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Getriebeausgang
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:attribute name="ref" type="ObjectReferenceType" use="required"/>
            </xs:complexType>
          </xs:element>
          <xs:element name="gearInput" minOccurs="1" maxOccurs="unbounded">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Getriebeeingang
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:attribute name="ref" type="ObjectReferenceType" use="required"/>
              <xs:attribute name="ratio" type="pv:floatFullEval" use="required"/>
            </xs:complexType>
          </xs:element>
          <xs:element name="generalizedForceLaw">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
            tbd
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:sequence>
                <xs:element ref="GeneralizedForceLaw"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="Joint" substitutionGroup="FloatingFrameLink" type="JointType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Definiert ein Gelenk als Verbindung zwischen zwei Körpern oder zwischen Körper und Umwelt.<br/>
        Aufgabe von Gelenken ist es, die Relativbewegung zwischen einzelnen Körpern eines Mehrkörpersystems einzuschränken und somit nur bestimmte Bewegungsmöglichkeiten zuzulassen. Die Relativbewegungen, die zwei Körper im ungebundenen Zustand durchführen könnten, werden dabei durch Gelenkkräfte und -momente verhindert.<br/> 
        Dabei wird idealisiert davon ausgegangen, dass Zwangsreaktionen punktuell zwischen zwei Koordinatensystemen übertragen werden.<br/>
        Wie der Betrag der Zwangsreaktionen berechnet wird, bestimmt das zugrunde liegende konstitutive Gesetz.<br/>
        Die Richtungen der Zwangsreaktion sind vom Benutzer anzugeben und bestimmen den Typ des Gelenks (z.B. Schub- / Drehgelenk usw.).
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="JointType">
    <xs:complexContent>
      <xs:extension base="FloatingFrameLinkType">
        <xs:sequence>
          <xs:sequence minOccurs="0">
            <xs:element name="forceDirection" type="pv:nounitMatrix">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                  Richtungen <object class="inlineeqn">\mathbf{D}_T=\left(\mathbf{d}_{T,1},\ldots\right)</object> der Zwangskräfte des Gelenks in normierten Vektoren dargestellt im Koordinatensystem des ersten Körpers.
              </xs:documentation></xs:annotation>
            </xs:element>
            <xs:element name="forceLaw">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                  Definiert das konstitutive Gesetz bez. der Zwangskräfte auf Beschleunigungsebene (ausreichend für alle funktionellen Gesetze / ausreichend wenn keine Stöße im System auftreten und das System ereignisgesteuert integriert wird)
              </xs:documentation></xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:element ref="GeneralizedForceLaw"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
          </xs:sequence>
          <xs:sequence minOccurs="0">
            <xs:element name="momentDirection" type="pv:nounitMatrix">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                  Richtungen <object class="inlineeqn">\mathbf{D}_R=\left(\mathbf{d}_{R,1},\ldots\right)</object> der Zwangsmomente des Gelenks in normierten Vektoren dargestellt im Koordinatensystem des ersten Körpers.
              </xs:documentation></xs:annotation>
            </xs:element>
            <xs:element name="momentLaw">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                  Definiert das konstitutive Gesetz bez. der Zwangsmomente auf Beschleunigungsebene (ausreichend für alle funktionellen Gesetze / ausreichend wenn keine Stöße im System auftreten und das System ereignisgesteuert integriert wird)
              </xs:documentation></xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:element ref="GeneralizedForceLaw"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
          </xs:sequence>
        </xs:sequence> 
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="ElasticJoint" substitutionGroup="FloatingFrameLink" type="ElasticJointType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Definiert ein Gelenk als elastische Verbindung zwischen zwei Körpern oder zwischen Körper und Umwelt.<br/>
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="ElasticJointType">
    <xs:complexContent>
      <xs:extension base="FloatingFrameLinkType">
        <xs:sequence>
          <xs:element name="forceDirection" type="pv:nounitMatrix" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Richtungen <object class="inlineeqn">\mathbf{D}_T=\left(\mathbf{d}_{T,1},\ldots\right)</object> der Zwangskräfte des Gelenks in normierten Vektoren dargestellt im Koordinatensystem des ersten Körpers.
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="momentDirection" type="pv:nounitMatrix" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Richtungen <object class="inlineeqn">\mathbf{D}_R=\left(\mathbf{d}_{R,1},\ldots\right)</object> der Zwangsmomente des Gelenks in normierten Vektoren dargestellt im Koordinatensystem des ersten Körpers.
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="generalizedForceFunction">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
            tbd
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:sequence>
                <xs:element ref="Function"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="SingleContact" substitutionGroup="ContourLink" type="SingleContactType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Definiert einen Kontakt als Interaktion zwischen zwei Körpern oder zwischen Körper und Umwelt.<br/>
        Bei der Simulation von Mehrkörpersystemen kann es aufgrund der Bewegung der Körper zu Kontakten zwischen einzelnen Körpern, aber auch zwischen einem Körper und der Umwelt kommen. Kommen zwei Körper in Kontakt, bildet sich an den sich berührenden Konturen (siehe <a class="link" href="mbsim:Contour">&lt;Contour&gt;</a>) eine Kontaktfläche aus, in der die Kontaktkräfte zwischen den Kontaktpartnern übertragen werden.<br/>
        Idealisiert wird davon ausgegangen, dass nur punktförmige Kontakte existieren; dies ist für eine Vielzahl von Problemstellungen ausreichend. Bei flächenhaften Kontakten muss die Oberfläche durch eine endliche Anzahl von Punkten diskretisiert werden.<br/>
        Es wird zwischen Kontaktkinematik und -kinetik unterschieden. In der Kontaktkinematik wird die relative Lage und Bewegung von zwei Konturen, also potentielle Kontaktpunkte, Abstand, relative Geschwindigkeiten in Konturnormalenrichtung und in der Tangentialebene der Kontur sowie u.U. auch Beschleunigungsgrößen bestimmt. Sie sind Eingangsgrößen der Kontaktkinetik und bestimmen somit anschließend die Kontaktkräfte über konstitutive Gesetze.
        <object class="figure" data="contact.svg">Kinematik einer Kontaktpaarung</object>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="SingleContactType">
    <xs:complexContent>
      <xs:extension base="ContourLinkType">
        <xs:sequence>
          <xs:element name="normalForceLaw">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Definiert das konstitutive Gesetz bez. der Kontaktkräfte auf Beschleunigungsebene in Konturnormalenrichtung (ausreichend für alle funktionellen Gesetze / ausreichend wenn keine Stöße im System auftreten und das System ereignisgesteuert integriert wird).
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:sequence>
                <xs:element ref="GeneralizedForceLaw"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="normalImpactLaw" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Definiert das konstitutive Gesetz bez. der Kontaktkräfte auf Geschwindigkeitsebene in Konturnormalenrichtung (nötig wenn Stöße im System auftreten oder das System mit Timestepping-Verfahren integriert wird).
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:sequence>
                <xs:element ref="GeneralizedImpactLaw"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:sequence minOccurs="0">
            <xs:element name="tangentialForceLaw">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                  Definiert das konstitutive Reibgesetz bez. der Kontaktkräfte auf Beschleunigungssebene (ausreichend für alle funktionellen Gesetze / ausreichend wenn keine Stöße im System auftreten und das System ereignisgesteuert integriert wird).
              </xs:documentation></xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:element ref="FrictionForceLaw"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
            <xs:element name="tangentialImpactLaw" minOccurs="0">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                  Definiert das konstitutive Reibgesetz bez. der Kontaktkräfte auf Geschwindigkeitssebene (nötig wenn Stöße im System auftreten oder das System mit Timestepping-Verfahren integriert wird).
              </xs:documentation></xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:element ref="FrictionImpactLaw"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
          </xs:sequence>
          <xs:element name="enableOpenMBVContactPoints" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Aktiviert die Visualisierung von zwei OpenMBV Koordinatensystemen in den jeweiligen Kontaktpunkten zur Repräsentation der begleitenden Dreibeine <object class="inlineeqn">\left(\boldsymbol{n},\boldsymbol{t}_1,\boldsymbol{t}_2\right)</object> bestehend aus Normale und den beiden Tangenten.<br/>
                Bei geschlossenem Kontakt fallen die Kontaktpunkte zusammen.<br/>
                Bei offenem Kontakt liegen die Kontaktpunkte auf den Konturen und haben minimalen Abstand.
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:group ref="OpenMBVFrameParameters"/>
            </xs:complexType> 
          </xs:element>
          <xs:element name="enableOpenMBVNormalForce" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Wenn angegeben, wird die Kontaktkraft in Normalenrichtung durch einen OpenMBV Pfeil mit Wirkung auf die Kontur des zweiten Körpers in OpenMBV visualisiert.
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:group ref="OpenMBVArrowParameters"/>
            </xs:complexType> 
          </xs:element>
          <xs:element name="enableOpenMBVTangentialForce" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Wenn angegeben, wird die Reibkraft durch einen OpenMBV Pfeil mit Wirkung auf die Kontur des zweiten Körpers in OpenMBV visualisiert.
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:group ref="OpenMBVArrowParameters"/>
            </xs:complexType> 
          </xs:element>
        </xs:sequence> 
      </xs:extension>
    </xs:complexContent>
  </xs:complexType> 

  <xs:element name="Contact" substitutionGroup="Link" type="ContactType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Definiert einen Kontakt als Interaktion zwischen mehreren Körpern.<br/>
        Bei der Simulation von Mehrkörpersystemen kann es aufgrund der Bewegung der Körper zu Kontakten zwischen einzelnen Körpern, aber auch zwischen einem Körper und der Umwelt kommen. Kommen zwei Körper in Kontakt, bildet sich an den sich berührenden Konturen (siehe <a class="link" href="mbsim:Contour">&lt;Contour&gt;</a>) eine Kontaktfläche aus, in der die Kontaktkräfte zwischen den Kontaktpartnern übertragen werden.<br/>
        Idealisiert wird davon ausgegangen, dass nur punktförmige Kontakte existieren; dies ist für eine Vielzahl von Problemstellungen ausreichend. Bei flächenhaften Kontakten muss die Oberfläche durch eine endliche Anzahl von Punkten diskretisiert werden.<br/>
        Es wird zwischen Kontaktkinematik und -kinetik unterschieden. In der Kontaktkinematik wird die relative Lage und Bewegung von zwei Konturen, also potentielle Kontaktpunkte, Abstand, relative Geschwindigkeiten in Konturnormalenrichtung und in der Tangentialebene der Kontur sowie u.U. auch Beschleunigungsgrößen bestimmt. Sie sind Eingangsgrößen der Kontaktkinetik und bestimmen somit anschließend die Kontaktkräfte über konstitutive Gesetze.
        <object class="figure" data="contact.svg">Kinematik einer Kontaktpaarung</object>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="ContactType">
    <xs:complexContent>
      <xs:extension base="LinkType">
        <xs:sequence>
          <xs:element name="connect" maxOccurs="unbounded">
           <xs:annotation>
             <xs:documentation xml:lang="de" xmlns="">
               Bindet zwei Konturen an einen Kontakt.
             </xs:documentation>
           </xs:annotation>
             <xs:complexType>
               <xs:attribute name="ref1" type="ContourReferenceType" use="required"/>
               <xs:attribute name="ref2" type="ContourReferenceType" use="required"/>
               <xs:attribute name="name" type="pv:stringPartialEval" use="optional"/>
             </xs:complexType>
          </xs:element>
          <xs:element name="normalForceLaw" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Definiert das konstitutive Gesetz bez. der Kontaktkräfte auf Beschleunigungsebene in Konturnormalenrichtung (ausreichend für alle funktionellen Gesetze / ausreichend wenn keine Stöße im System auftreten und das System ereignisgesteuert integriert wird).
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:sequence>
                <xs:element ref="GeneralizedForceLaw"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="normalImpactLaw" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Definiert das konstitutive Gesetz bez. der Kontaktkräfte auf Geschwindigkeitsebene in Konturnormalenrichtung (nötig wenn Stöße im System auftreten oder das System mit Timestepping-Verfahren integriert wird).
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:sequence>
                <xs:element ref="GeneralizedImpactLaw"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:sequence minOccurs="0">
            <xs:element name="tangentialForceLaw">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                  Definiert das konstitutive Reibgesetz bez. der Kontaktkräfte auf Beschleunigungssebene (ausreichend für alle funktionellen Gesetze / ausreichend wenn keine Stöße im System auftreten und das System ereignisgesteuert integriert wird).
              </xs:documentation></xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:element ref="FrictionForceLaw"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
            <xs:element name="tangentialImpactLaw" minOccurs="0">
              <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                  Definiert das konstitutive Reibgesetz bez. der Kontaktkräfte auf Geschwindigkeitssebene (nötig wenn Stöße im System auftreten oder das System mit Timestepping-Verfahren integriert wird).
              </xs:documentation></xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:element ref="FrictionImpactLaw"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
          </xs:sequence>
          <xs:element name="searchAllContactPoints" minOccurs="0" type="pv:booleanFullEval">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Definiert, ob initial alle möglichen Kontaktpunkte gesucht werden sollen.
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="initialGuess" minOccurs="0" type="pv:unknownVector">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Anfangswerte für Newton-Löser.
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="enableOpenMBVContactPoints" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Aktiviert die Visualisierung von zwei OpenMBV Koordinatensystemen in den jeweiligen Kontaktpunkten zur Repräsentation der begleitenden Dreibeine <object class="inlineeqn">\left(\boldsymbol{n},\boldsymbol{t}_1,\boldsymbol{t}_2\right)</object> bestehend aus Normale und den beiden Tangenten.<br/>
                Bei geschlossenem Kontakt fallen die Kontaktpunkte zusammen.<br/>
                Bei offenem Kontakt liegen die Kontaktpunkte auf den Konturen und haben minimalen Abstand.
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:group ref="OpenMBVFrameParameters"/>
            </xs:complexType> 
          </xs:element>
          <xs:element name="enableOpenMBVNormalForce" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Wenn angegeben, wird die Kontaktkraft in Normalenrichtung durch einen OpenMBV Pfeil mit Wirkung auf die Kontur des zweiten Körpers in OpenMBV visualisiert.
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:group ref="OpenMBVArrowParameters"/>
            </xs:complexType> 
          </xs:element>
          <xs:element name="enableOpenMBVTangentialForce" minOccurs="0">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Wenn angegeben, wird die Reibkraft durch einen OpenMBV Pfeil mit Wirkung auf die Kontur des zweiten Körpers in OpenMBV visualisiert.
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:group ref="OpenMBVArrowParameters"/>
            </xs:complexType> 
          </xs:element>
        </xs:sequence> 
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="MaxwellContact" substitutionGroup="Contact" type="MaxwellContactType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
      tbd
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="MaxwellContactType">
    <xs:complexContent>
      <xs:extension base="ContactType">
        <xs:sequence>
          <xs:element name="InfluenceFunction">
            <xs:complexType>
              <xs:sequence>
               <xs:element ref="InfluenceFunction" maxOccurs="unbounded"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="Frame" substitutionGroup="Element" type="FrameType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Klasse zur Beschreibung von Koordinatensystemen.
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="FrameType">
    <xs:complexContent>
      <xs:extension base="ElementType">
        <xs:sequence>
          <xs:element name="enableOpenMBV" minOccurs="0">  
            <xs:complexType>
              <xs:group ref="OpenMBVFrameParameters"/>
            </xs:complexType> 
          </xs:element>
        </xs:sequence> 
      </xs:extension>
    </xs:complexContent>
  </xs:complexType> 

  <xs:element name="FixedRelativeFrame" substitutionGroup="Frame" type="FixedRelativeFrameType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Klasse zur Beschreibung von Koordinatensystemen.
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="FixedRelativeFrameType">
    <xs:complexContent>
      <xs:extension base="FrameType">
        <xs:sequence>
          <xs:element name="frameOfReference" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Koordinatensystem, in dem die Positionierung des KOS angegeben wird.<br/>
                Standardmässig "I"-System der Gruppe bzw. "C"-System des RigidBody.
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:attribute name="ref" type="ParentFrameReferenceType" use="required"/>
            </xs:complexType>
          </xs:element>
          <xs:element name="relativePosition" type="pv:lengthVector" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Relative Lage des Koordinatensystems.<br/>
                Vektor von <code>frameOfReference</code> zum Ursprung des neuen KOS dargestellt
                im KOS <code>frameOfReference</code>.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="relativeOrientation" type="pv:rotationMatrix" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Relative Orientierung des Koordinatensystems.<br/>
                Transformationsmatrix vom neuen KOS ins KOS <code>frameOfReference</code>.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType> 

  <xs:element name="Contour" abstract="true" substitutionGroup="Element" type="ContourType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Abstrakte Klasse für Kontaktkonturen.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="ContourType">
    <xs:complexContent>
      <xs:extension base="ElementType">
        <xs:sequence>
          <xs:element name="thickness" type="pv:lengthScalar" minOccurs="0">
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="RigidContour" abstract="true" substitutionGroup="Contour" type="RigidContourType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Abstrakte Klasse für starre Konturen.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="RigidContourType">
    <xs:complexContent>
      <xs:extension base="ContourType">
        <xs:sequence>
          <xs:element name="frameOfReference" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Koordinatensystem, in dem die Positionierung des KOS angegeben wird.<br/>
                Standardmässig "I"-System der Gruppe bzw. "C"-System des RigidBody.
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:attribute name="ref" type="FrameReferenceType" use="required"/>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="Circle" substitutionGroup="RigidContour" type="CircleType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Ebene Kontur eines Circle.<br/>
        Die Kreiskontur liegt normal zur z-Achse des Referenzkoordinatensystems.
        <object class="figure" data="contour_circlehollow.svg">Orientierung einer Cicle-Kontur (hollow-Circle)</object>
        <object class="figure" data="contour_circlesolid.svg">Orientierung einer Cicle-Kontur (solid-Circle)</object>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="CircleType">
    <xs:complexContent>
      <xs:extension base="RigidContourType">
        <xs:sequence>
          <xs:element name="radius" type="pv:lengthScalar">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Definiert den Radius des Kreises.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="solid" type="pv:booleanFullEval" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Definiert, ob der Kreis ein Vollkreis ist.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="enableOpenMBV" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Aktiviert die Visualisierung der Kontur.
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:sequence>
                <xs:element name="diffuseColor" type="pv:nounitVector" minOccurs="0"/>
                <xs:element name="transparency" type="pv:nounitScalar" minOccurs="0"/> 
              </xs:sequence>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="Frustum" substitutionGroup="RigidContour" type="FrustumType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Kontur eines Kegelstumpfes, die über Variation der zu definierenden Größen auch Kegel und Zylinder abdeckt.<br/>
        Die Symmetrieachse fällt mit der y-Achse des Referenzkoordinationsystems zusammen. Zu definierende geometrische Größen sind in der Zeichnung eingetragen.      
        <object class="figure" data="contour_frustum.svg">Orientierung und geometrische Größen einer Frustum-Kontur</object>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="FrustumType">
    <xs:complexContent>
      <xs:extension base="RigidContourType">
        <xs:sequence>
          <xs:element name="baseRadius" type="pv:lengthScalar">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Radius des Fußkreises.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="topRadius" type="pv:lengthScalar">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Radius des Kopfkreises.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="height" type="pv:lengthScalar">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Höhe des Kegelstumpfes.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:choice>
            <xs:element name="solid">
              <xs:annotation>
                <xs:documentation xml:lang="de" xmlns="">
                  Als Kontaktkontur wird die Ausfläche des Kegelstumpfes gewählt.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType/>
            </xs:element>
            <xs:element name="hollow">
              <xs:annotation>
                <xs:documentation xml:lang="de" xmlns="">
                  Als Kontaktkontur wird die Innenfläche des Kegelstumpfes gewählt.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType/>
            </xs:element>
          </xs:choice>
          <xs:element name="enableOpenMBV" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Aktiviert die Visualisierung der Kontur.
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:sequence>
                <xs:element name="diffuseColor" type="pv:nounitVector" minOccurs="0"/>
                <xs:element name="transparency" type="pv:nounitScalar" minOccurs="0"/> 
              </xs:sequence>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="Line" substitutionGroup="RigidContour" type="LineType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Einfache, unendlich ausgedehnte Linienkontur.<br/>
        Die Linie verläuft in Richtung der y-Achse des Referenzkoordinatensystems, die Normale weist in die Richtung der x-Achse des Referenzkoordinatensystems.
        <object class="figure" data="contour_line.svg">Orientierung einer Line-Kontur</object>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="LineType">
    <xs:complexContent>
      <xs:extension base="RigidContourType">
        <xs:sequence>
          <xs:element name="enableOpenMBV" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Aktiviert die Visualisierung der Kontur.
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:sequence>
                <xs:element name="length" type="pv:lengthScalar" minOccurs="0"/>
                <xs:element name="diffuseColor" type="pv:nounitVector" minOccurs="0"/>
                <xs:element name="transparency" type="pv:nounitScalar" minOccurs="0"/> 
              </xs:sequence>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
   </xs:complexContent>
  </xs:complexType>

  <xs:element name="LineSegment" substitutionGroup="RigidContour" type="LineSegmentType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Einfache Linienkontur mit endlicher Ausdehnung.<br/>
        Die Linie verläuft in Richtung der y-Achse des Referenzkoordinatensystems, die Normale weist in die Richtung der x-Achse des Referenzkoordinatensystems.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="LineSegmentType">
    <xs:complexContent>
      <xs:extension base="RigidContourType">
        <xs:sequence>
          <xs:element name="length" type="pv:lengthScalar">
          </xs:element>
          <xs:element name="enableOpenMBV" minOccurs="0">
            <xs:complexType>
              <xs:sequence>
                <xs:element name="diffuseColor" type="pv:nounitVector" minOccurs="0"/>
                <xs:element name="transparency" type="pv:nounitScalar" minOccurs="0"/> 
              </xs:sequence>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="CompoundContour" substitutionGroup="RigidContour" abstract="true"  type="CompoundContourType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Abstrakte Basisklasse für Gruppen von Kontouren.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="CompoundContourType">
    <xs:complexContent>
      <xs:extension base="RigidContourType"/>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="Cuboid" substitutionGroup="CompoundContour" type="CuboidType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Quaderkontour bestehenden aus 8 Punkten, 6 Flächen und 12 Kanten.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="CuboidType">
    <xs:complexContent>
      <xs:extension base="CompoundContourType">
        <xs:sequence>
          <xs:element name="length" type="pv:lengthVector"/>
          <xs:element name="enableOpenMBV" minOccurs="0">
            <xs:complexType>
              <xs:sequence>
                <xs:element name="diffuseColor" type="pv:nounitVector" minOccurs="0"/>
                <xs:element name="transparency" type="pv:nounitScalar" minOccurs="0"/> 
              </xs:sequence>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="Plane" substitutionGroup="RigidContour" type="PlaneType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Unendlich ausgedehnte Ebenenkontur.<br/>
        Die Ebene wird durch die y- und z-Achse des Referenzkoordinatensystems beschrieben.
        <object class="figure" data="contour_plane.svg">Orientierung einer Plane-Kontur</object>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="PlaneType">
    <xs:complexContent>
      <xs:extension base="RigidContourType">
        <xs:sequence>
          <xs:element name="enableOpenMBV" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Aktiviert die Visualisierung der Kontur.
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:sequence>
                <xs:element name="length" type="pv:lengthVector" minOccurs="0"/>
                <xs:element name="diffuseColor" type="pv:nounitVector" minOccurs="0"/>
                <xs:element name="transparency" type="pv:nounitScalar" minOccurs="0"/> 
              </xs:sequence>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="PlaneWithFrustum" substitutionGroup="RigidContour" type="PlaneWithFrustumType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Eine Kontur, die aus einer Ebene und einem Kegelstumpf (Frustum) besteht.<br/>
        Die Ebene wird wie gezeichnet durch die y- und z-Achse des Referenzkoordinatensystems aufgespannt, die Rotationsachse des Kegelstumpfes ist die x-Achse des Referenzkoordinatensystems. Für eine Kegelstumpf-Höhe h&gt;0 erstreckt sich die Kegelstumpfkontur in Richtung der positiven x-Achse des Referenzkoordinatensystems. <object class="inlineeqn">\rho</object> ist der Radius der Verrundung zwischen Ebene und Kegelstumpf und am Kopf des Kegelstumpfes.
        <object class="figure" data="contour_planewithfrustum.svg">Orientierung einer PlaneWithFrustum-Kontur</object>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="PlaneWithFrustumType">
    <xs:complexContent>
      <xs:extension base="RigidContourType">
        <xs:sequence>
          <xs:element name="baseRadius" type="pv:lengthScalar">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Radius des Fußkreises.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="topRadius" type="pv:lengthScalar">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Radius des Kopfkreises.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="height" type="pv:lengthScalar">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Höhe des Kegelstumpfes.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="roundingRadius" type="pv:lengthScalar">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Verrundungsradius, einmal zwischen Ebene und Kegelstumpf und einmal zwischen Kegelstumpf und Deckfläche des Kegelstumpfes (wie gezeichnet).
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="enableOpenMBV" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Aktiviert die Visualisierung der Kontur.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="Point" substitutionGroup="RigidContour" type="PointType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Kontur eines einzelnen Punktes.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="PointType">
    <xs:complexContent>
      <xs:extension base="RigidContourType">
        <xs:sequence>
          <xs:element name="enableOpenMBV" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Aktiviert die Visualisierung der Kontur.
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:sequence>
                <xs:element name="size" type="pv:lengthScalar" minOccurs="0"/>
                <xs:element name="diffuseColor" type="pv:nounitVector" minOccurs="0"/>
                <xs:element name="transparency" type="pv:nounitScalar" minOccurs="0"/> 
              </xs:sequence>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="Sphere" substitutionGroup="RigidContour" type="SphereType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Kontur einer Kugel.<br/>
        r gibt den Radius der Kugel an
        <object class="figure" data="contour_sphere.svg">Geometrie einer Sphere-Kontur</object>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="SphereType">
    <xs:complexContent>
      <xs:extension base="RigidContourType">
        <xs:sequence>
          <xs:element name="radius" type="pv:lengthScalar">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Radius der Kugel.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="enableOpenMBV" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Aktiviert die Visualisierung der Kontur.
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:sequence>
                <xs:element name="diffuseColor" type="pv:nounitVector" minOccurs="0"/>
                <xs:element name="transparency" type="pv:nounitScalar" minOccurs="0"/> 
              </xs:sequence>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="ContourContinuum" substitutionGroup="Contour" abstract="true" type="ContourContinuumType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Abstrakte Klasse zur Beschreibung kontinuierlicher Konturen.<br/>
        Die Konturen werden in Abhängigkeit eines Parameters <object class="inlineeqn">\alpha \, \left(\alpha_{Start} \leq \alpha \leq \alpha_{End} \right)</object> beschrieben. Für eine effiziente Abstandsberechnung müssen vom Benutzer zusätzliche Stützstellen angegeben werden, anhand derer eine erste Abschätzung des Kontaktbereiches erfolgt.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="ContourContinuumType">
    <xs:complexContent>
      <xs:extension base="ContourType">
        <xs:sequence>
          <xs:element name="alphaStart" type="pv:nounitScalar">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Startwert des Laufparameters <object class="inlineeqn">\alpha</object>.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="alphaEnd" type="pv:nounitScalar">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Endwert des Laufparameters <object class="inlineeqn">\alpha</object>.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="nodes" type="pv:nounitScalar">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Stützstellen.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="Contour1s" substitutionGroup="ContourContinuum" abstract="true" type="Contour1sType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Abstrakte Klasse zur Beschreibung beliebiger Konturen, die durch eine räumliche Kurve beschrieben werden können. 
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="Contour1sType">
    <xs:complexContent>
      <xs:extension base="ContourContinuumType">
        <xs:sequence>
          <xs:element name="diameter" type="pv:lengthScalar">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Durchmesser der Kurvenkontur.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="PlanarContour" substitutionGroup="RigidContour" type="PlanarContourType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Kurvenkontur, bei der die Parametrisierung analytisch durch einen funktionalen Zusammenhang beschrieben werden kann:
        <object class="eqn">
          <![CDATA[\mathbf{f}:\,\mathbf{R}\rightarrow\mathbf{R}^3;\quad\alpha\mapsto\mathbf{f} \left(\alpha\right)=
          \left(\begin{array}{c}
          f_x\left(\alpha\right) \\
          f_y\left(\alpha\right) \\
          f_z\left(\alpha\right)
          \end{array}\right)]]>
        </object>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="PlanarContourType">
    <xs:complexContent>
      <xs:extension base="RigidContourType">
        <xs:sequence>
          <xs:element name="nodes" type="pv:nounitVector">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                tbd
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="contourFunction">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Beschreibung der Kontur.
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:sequence>
                <xs:element ref="Function"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="open" minOccurs="0" type="pv:booleanFullEval">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Definiert, ob die Kontur offen ist.
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="enableOpenMBV" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Aktiviert die Visualisierung der Kontur.
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:sequence>
                <xs:element name="nodes" type="pv:nounitVector" minOccurs="0"/>
                <xs:element name="diffuseColor" type="pv:nounitVector" minOccurs="0"/>
                <xs:element name="transparency" type="pv:nounitScalar" minOccurs="0"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="SpatialContour" substitutionGroup="RigidContour" type="SpatialContourType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Kurvenkontur, bei der die Parametrisierung analytisch durch einen funktionalen Zusammenhang beschrieben werden kann:
        <object class="eqn">
          <![CDATA[\mathbf{f}:\,\mathbf{R}\rightarrow\mathbf{R}^3;\quad\alpha\mapsto\mathbf{f} \left(\alpha\right)=
          \left(\begin{array}{c}
          f_x\left(\alpha\right) \\
          f_y\left(\alpha\right) \\
          f_z\left(\alpha\right)
          \end{array}\right)]]>
        </object>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="SpatialContourType">
    <xs:complexContent>
      <xs:extension base="RigidContourType">
        <xs:sequence>
          <xs:element name="etaNodes" type="pv:nounitVector">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                tbd
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="xiNodes" type="pv:nounitVector">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                tbd
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="contourFunction">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Beschreibung der Kontur.
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:sequence>
                <xs:element ref="Function"/>
              </xs:sequence>
            </xs:complexType> 
          </xs:element>
          <xs:element name="open" minOccurs="0" type="pv:booleanFullEval">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Definiert, ob die Kontur offen ist.
            </xs:documentation></xs:annotation>
          </xs:element>
          <xs:element name="enableOpenMBV" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Aktiviert die Visualisierung der Kontur.
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:sequence>
                <xs:element name="etaNodes" type="pv:nounitVector" minOccurs="0"/>
                <xs:element name="xiNodes" type="pv:nounitVector" minOccurs="0"/>
                <xs:element name="diffuseColor" type="pv:nounitVector" minOccurs="0"/>
                <xs:element name="transparency" type="pv:nounitScalar" minOccurs="0"/> 
              </xs:sequence>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="GeneralizedForceLaw" abstract="true" type="GeneralizedForceLawType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Abstrakte Oberklasse zur Beschreibung konstitutiver Gesetze auf Beschleunigungsebene.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="GeneralizedForceLawType"/>

  <xs:element name="BilateralConstraint" substitutionGroup="GeneralizedForceLaw" type="BilateralConstraintType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Konstitutives Gesetz zur Beschreibung einer mengenwertigen zweiseitigen Bindung auf Beschleunigungsebene. 
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="BilateralConstraintType">
    <xs:complexContent>
      <xs:extension base="GeneralizedForceLawType"/>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="UnilateralConstraint" substitutionGroup="GeneralizedForceLaw" type="UnilateralConstraintType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Konstitutives Gesetz auf Beschleunigunssebene zur Beschreibung einer mengenwertigen einseitigen Bindung. 
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="UnilateralConstraintType">
    <xs:complexContent>
      <xs:extension base="GeneralizedForceLawType"/>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="GeneralizedImpactLaw" abstract="true" type="GeneralizedImpactLawType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Abstrakte Oberklasse zur Beschreibung konstitutiver Gesetze auf Geschwindigkeitsebene.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="GeneralizedImpactLawType"/>

  <xs:element name="BilateralImpact" substitutionGroup="GeneralizedImpactLaw" type="BilateralImpactType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Konstitutives Gesetz auf Geschwindigkeitsebene zur Beschreibung einer mengenwertigen zweiseitigen Bindung. 
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="BilateralImpactType">
    <xs:complexContent>
      <xs:extension base="GeneralizedImpactLawType"/>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="UnilateralNewtonImpact" substitutionGroup="GeneralizedImpactLaw" type="UnilateralNewtonImpactType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Konstitutives Gesetz auf Geschwindigkeitsebene zur Beschreibung eines Newton-Stoßes. 
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="UnilateralNewtonImpactType">
    <xs:complexContent>
      <xs:extension base="GeneralizedImpactLawType">
        <xs:sequence>
          <xs:element name="restitutionCoefficient" type="pv:nounitScalar">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Stoßzahl. Wert zwischen 0 (plastisch) und 1 (vollelastisch).
              </xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence> 
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="RegularizedBilateralConstraint" substitutionGroup="GeneralizedForceLaw" type="RegularizedBilateralConstraintType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Konstitutives Gesetz zur Beschreibung einer regularisierten zweiseitigen Bindung. 
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="RegularizedBilateralConstraintType">
    <xs:complexContent>
      <xs:extension base="GeneralizedForceLawType">
        <xs:sequence>
          <xs:element name="forceFunction">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Konstitutive zweiparametrige Funktion <object class="inlineeqn">\lambda=\lambda\left(g,\dot{g}\right)</object> zur Auswertung der Reaktion basierend auf relativer Distanz g und Geschwindigkeit <object class="inlineeqn">\dot{g}</object>.  
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:sequence>
                <xs:element ref="Function"/>
              </xs:sequence>
            </xs:complexType> 
          </xs:element>
        </xs:sequence> 
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="RegularizedUnilateralConstraint" substitutionGroup="GeneralizedForceLaw" type="RegularizedUnilateralConstraintType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Konstitutives Gesetz zur Beschreibung einer regularisierten einseitigen Bindung. 
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="RegularizedUnilateralConstraintType">
    <xs:complexContent>
      <xs:extension base="GeneralizedForceLawType">
        <xs:sequence>
          <xs:element name="forceFunction">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Konstitutive zweiparametrige Funktion <object class="inlineeqn">\lambda=\lambda\left(g,\dot{g}\right)</object> zur Auswertung der Reaktion basierend auf relativer Distanz <object class="inlineeqn">g</object> und Geschwindigkeit <object class="inlineeqn">\dot{g}</object>.  
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:sequence>
                <xs:element ref="Function"/>
              </xs:sequence>
            </xs:complexType> 
          </xs:element>
        </xs:sequence> 
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="FrictionForceLaw" abstract="true" type="FrictionForceLawType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Abstrakte Oberklasse zur Beschreibung von Reibgesetzen auf Beschleunigungsebene. 
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="FrictionForceLawType"/>

  <xs:element name="RegularizedPlanarFriction" substitutionGroup="FrictionForceLaw" type="RegularizedPlanarFrictionType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Definiert beliebige ebene regularisierte und damit funktionale Reibgesetze. 
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="RegularizedPlanarFrictionType">
    <xs:complexContent>
      <xs:extension base="FrictionForceLawType">
        <xs:sequence>
          <xs:element name="frictionForceFunction">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Reibgesetze der Form <object class="inlineeqn">\boldsymbol{F}_R=\boldsymbol{F}_R\left(\dot{\boldsymbol{g}}_T,\left\|\boldsymbol{F}_N\right\|\right)</object> basierend auf tangentialer relativer Geschwindigkeit und Betrag der Normalkraft
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:sequence>
                <xs:element ref="Function"/>
              </xs:sequence>
            </xs:complexType> 
          </xs:element>
        </xs:sequence> 
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="RegularizedSpatialFriction" substitutionGroup="FrictionForceLaw" type="RegularizedSpatialFrictionType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Definiert beliebige räumliche regularisierte und damit funktionale Reibgesetze. 
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="RegularizedSpatialFrictionType">
    <xs:complexContent>
      <xs:extension base="FrictionForceLawType">
        <xs:sequence>
          <xs:element name="frictionForceFunction">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Reibgesetze der Form <object class="inlineeqn">\boldsymbol{F}_R=\boldsymbol{F}_R\left(\dot{\boldsymbol{g}}_T,\left\|\boldsymbol{F}_N\right\|\right)</object> basierend auf tangentialer relativer Geschwindigkeit und Betrag der Normalkraft
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:sequence>
                <xs:element ref="Function"/>
              </xs:sequence>
            </xs:complexType> 
          </xs:element>
        </xs:sequence> 
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="SpatialCoulombFriction" substitutionGroup="FrictionForceLaw" type="SpatialCoulombFrictionType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Definiert räumliche Coulomb-Reibung auf Beschleunigungsebene. 
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="SpatialCoulombFrictionType">
    <xs:complexContent>
      <xs:extension base="FrictionForceLawType">
        <xs:sequence>
          <xs:element name="frictionCoefficient" type="pv:nounitScalar">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Konstanter Reibkoeffizient. 
            </xs:documentation></xs:annotation>
          </xs:element>
        </xs:sequence> 
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="PlanarCoulombFriction" substitutionGroup="FrictionForceLaw" type="PlanarCoulombFrictionType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Definiert ebene Coulomb-Reibung auf Beschleunigungsebene. 
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="PlanarCoulombFrictionType">
    <xs:complexContent>
      <xs:extension base="FrictionForceLawType">
        <xs:sequence>
          <xs:element name="frictionCoefficient" type="pv:nounitScalar">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Konstanter Reibkoeffizient. 
            </xs:documentation></xs:annotation>
          </xs:element>
        </xs:sequence> 
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="SpatialStribeckFriction" substitutionGroup="FrictionForceLaw" type="SpatialStribeckFrictionType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Definiert räumliche Stribeck-Reibung auf Beschleunigungsebene.
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="SpatialStribeckFrictionType">
    <xs:complexContent>
      <xs:extension base="FrictionForceLawType">
        <xs:sequence>
          <xs:element name="frictionFunction">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Definiert den Reibkoeffizienten in Abhängigkeit der Relativgeschwindigkeit.
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:sequence>
                <xs:element ref="Function"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="PlanarStribeckFriction" substitutionGroup="FrictionForceLaw" type="PlanarStribeckFrictionType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Definiert ebene Stribeck-Reibung auf Beschleunigungsebene.
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="PlanarStribeckFrictionType">
    <xs:complexContent>
      <xs:extension base="FrictionForceLawType">
        <xs:sequence>
          <xs:element name="frictionFunction">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Definiert den Reibkoeffizienten in Abhängigkeit der Relativgeschwindigkeit.
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:sequence>
                <xs:element ref="Function"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="FrictionImpactLaw" abstract="true" type="FrictionImpactLawType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Abstrakte Oberklasse zur Beschreibung von Reibgesetzen auf Geschwindigkeitsebene. 
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="FrictionImpactLawType"/>

  <xs:element name="SpatialCoulombImpact" substitutionGroup="FrictionImpactLaw" type="SpatialCoulombImpactType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Definiert räumliche Coulomb-Reibung auf Geschwindigkeitssebene. 
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="SpatialCoulombImpactType">
    <xs:complexContent>
      <xs:extension base="FrictionImpactLawType">
        <xs:sequence>
          <xs:element name="frictionCoefficient" type="pv:nounitScalar">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Konstanter Reibkoeffizient. 
            </xs:documentation></xs:annotation>
          </xs:element>
        </xs:sequence> 
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="PlanarCoulombImpact" substitutionGroup="FrictionImpactLaw" type="PlanarCoulombImpactType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Definiert ebene Coulomb-Reibung auf Geschwindigkeitssebene. 
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="PlanarCoulombImpactType">
    <xs:complexContent>
      <xs:extension base="FrictionImpactLawType">
        <xs:sequence>
          <xs:element name="frictionCoefficient" type="pv:nounitScalar">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Konstanter Reibkoeffizient. 
            </xs:documentation></xs:annotation>
          </xs:element>
        </xs:sequence> 
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="SpatialStribeckImpact" substitutionGroup="FrictionImpactLaw" type="SpatialStribeckImpactType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Definiert räumliche Stribeck-Reibung auf Geschwindigkeitssebene.
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="SpatialStribeckImpactType">
    <xs:complexContent>
      <xs:extension base="FrictionImpactLawType">
        <xs:sequence>
          <xs:element name="frictionFunction">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Definiert den Reibkoeffizienten in Abhängigkeit der Relativgeschwindigkeit.
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:sequence>
                <xs:element ref="Function"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="PlanarStribeckImpact" substitutionGroup="FrictionImpactLaw" type="PlanarStribeckImpactType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        Definiert ebene Stribeck-Reibung auf Geschwindigkeitssebene.
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="PlanarStribeckImpactType">
    <xs:complexContent>
      <xs:extension base="FrictionImpactLawType">
        <xs:sequence>
          <xs:element name="frictionFunction">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Definiert den Reibkoeffizienten in Abhängigkeit der Relativgeschwindigkeit.
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:sequence>
                <xs:element ref="Function"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="Function" abstract="true" substitutionGroup="Element" type="FunctionType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Abstrakte Klasse von Funktionen mit beliebig vielen Parametern.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="FunctionType">
    <xs:complexContent>
      <xs:extension base="ElementType"/>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="TranslationAlongXAxis" substitutionGroup="Function" type="TranslationAlongXAxisType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
      tbd
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="TranslationAlongXAxisType">
    <xs:complexContent>
      <xs:extension base="FunctionType"/>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="TranslationAlongYAxis" substitutionGroup="Function" type="TranslationAlongYAxisType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
      tbd
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="TranslationAlongYAxisType">
    <xs:complexContent>
      <xs:extension base="FunctionType"/>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="TranslationAlongZAxis" substitutionGroup="Function" type="TranslationAlongZAxisType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
      tbd
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="TranslationAlongZAxisType">
    <xs:complexContent>
      <xs:extension base="FunctionType"/>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="TranslationAlongAxesXY" substitutionGroup="Function" type="TranslationAlongAxesXYType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
      tbd
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="TranslationAlongAxesXYType">
    <xs:complexContent>
      <xs:extension base="FunctionType"/>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="TranslationAlongAxesYZ" substitutionGroup="Function" type="TranslationAlongAxesYZType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
      tbd
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="TranslationAlongAxesYZType">
    <xs:complexContent>
      <xs:extension base="FunctionType"/>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="TranslationAlongAxesXZ" substitutionGroup="Function" type="TranslationAlongAxesXZType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
      tbd
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="TranslationAlongAxesXZType">
    <xs:complexContent>
      <xs:extension base="FunctionType"/>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="TranslationAlongAxesXYZ" substitutionGroup="Function" type="TranslationAlongAxesXYZType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
      tbd
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="TranslationAlongAxesXYZType">
    <xs:complexContent>
      <xs:extension base="FunctionType"/>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="TranslationAlongFixedAxis" substitutionGroup="Function" type="TranslationAlongFixedAxisType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
      tbd
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="TranslationAlongFixedAxisType">
    <xs:complexContent>
      <xs:extension base="FunctionType">
        <xs:sequence>
          <xs:element name="axisOfTranslation" type="pv:nounitVector">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
              tbd
              </xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence> 
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="LinearTranslation" substitutionGroup="Function" type="LinearTranslationType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
      tbd
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="LinearTranslationType">
    <xs:complexContent>
      <xs:extension base="FunctionType">
        <xs:sequence>
          <xs:element name="translationVectors" type="pv:unknownMatrix">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
              tbd
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="offset" type="pv:unknownVector" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
              tbd
              </xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence> 
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="RotationAboutXAxis" substitutionGroup="Function" type="RotationAboutXAxisType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
      tbd
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="RotationAboutXAxisType">
    <xs:complexContent>
      <xs:extension base="FunctionType"/>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="RotationAboutYAxis" substitutionGroup="Function" type="RotationAboutYAxisType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
      tbd
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="RotationAboutYAxisType">
    <xs:complexContent>
      <xs:extension base="FunctionType"/>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="RotationAboutZAxis" substitutionGroup="Function" type="RotationAboutZAxisType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
      tbd
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="RotationAboutZAxisType">
    <xs:complexContent>
      <xs:extension base="FunctionType"/>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="RotationAboutFixedAxis" substitutionGroup="Function" type="RotationAboutFixedAxisType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
      tbd
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="RotationAboutFixedAxisType">
    <xs:complexContent>
      <xs:extension base="FunctionType">
        <xs:sequence>
          <xs:element name="axisOfRotation" type="pv:nounitVector">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
              tbd
              </xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence> 
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="RotationAboutAxesXY" substitutionGroup="Function" type="RotationAboutAxesXYType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
      tbd
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="RotationAboutAxesXYType">
    <xs:complexContent>
      <xs:extension base="FunctionType"/>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="RotationAboutAxesYZ" substitutionGroup="Function" type="RotationAboutAxesYZType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
      tbd
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="RotationAboutAxesYZType">
    <xs:complexContent>
      <xs:extension base="FunctionType"/>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="RotationAboutAxesXZ" substitutionGroup="Function" type="RotationAboutAxesXZType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
      tbd
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="RotationAboutAxesXZType">
    <xs:complexContent>
      <xs:extension base="FunctionType"/>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="RotationAboutAxesXYZ" substitutionGroup="Function" type="RotationAboutAxesXYZType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
      tbd
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="RotationAboutAxesXYZType">
    <xs:complexContent>
      <xs:extension base="FunctionType"/>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="RotationAboutAxesZXZ" substitutionGroup="Function" type="RotationAboutAxesZXZType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
      tbd
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="RotationAboutAxesZXZType">
    <xs:complexContent>
      <xs:extension base="FunctionType"/>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="RotationAboutAxesZYX" substitutionGroup="Function" type="RotationAboutAxesZYXType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
      tbd
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="RotationAboutAxesZYXType">
    <xs:complexContent>
      <xs:extension base="FunctionType"/>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="SymbolicFunction" substitutionGroup="Function" type="SymbolicFunctionType"/>
  <!-- This type is just a hack to enable the mixed="true" attribute in SymbolicFunctionType.
       Maybe this work only due to a bug in xerces-c ???!!! but it works here   :-O   :-(   :-)   -->
  <xs:complexType name="FunctionMixedType" mixed="true">
    <xs:complexContent>
      <xs:extension base="FunctionType"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="SymbolicFunctionType" mixed="true">
    <xs:complexContent>
      <xs:extension base="FunctionMixedType">
        <xs:group ref="pv:symbolicFunctionXMLElement" minOccurs="0"/>
        <!-- A symbolic function has at least one parameter => arg1 is required.
             argXDim is optional since this is interpreted as "1" (scalar) if missing.
             arg2 (and higher) are optional to define with this XML element all symbolic functions at ones.
             If argXNr is not from 1 to N => error. -->
        <xs:attribute name="arg1" use="required" type="pv:symbolicFunctionArgNameType"/>
        <xs:attribute name="arg1Dim" use="optional" default="1" type="pv:symbolicFunctionArgDimType"/>
        <xs:attribute name="arg1Nr" type="xs:integer" fixed="1"/>
        <xs:attribute name="arg2" use="optional" type="pv:symbolicFunctionArgNameType"/>
        <xs:attribute name="arg2Dim" use="optional" default="1" type="pv:symbolicFunctionArgDimType"/>
        <xs:attribute name="arg2Nr" type="xs:integer" fixed="2"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="IdentityFunction" substitutionGroup="Function" type="IdentityFunctionType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Identische Abbildung: <object class="inlineeqn">\boldsymbol{y}=\boldsymbol{y}</object>.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="IdentityFunctionType">
    <xs:complexContent>
      <xs:extension base="FunctionType">
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="ConstantFunction" substitutionGroup="Function" type="ConstantFunctionType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Konstanter Funktionswert: <object class="inlineeqn">\boldsymbol{y}=\boldsymbol{c}</object>.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="ConstantFunctionType">
    <xs:complexContent>
      <xs:extension base="FunctionType">
        <xs:sequence>
          <xs:element name="a0" type="pv:unknownScalar">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Konstanter Funktionswert: <object class="inlineeqn">\boldsymbol{y}=\boldsymbol{c}</object>.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence> 
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="LinearFunction" substitutionGroup="Function" type="LinearFunctionType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
      tbd
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="LinearFunctionType">
    <xs:complexContent>
      <xs:extension base="FunctionType">
        <xs:sequence>
          <xs:element name="a0" type="pv:unknownScalar" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
              tbd
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="a1" type="pv:unknownScalar">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
              tbd
              </xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence> 
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="QuadraticFunction" substitutionGroup="Function" type="QuadraticFunctionType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Quadratische Funktion mit <object class="inlineeqn">\boldsymbol{y}= \boldsymbol{a}_{0} + \boldsymbol{a}_{1} \, x + \boldsymbol{a}_{2} \, x^2</object>.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="QuadraticFunctionType">
    <xs:complexContent>
      <xs:extension base="FunctionType">
        <xs:sequence>
          <xs:element name="a0" type="pv:unknownScalar" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Faktor <object class="inlineeqn">\boldsymbol{a}_0</object>.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="a1" type="pv:unknownScalar" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Faktor <object class="inlineeqn">\boldsymbol{a}_1</object>.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="a2" type="pv:unknownScalar">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Faktor <object class="inlineeqn">\boldsymbol{a}_2</object>.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence> 
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="PolynomFunction" substitutionGroup="Function" type="PolynomFunctionType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Polynomfunktion <object class="inlineeqn">y=\sum_{i=0}^n a_i \, x^i</object>.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="PolynomFunctionType">
    <xs:complexContent>
      <xs:extension base="FunctionType">
        <xs:sequence>
          <xs:element name="coefficients" type="pv:unknownVector">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Vektor mit den Koeffizienten <object class="inlineeqn">a_i</object>.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="SinusoidalFunction" substitutionGroup="Function" type="SinusoidalFunctionType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Vektorwertige periodische Funktion mit <object class="inlineeqn">y_i= A_i \, \sin \left( 2 \, \pi \, f_i \, x + \varphi_i \right) + o_i</object>.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="SinusoidalFunctionType">
    <xs:complexContent>
      <xs:extension base="FunctionType">
        <xs:sequence>
          <xs:element name="amplitude" type="pv:unknownScalar">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Amplitude <object class="inlineeqn">A</object>.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="frequency" type="pv:unknownScalar">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Frequenz <object class="inlineeqn">f</object>.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="phase" type="pv:angleScalar" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Phasenwinkel <object class="inlineeqn">\varphi</object>.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="offset" type="pv:unknownScalar" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Offset <object class="inlineeqn">o</object>.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence> 
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="StepFunction" substitutionGroup="Function" type="StepFunctionType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Vektorwertige Sprungfunktion <object class="inlineeqn">y_i=\begin{cases}c_i\ \text{bei}\ t\geq t_i\\0\ \text{bei}\ t\leq t_i\end{cases}</object>.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="StepFunctionType">
    <xs:complexContent>
      <xs:extension base="FunctionType">
        <xs:sequence>
          <xs:element name="time" type="pv:unknownScalar">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Vektor der Sprungzeitpunkte <object class="inlineeqn">\boldsymbol{t}</object>.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="size" type="pv:unknownScalar">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Vektor der zugehörigen Funktionswerte <object class="inlineeqn">\boldsymbol{c}</object>.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence> 
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="AbsoluteValueFunction" substitutionGroup="Function" type="AbsoluteValueFunctionType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
      tbd
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="AbsoluteValueFunctionType">
    <xs:complexContent>
      <xs:extension base="FunctionType"/>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="ModuloFunction" substitutionGroup="Function" type="ModuloFunctionType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
      tbd
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="ModuloFunctionType">
    <xs:complexContent>
      <xs:extension base="FunctionType">
        <xs:sequence>
          <xs:element name="denominator" type="pv:unknownScalar">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Vektor der zugehörigen Funktionswerte <object class="inlineeqn">\boldsymbol{c}</object>.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence> 
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="SignumFunction" substitutionGroup="Function" type="SignumFunctionType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
      tbd
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="SignumFunctionType">
    <xs:complexContent>
      <xs:extension base="FunctionType"/>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="BoundedFunction" substitutionGroup="Function" type="BoundedFunctionType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
      tbd
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="BoundedFunctionType">
    <xs:complexContent>
      <xs:extension base="FunctionType">
        <xs:sequence>
          <xs:element name="lowerBound" minOccurs="0" type="pv:unknownScalar">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Untere Grenze.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="upperBound" minOccurs="0" type="pv:unknownScalar">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Obere Grenze.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence> 
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="VectorValuedFunction" substitutionGroup="Function" type="VectorValuedFunctionType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
      tbd
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="VectorValuedFunctionType">
    <xs:complexContent>
      <xs:extension base="FunctionType">
        <xs:sequence>
          <xs:element name="components">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                tbd
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:sequence minOccurs="0" maxOccurs="unbounded">
                <xs:element ref="Function"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="CompositeFunction" substitutionGroup="Function" type="CompositeFunctionType"/>
  <xs:complexType name="CompositeFunctionType">
    <xs:complexContent>
      <xs:extension base="FunctionType">
        <xs:sequence>
          <xs:element name="outerFunction">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
            tbd
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:sequence>
                <xs:element ref="Function"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="innerFunction">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
            tbd
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:sequence>
                <xs:element ref="Function"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="BinaryCompositeFunction" substitutionGroup="Function" type="BinaryCompositeFunctionType"/>
  <xs:complexType name="BinaryCompositeFunctionType">
    <xs:complexContent>
      <xs:extension base="FunctionType">
        <xs:sequence>
          <xs:element name="outerFunction">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
            tbd
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:sequence>
                <xs:element ref="Function"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="firstInnerFunction">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
            tbd
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:sequence>
                <xs:element ref="Function"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="secondInnerFunction">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
            tbd
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:sequence>
                <xs:element ref="Function"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="LimitedFunction" type="LimitedFunctionType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
    tbd
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="LimitedFunctionType">
    <xs:sequence>
      <xs:element name="function">
        <xs:annotation><xs:documentation xml:lang="de" xmlns="">
        tbd
        </xs:documentation></xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="Function"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
      <xs:element name="limit" type="pv:unknownScalar">
        <xs:annotation>
          <xs:documentation xml:lang="de" xmlns="">
          tbd
          </xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:sequence>
  </xs:complexType> 

  <xs:element name="PiecewiseDefinedFunction" substitutionGroup="Function" type="PiecewiseDefinedFunctionType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
      tbd
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="PiecewiseDefinedFunctionType">
    <xs:complexContent>
      <xs:extension base="FunctionType">
        <xs:sequence>
          <xs:element name="limitedFunctions">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                tbd
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:sequence minOccurs="1" maxOccurs="unbounded">
                <xs:element ref="LimitedFunction"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="shiftAbscissa" type="pv:booleanFullEval" minOccurs="0"/>
          <xs:element name="shiftOrdinate" type="pv:booleanFullEval" minOccurs="0"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="TabularFunction" substitutionGroup="Function" type="TabularFunctionType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Vektorwertige Funktion generiert aus linearer Interpolation von Tabellenwerten <object class="inlineeqn">\boldsymbol{y}=\begin{cases}\boldsymbol{c_0}\ \text{bei}\ x\leq x_0\\\frac{\boldsymbol{c}_{i+1}-\boldsymbol{c}_{i}}{x_{i+1}-x_i}\left(x-x_i\right)\ \text{bei}\ x_i \leq x\leq x_{i+1}\ \text{und}\ 0\leq i\leq n-1\\\boldsymbol{c_n}\ \text{bei}\ x_n \leq x\end{cases}</object>.<br/>
        Zum einen ist es möglich, die Parameter <object class="inlineeqn">\mathbf{x}</object> als (Spalten-)Vektor und die Punkte <object class="inlineeqn">\mathbf{c}</object> -zeilenweise in einer Matrix angeordnet- in getrennten Matrizen vorzugeben, zum anderen ist deren Angabe auch in einer Matrix möglich.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="TabularFunctionType">
    <xs:complexContent>
      <xs:extension base="FunctionType">
        <xs:sequence>
          <xs:choice>
            <xs:sequence>
              <xs:element name="x" type="pv:unknownVector">
                <xs:annotation>
                  <xs:documentation xml:lang="de" xmlns="">
                    Parameter-(Spalten-)vektor der zu interpolierenden Punkte.
                  </xs:documentation>
                </xs:annotation>
              </xs:element>
              <xs:element name="y" type="pv:unknownMatrix">
                <xs:annotation>
                  <xs:documentation xml:lang="de" xmlns="">
                    Zeilenweises Arrangement der zu interpolierenden Punkte in einer Matrix.
                  </xs:documentation>
                </xs:annotation>
              </xs:element>
            </xs:sequence>
            <xs:element name="xy" type="pv:unknownMatrix">
              <xs:annotation>
                <xs:documentation xml:lang="de" xmlns="">
                  Parameter-(Spalten-)vektor und die zu interpolierenden Punkte sind in einer Matrix zusammengefasst.
                </xs:documentation>
              </xs:annotation>
            </xs:element>
          </xs:choice>
        </xs:sequence> 
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="TwoDimensionalTabularFunction" substitutionGroup="Function" type="TwoDimensionalTabularFunctionType">
    <xs:annotation>
      <xs:documentation  xml:lang="de" xmlns="">
        Lineare Interpolation einer Funktion <object class="inlineeqn">z=f(x, y)</object>, die als Kennfeld hinterlegt ist.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="TwoDimensionalTabularFunctionType">
    <xs:complexContent>
      <xs:extension base="FunctionType">
        <xs:sequence>
          <xs:choice>
            <xs:sequence>
              <xs:element name="x" type="pv:unknownVector">
                <xs:annotation>
                  <xs:documentation xml:lang="de" xmlns="">
                    x-Werte. Die Werte müssen streng mononton steigend sein.
                  </xs:documentation>
                </xs:annotation>
              </xs:element>
              <xs:element name="y" type="pv:unknownVector">
                <xs:annotation>
                  <xs:documentation xml:lang="de" xmlns="">
                    y-Werte. Die Werte müssen streng mononton steigend sein.
                  </xs:documentation>
                </xs:annotation>
              </xs:element>
              <xs:element name="z" type="pv:unknownMatrix">
                <xs:annotation>
                  <xs:documentation xml:lang="de" xmlns="">
                    z-Werte. Die Anzahl der Spalten der Matrix muss mit der Größe des x-Vektors und die Anzahl der Zeilen der Matrix muss mit der Größe des y-Vektors übereinstimmen.
                  </xs:documentation>
                </xs:annotation>
              </xs:element>
            </xs:sequence>
            <xs:element name="xyz" type="pv:unknownMatrix">
              <xs:annotation>
                <xs:documentation xml:lang="de" xmlns="">
                  Die Stützstellen und die Stützwerte sind in einer Matrix zusammengefasst.
                </xs:documentation>
              </xs:annotation>
            </xs:element>
          </xs:choice>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="PiecewisePolynomFunction" substitutionGroup="Function" type="PiecewisePolynomFunctionType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Klasse zur Definition von vektorwertigen, univariaten Funktionen über Spline-Interpolation.<br/>
        Die zu interpolierenden Punkte <object class="inlineeqn">\mathbf{Y}_i</object> werden dabei bez. des Spline mit der skalaren Größe <object class="inlineeqn">x_i</object> parametrisiert.<br/>
        Zum einen ist es möglich, die Parameter <object class="inlineeqn">\mathbf{x}</object> als (Spalten-)Vektor und die Punkte <object class="inlineeqn">\mathbf{Y}</object> -zeilenweise in einer Matrix angeordnet- in getrennten Matrizen vorzugeben, zum anderen ist deren Angabe auch in einer Matrix möglich.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="PiecewisePolynomFunctionType">
    <xs:complexContent>
      <xs:extension base="FunctionType">
        <xs:sequence>
          <xs:choice>
            <xs:sequence>
              <xs:element name="x" type="pv:unknownVector">
                <xs:annotation>
                  <xs:documentation xml:lang="de" xmlns="">
                    Parameter-(Spalten-)vektor der zu interpolierenden Punkte.
                  </xs:documentation>
                </xs:annotation>
              </xs:element>
              <xs:element name="y" type="pv:unknownMatrix">
                <xs:annotation>
                  <xs:documentation xml:lang="de" xmlns="">
                    Zeilenweises Arrangement der zu interpolierenden Punkte in einer Matrix.
                  </xs:documentation>
                </xs:annotation>
              </xs:element>
            </xs:sequence>
            <xs:element name="xy" type="pv:unknownMatrix">
              <xs:annotation>
                <xs:documentation xml:lang="de" xmlns="">
                  Parameter-(Spalten-)vektor und die zu interpolierenden Punkte sind in einer Matrix zusammengefasst.
                </xs:documentation>
              </xs:annotation>
            </xs:element>
          </xs:choice>
          <xs:element name="interpolationMethod" minOccurs="0" type="pv:stringFullEval">
              <xs:annotation>
                <xs:documentation xml:lang="de" xmlns="">
                  <dl>
                    <dt>"cSplinePeriodic"</dt> <dd>Interpolation mit periodischem Spline s vom lokalem Polynomgrad 3 (<object class="inlineeqn"> s'(0)=s'(l);\ s''(0)=s''(l)</object>).</dd>
                    <dt>"cSplineNatural"</dt> <dd>Interpolation mit natürlichem Spline s vom lokalem Polynomgrad 3 (<object class="inlineeqn"> s''(0)=0;\ s''(l)=0</object>).</dd>
                    <dt>"piecewiseLinear"</dt> <dd>Interpolation mit stückweise linearem Spline.</dd>
                  </dl>
                </xs:documentation>
              </xs:annotation>
          </xs:element>
        </xs:sequence> 
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="TwoDimensionalPiecewisePolynomFunction" substitutionGroup="Function" type="TwoDimensionalPiecewisePolynomFunctionType">
    <xs:annotation>
      <xs:documentation  xml:lang="de" xmlns="">
        Spline-Interpolation einer Funktion <object class="inlineeqn">z=f(x, y)</object>, die als Kennfeld hinterlegt ist.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="TwoDimensionalPiecewisePolynomFunctionType">
    <xs:complexContent>
      <xs:extension base="FunctionType">
        <xs:sequence>
          <xs:choice>
            <xs:sequence>
              <xs:element name="x" type="pv:unknownVector">
                <xs:annotation>
                  <xs:documentation xml:lang="de" xmlns="">
                    x-Werte.
                  </xs:documentation>
                </xs:annotation>
              </xs:element>
              <xs:element name="y" type="pv:unknownVector">
                <xs:annotation>
                  <xs:documentation xml:lang="de" xmlns="">
                    y-Werte.
                  </xs:documentation>
                </xs:annotation>
              </xs:element>
              <xs:element name="z" type="pv:unknownMatrix">
                <xs:annotation>
                  <xs:documentation xml:lang="de" xmlns="">
                    z-Werte. Die Anzahl der Spalten der Matrix muss mit der Größe des x-Vektors und die Anzahl der Zeilen der Matrix muss mit der Größe des y-Vektors übereinstimmen.
                  </xs:documentation>
                </xs:annotation>
              </xs:element>
            </xs:sequence>
            <xs:element name="xyz" type="pv:unknownMatrix">
              <xs:annotation>
                <xs:documentation xml:lang="de" xmlns="">
                  Die Stützstellen und die Stützwerte sind in einer Matrix zusammengefasst.
                </xs:documentation>
              </xs:annotation>
            </xs:element>
          </xs:choice>
          <xs:element name="interpolationMethodFirstDimension" minOccurs="0" type="pv:stringFullEval">
              <xs:annotation>
                <xs:documentation xml:lang="de" xmlns="">
                  <dl>
                    <dt>"cSplinePeriodic"</dt> <dd>Interpolation mit periodischem Spline s vom lokalem Polynomgrad 3 (<object class="inlineeqn"> s'(0)=s'(l);\ s''(0)=s''(l)</object>).</dd>
                    <dt>"cSplineNatural"</dt> <dd>Interpolation mit natürlichem Spline s vom lokalem Polynomgrad 3 (<object class="inlineeqn"> s''(0)=0;\ s''(l)=0</object>).</dd>
                    <dt>"piecewiseLinear"</dt> <dd>Interpolation mit stückweise linearem Spline.</dd>
                  </dl>
                </xs:documentation>
              </xs:annotation>
          </xs:element>
          <xs:element name="interpolationMethodSecondDimension" minOccurs="0" type="pv:stringFullEval">
              <xs:annotation>
                <xs:documentation xml:lang="de" xmlns="">
                  <dl>
                    <dt>"cSplinePeriodic"</dt> <dd>Interpolation mit periodischem Spline s vom lokalem Polynomgrad 3 (<object class="inlineeqn"> s'(0)=s'(l);\ s''(0)=s''(l)</object>).</dd>
                    <dt>"cSplineNatural"</dt> <dd>Interpolation mit natürlichem Spline s vom lokalem Polynomgrad 3 (<object class="inlineeqn"> s''(0)=0;\ s''(l)=0</object>).</dd>
                    <dt>"piecewiseLinear"</dt> <dd>Interpolation mit stückweise linearem Spline.</dd>
                  </dl>
                </xs:documentation>
              </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="FourierFunction" substitutionGroup="Function" type="FourierFunctionType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Fourierreihe <object class="inlineeqn">y=\frac{a_0}{2}+\sum_{i=1}^n a_i\,\cos(i*2*pi*f*t)+b_i\,\sin(i*2*pi*f*t)</object>.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="FourierFunctionType">
    <xs:complexContent>
      <xs:extension base="FunctionType">
        <xs:sequence>
          <xs:element name="frequency" type="pv:unknownScalar">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Grundfrequenz <object class="inlineeqn">f</object>.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="a0" type="pv:unknownScalar" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Koeffizient <object class="inlineeqn">a_0</object>.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:choice>
            <xs:sequence>
              <xs:element name="a" type="pv:unknownVector">
                <xs:annotation>
                  <xs:documentation xml:lang="de" xmlns="">
                    Vektor mit den Koeffizienten <object class="inlineeqn">a_i</object>.
                  </xs:documentation>
                </xs:annotation>
              </xs:element>
              <xs:element name="b" type="pv:unknownVector">
                <xs:annotation>
                  <xs:documentation xml:lang="de" xmlns="">
                    Vektor mit den Koeffizienten <object class="inlineeqn">b_i</object>.
                  </xs:documentation>
                </xs:annotation>
              </xs:element>
            </xs:sequence>
            <xs:element name="ab" type="pv:unknownMatrix">
              <xs:annotation>
                <xs:documentation xml:lang="de" xmlns="">
                    Matrix mit den Koeffizienten <object class="inlineeqn">a_i</object> und <object class="inlineeqn">b_i</object>.
                </xs:documentation>
              </xs:annotation>
            </xs:element>
          </xs:choice>
          <xs:element name="amplitudePhaseAngleForm" minOccurs="0" type="pv:booleanFullEval">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
                Definiert, ob die Koeffizienten <object class="inlineeqn">a_i</object> und <object class="inlineeqn">b_i</object> als Amplitude <object class="inlineeqn">A_i</object> und Phasenwinkel <object class="inlineeqn">\varphi_i</object> interpretiert werden sollen.
            </xs:documentation></xs:annotation>
          </xs:element>
        </xs:sequence> 
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="BidirectionalFunction" substitutionGroup="Function" type="BidirectionalFunctionType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Bidirektionale Funktion.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="BidirectionalFunctionType">
    <xs:complexContent>
      <xs:extension base="FunctionType">
        <xs:sequence>
          <xs:element name="negativeDirectionalFunction">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
            tbd
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:sequence>
                <xs:element ref="Function"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="positiveDirectionalFunction">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
            tbd
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:sequence>
                <xs:element ref="Function"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="ContinuedFunction" substitutionGroup="Function" type="ContinuedFunctionType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Fortsetzung einer Funktion mit eingeschränktem Definitionsbereich.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="ContinuedFunctionType">
    <xs:complexContent>
      <xs:extension base="FunctionType">
        <xs:sequence>
          <xs:element name="function">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Funktion mit eingeschränktem Definitionsbereich.
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:sequence>
                <xs:element ref="Function"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="continuationRule">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
              Forsetzungsregel.
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:sequence>
                <xs:element ref="Function"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="LinearSpringDamperForce" substitutionGroup="Function" type="LinearSpringDamperForceType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Lineares funktionelles Feder- / Dämpfergesetz.<br/>
        Die resultierende Kraft ergibt sich zu <object class="inlineeqn">f=c\,s+d\,\dot{s}</object> mit der Auslenkung <object class="inlineeqn">s</object> und der relativen Geschwindigkeit <object class="inlineeqn">\dot{s}</object>.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="LinearSpringDamperForceType">
    <xs:complexContent>
      <xs:extension base="FunctionType">
        <xs:sequence>
          <xs:element name="stiffnessCoefficient" type="pv:stiffnessScalar">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Steifigkeit <object class="inlineeqn">c</object>.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="dampingCoefficient" type="pv:dampingScalar">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Dämpfungskoeffizient <object class="inlineeqn">d</object>.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence> 
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="NonlinearSpringDamperForce" substitutionGroup="Function" type="NonlinearSpringDamperForceType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Nichtlineares funktionelles Feder- / Dämpfergesetz.<br/>
        Die resultierende Kraft ergibt sich zu <object class="inlineeqn">f=f_s\left(s\right)+f_{\dot{s}}\left(\dot{s}\right)</object> mit der Auslenkung <object class="inlineeqn">s</object> und der relativen Geschwindigkeit <object class="inlineeqn">\dot{s}</object>.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="NonlinearSpringDamperForceType">
    <xs:complexContent>
      <xs:extension base="FunctionType">
        <xs:sequence>
          <xs:element name="forceDeflectionFunction">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Lagereaktion <object class="inlineeqn">f_s\left(s\right)</object> (Feder).
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:sequence>
                <xs:element ref="Function"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="forceVelocityFunction">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Geschwindigkeitsreaktion <object class="inlineeqn">f_{\dot{s}}\left(\dot{s}\right)</object> (Dämpfer).
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:sequence>
                <xs:element ref="Function"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
        </xs:sequence> 
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="LinearElasticFunction" substitutionGroup="Function" type="LinearElasticFunctionType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
      tbd
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="LinearElasticFunctionType">
    <xs:complexContent>
      <xs:extension base="FunctionType">
        <xs:sequence>
          <xs:element name="stiffnessMatrix" type="pv:unknownMatrix">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Steifigkeitsmatrix.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="dampingMatrix" type="pv:unknownMatrix" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Dämpfungsmatrix.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="LinearRegularizedUnilateralConstraint" substitutionGroup="Function" type="LinearRegularizedUnilateralConstraintType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Konstitutive Funktion für einseitige Bindungen.<br/>
        Die Bindungskraft ergibt sich zu <object class="inlineeqn">\lambda=\begin{cases}0\ \text{bei}\ g\geq 0\\-cg-d\dot{g}\ \text{bei}\ g\leq 0\ \text{und}\ \dot{g}\leq 0\\-cg\ \text{bei}\ g\leq 0\ \text{und}\ \dot{g}\geq 0\end{cases}</object> mit dem Abstand g und der relativen Geschwindigkeit <object class="inlineeqn">\dot{g}</object>.
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:complexType name="LinearRegularizedUnilateralConstraintType">
    <xs:complexContent>
      <xs:extension base="FunctionType">
        <xs:sequence>
          <xs:element name="stiffnessCoefficient" type="pv:stiffnessScalar">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Steifigkeit c.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="dampingCoefficient" type="pv:dampingScalar">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Dämpfungskoeffizient d.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence> 
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="LinearRegularizedBilateralConstraint" substitutionGroup="Function" type="LinearRegularizedBilateralConstraintType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Konstitutive Funktion für zweiseitige Bindungen.<br/>
        Die Bindungskraft ergibt sich zu <object class="inlineeqn">\lambda=-cg-d\dot{g}</object> mit dem Abstand g und der relativen Geschwindigkeit <object class="inlineeqn">\dot{g}</object>.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="LinearRegularizedBilateralConstraintType">
    <xs:complexContent>
      <xs:extension base="FunctionType">
        <xs:sequence>
          <xs:element name="stiffnessCoefficient" type="pv:stiffnessScalar">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Steifigkeit c.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="dampingCoefficient" type="pv:dampingScalar">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Dämpfungskoeffizient d.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence> 
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="LinearRegularizedCoulombFriction" substitutionGroup="Function" type="LinearRegularizedCoulombFrictionType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Klasse für Coulomb Reibung, die durch eine lineare Funktion innerhalb von Grenzen um den Haftreibungsbereich regularisiert ist.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="LinearRegularizedCoulombFrictionType">
    <xs:complexContent>
      <xs:extension base="FunctionType">
        <xs:sequence>
          <xs:element name="marginalVelocity" type="pv:velocityScalar" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Grenze für die Regularisierung.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="frictionCoefficient" type="pv:nounitScalar">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Reibkoeffizient.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence> 
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>   

  <xs:element name="LinearRegularizedStribeckFriction" substitutionGroup="Function" type="LinearRegularizedStribeckFrictionType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
        Klasse für Stribeck Reibung, die durch eine lineare Funktion innerhalb von Grenzen um den Haftreibungsbereich regularisiert ist.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="LinearRegularizedStribeckFrictionType">
    <xs:complexContent>
      <xs:extension base="FunctionType">
        <xs:sequence>
          <xs:element name="marginalVelocity" type="pv:velocityScalar" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Grenze für die Regularisierung.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="frictionFunction">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Funktion für den geschwindigkeitsabhängigen Reibkoeffizienten.
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:sequence>
                <xs:element ref="Function"/>
              </xs:sequence>
            </xs:complexType> 
          </xs:element>
        </xs:sequence> 
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>   
  
  <xs:element name="InfluenceFunction" abstract="true" type="InfluenceFunctionType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
         Koppelt den Einfluss zwischen zwei Kontouren durch eine Einflussfunktion.
      </xs:documentation>
    </xs:annotation>
  </xs:element> 
  <xs:complexType name="InfluenceFunctionType">
    <xs:complexContent>
      <xs:extension base="FunctionType">
        <xs:attribute name="contourName1" type="ContourReferenceType" use="required"/>
        <xs:attribute name="contourName2" type="ContourReferenceType" use="required"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  <xs:element name="FlexibilityInfluenceFunction" substitutionGroup="InfluenceFunction" type="FlexibilityInfluenceFunctionType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
         Koppelt den Einfluss auf nur einer Kontur durch ihre Felxibilität.
      </xs:documentation>
    </xs:annotation>
  </xs:element>  
  <xs:complexType name="FlexibilityInfluenceFunctionType">
    <xs:complexContent>
      <xs:extension base="InfluenceFunctionType">
        <xs:sequence>
          <xs:element name="Flexibility" type="pv:unknownScalar"> <!-- Einheit eigentlich m/N -->
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Flexibilität (Kehrwert der Steifigkeit) der Kontur.
              </xs:documentation>
            </xs:annotation>
          </xs:element>            
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType> 

  <xs:element name="ConstantInfluenceFunction" substitutionGroup="InfluenceFunction" type="ConstantInfluenceFunctionType">
    <xs:annotation>
      <xs:documentation xml:lang="de" xmlns="">
         Koppelt den Einfluss zweier Konturen konsant.
      </xs:documentation>
    </xs:annotation>
  </xs:element> 
  <xs:complexType name="ConstantInfluenceFunctionType">
    <xs:complexContent>
      <xs:extension base="InfluenceFunctionType">
        <xs:sequence>
          <xs:element name="CouplingValue" type="pv:unknownScalar"> <!-- Einheit eigentlich m/N -->
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
                Kopplungswert zwischen zwei Konturen.
              </xs:documentation>
            </xs:annotation>
          </xs:element>            
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType> 

  <xs:element name="PolarContourFunction" substitutionGroup="Function" type="PolarContourFunctionType"/>
  <xs:complexType name="PolarContourFunctionType">
    <xs:complexContent>
      <xs:extension base="FunctionType">
        <xs:sequence>
          <xs:element name="radiusFunction">
            <xs:annotation><xs:documentation xml:lang="de" xmlns="">
            tbd
            </xs:documentation></xs:annotation>
            <xs:complexType>
              <xs:sequence>
                <xs:element ref="Function"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="Observer" substitutionGroup="Element" type="ObserverType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
    tbd.
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="ObserverType">
    <xs:complexContent>
      <xs:extension base="ElementType"/>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="CoordinatesObserver" substitutionGroup="Observer" type="CoordinatesObserverType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
    tbd.
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="CoordinatesObserverType">
    <xs:complexContent>
      <xs:extension base="ObserverType">
        <xs:sequence>
          <xs:element name="frame">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
              tbd.
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:attribute name="ref" type="FrameReferenceType" use="required"/>
            </xs:complexType>
          </xs:element>
          <xs:element name="enableOpenMBVPosition" minOccurs="0">  
            <xs:complexType>
              <xs:group ref="OpenMBVArrowParameters"/>
            </xs:complexType> 
          </xs:element>
          <xs:element name="enableOpenMBVVelocity" minOccurs="0">  
            <xs:complexType>
              <xs:group ref="OpenMBVArrowParameters"/>
            </xs:complexType> 
          </xs:element>
          <xs:element name="enableOpenMBVAcceleration" minOccurs="0">  
            <xs:complexType>
              <xs:group ref="OpenMBVArrowParameters"/>
            </xs:complexType> 
          </xs:element>
          <xs:element name="enableOpenMBVFrame" minOccurs="0">
            <xs:complexType>
              <xs:group ref="OpenMBVFrameParameters"/>
            </xs:complexType> 
          </xs:element>
        </xs:sequence> 
      </xs:extension>
    </xs:complexContent>
  </xs:complexType> 

  <xs:element name="CartesianCoordinatesObserver" substitutionGroup="CoordinatesObserver" type="CartesianCoordinatesObserverType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
    tbd.
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="CartesianCoordinatesObserverType">
    <xs:complexContent>
      <xs:extension base="CoordinatesObserverType">
        <xs:sequence>
          <xs:element name="orientation" type="pv:rotationMatrix" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
              tbd.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType> 

  <xs:element name="CylinderCoordinatesObserver" substitutionGroup="CoordinatesObserver" type="CylinderCoordinatesObserverType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
    tbd.
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="CylinderCoordinatesObserverType">
    <xs:complexContent>
      <xs:extension base="CoordinatesObserverType"/>
    </xs:complexContent>
  </xs:complexType> 

  <xs:element name="NaturalCoordinatesObserver" substitutionGroup="CoordinatesObserver" type="NaturalCoordinatesObserverType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
    tbd.
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="NaturalCoordinatesObserverType">
    <xs:complexContent>
      <xs:extension base="CoordinatesObserverType"/>
    </xs:complexContent>
  </xs:complexType> 

  <xs:element name="KinematicsObserver" substitutionGroup="Observer" type="KinematicsObserverType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
    tbd.
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="KinematicsObserverType">
    <xs:complexContent>
      <xs:extension base="ObserverType">
        <xs:sequence>
          <xs:element name="frame">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
              tbd.
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:attribute name="ref" type="FrameReferenceType" use="required"/>
            </xs:complexType>
          </xs:element>
          <xs:element name="enableOpenMBVPosition" minOccurs="0">  
            <xs:complexType>
              <xs:group ref="OpenMBVArrowParameters"/>
            </xs:complexType> 
          </xs:element>
          <xs:element name="enableOpenMBVVelocity" minOccurs="0">  
            <xs:complexType>
              <xs:group ref="OpenMBVArrowParameters"/>
            </xs:complexType> 
          </xs:element>
          <xs:element name="enableOpenMBVAngularVelocity" minOccurs="0">  
            <xs:complexType>
              <xs:group ref="OpenMBVArrowParameters"/>
            </xs:complexType> 
          </xs:element>
          <xs:element name="enableOpenMBVAcceleration" minOccurs="0">  
            <xs:complexType>
              <xs:group ref="OpenMBVArrowParameters"/>
            </xs:complexType> 
          </xs:element>
          <xs:element name="enableOpenMBVAngularAcceleration" minOccurs="0">  
            <xs:complexType>
              <xs:group ref="OpenMBVArrowParameters"/>
            </xs:complexType> 
          </xs:element>
        </xs:sequence> 
      </xs:extension>
    </xs:complexContent>
  </xs:complexType> 

  <xs:element name="AbsoluteKinematicsObserver" substitutionGroup="KinematicsObserver" type="AbsoluteKinematicsObserverType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
    tbd.
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="AbsoluteKinematicsObserverType">
    <xs:complexContent>
      <xs:extension base="KinematicsObserverType"/>
    </xs:complexContent>
  </xs:complexType> 

  <xs:element name="RelativeKinematicsObserver" substitutionGroup="KinematicsObserver" type="RelativeKinematicsObserverType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
    tbd.
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="RelativeKinematicsObserverType">
    <xs:complexContent>
      <xs:extension base="KinematicsObserverType">
        <xs:sequence>
          <xs:element name="frameOfReference">
            <xs:annotation>
              <xs:documentation xml:lang="de" xmlns="">
              tbd.
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:attribute name="ref" type="FrameReferenceType" use="required"/>
            </xs:complexType>
          </xs:element>
        </xs:sequence> 
      </xs:extension>
    </xs:complexContent>
  </xs:complexType> 

  <xs:element name="Solver" abstract="true" type="SolverType">
    <xs:annotation><xs:documentation xml:lang="de" xmlns="">
    tbd
    </xs:documentation></xs:annotation>
  </xs:element>
  <xs:complexType name="SolverType">
  </xs:complexType> 

</xs:schema>
