diff -crB nurbs++-3.0.11_Patch1//image/color.h nurbs++-3.0.11/image/color.h
*** nurbs++-3.0.11_Patch1//image/color.h	2002-05-13 23:07:45.000000000 +0200
--- nurbs++-3.0.11/image/color.h	2011-07-05 10:18:02.352415490 +0200
***************
*** 28,33 ****
--- 28,35 ----
  #include "matrix_global.h"
  #include "matrixTool.h"
  
+ #include <limits>
+ 
  /*!
   */
  namespace PLib {
***************
*** 253,259 ****
      \date 14 May 1999
     */
    inline void Color::fromHSV(double h, double s, double v){
!     if(s==0.0){
        r=g=b=0;
        return;
      }
--- 255,261 ----
      \date 14 May 1999
     */
    inline void Color::fromHSV(double h, double s, double v){
!     if(abs(s)<std::numeric_limits<double>::epsilon()){
        r=g=b=0;
        return;
      }
diff -crB nurbs++-3.0.11_Patch1//numerical/matrixMat.cpp nurbs++-3.0.11/numerical/matrixMat.cpp
*** nurbs++-3.0.11_Patch1//numerical/matrixMat.cpp	2011-08-31 13:05:50.122279745 +0200
--- nurbs++-3.0.11/numerical/matrixMat.cpp	2011-08-31 11:40:12.991406697 +0200
***************
*** 250,255 ****
--- 250,258 ----
  template <class T>
  void LUMatrix<T>::inverseIn(Matrix<T>& inv) 
  {
+     if(Matrix<T>::rows() > 14)
+       cout << "WARNING in LUMatrix<T>::inverseIn: There are errors in this routine (or class) that should be solved!\n They have been discovered when using a closed interpolation of a nurbs curve with more than 14 interpolated points.\n Solve them or use the SVD-Solver as it seems to work more reliable." << endl;
+ 
    T ten;
    int i, j, k, l, kb, kp1, nm1, n, coln;
  
***************
*** 1025,1032 ****
  
    Solves the linear system \a A \a X = \a B. Given \a A and B it
    finds the value of \a X. The routine uses LU decomposition
!   if the A matrix is square and it uses SVD decomposition
!   otherwise.
  
    \param   A  the \a A matrix
    \param B  the right hand side of the equation
--- 1028,1035 ----
  
    Solves the linear system \a A \a X = \a B. Given \a A and B it
    finds the value of \a X. The routine uses LU decomposition
!   if the A matrix is square and its dimension is less than 14
!   It uses SVD decomposition otherwise.
  
    \param   A  the \a A matrix
    \param B  the right hand side of the equation
***************
*** 1041,1047 ****
  int solve(const Matrix<T>& A, 
  	   const Matrix<T>& B, 
  	   Matrix<T>& X){
!   if(A.rows()==A.cols()){ 
      // use LU decomposition to solve the problem
      LUMatrix<T> lu(A) ;
      X = lu.inverse()*B ;
--- 1044,1051 ----
  int solve(const Matrix<T>& A, 
  	   const Matrix<T>& B, 
  	   Matrix<T>& X){
!   if(A.rows()==A.cols() and A.rows() < 14){
!     // lu.inverse() seems not be relieable for more than about 14 interpolation points (just try an example for a (closed) circle with 14 points) and you will see ...
      // use LU decomposition to solve the problem
      LUMatrix<T> lu(A) ;
      X = lu.inverse()*B ;
***************
*** 1057,1063 ****
    \brief finds the inverse of a matrix
  
    Finds the inverse of a matrix. It uses LU decomposition if
!   the matrix is square and it uses SVD decomposition otherwise.
  
    \param A  the matrix to inverse
  
--- 1061,1068 ----
    \brief finds the inverse of a matrix
  
    Finds the inverse of a matrix. It uses LU decomposition if
!   the matrix is square and the dimension of A is < 14.
!   It uses SVD decomposition otherwise.
  
    \param A  the matrix to inverse
  
***************
*** 1072,1078 ****
  template <class T>
  Matrix<T> inverse(const Matrix<T>&A){
    Matrix<T> inv ;
!   if(A.rows()==A.cols()){
      LUMatrix<T> lu(A) ;
      lu.inverseIn(inv) ;
    }
--- 1077,1084 ----
  template <class T>
  Matrix<T> inverse(const Matrix<T>&A){
    Matrix<T> inv ;
!   if(A.rows()==A.cols()  and A.rows() < 14){
!     // lu.inverse() seems not be relieable for more than about 14 interpolation points (just try an example for a (closed) circle with 14 points) and you will see ...
      LUMatrix<T> lu(A) ;
      lu.inverseIn(inv) ;
    }
diff -crB nurbs++-3.0.11_Patch1//nurbs/d_surface.cpp nurbs++-3.0.11/nurbs/d_surface.cpp
*** nurbs++-3.0.11_Patch1//nurbs/d_surface.cpp	2011-08-31 13:05:50.124279849 +0200
--- nurbs++-3.0.11/nurbs/d_surface.cpp	2011-07-05 10:18:02.353405055 +0200
***************
*** 25,33 ****
    template class InterPoint<double,2> ;
    template class InterPoint<double,3> ;
    
!   //TODO: External patcher's comment: BasicList not in PLib namespace?
!   //template class BasicList<InterPoint<double,2> > ; 
!   //template class BasicList<InterPoint<double,3> > ; 
    
    template class ParaSurface<double,2> ;
    template class ParaSurface<double,3> ;
--- 25,31 ----
    template class InterPoint<double,2> ;
    template class InterPoint<double,3> ;
    
! 
    
    template class ParaSurface<double,2> ;
    template class ParaSurface<double,3> ;
***************
*** 38,40 ****
--- 36,41 ----
  #endif 
  
  }
+ 
+ template class BasicList<PLib::InterPoint<double,2> > ; 
+ template class BasicList<PLib::InterPoint<double,3> > ; 
diff -crB nurbs++-3.0.11_Patch1//nurbs/f_surface.cpp nurbs++-3.0.11/nurbs/f_surface.cpp
*** nurbs++-3.0.11_Patch1//nurbs/f_surface.cpp	2011-08-31 13:05:50.125279748 +0200
--- nurbs++-3.0.11/nurbs/f_surface.cpp	2011-07-05 10:18:02.353405055 +0200
***************
*** 26,34 ****
    template class InterPoint<float,3> ;
   
  
! //This breaks the "NO_IMPLICIT_TEMPLATES" thingy. Does BasicList not belong to PLib? 
! //  template class BasicList<InterPoint<float,2> > ; 
! //  template class BasicList<InterPoint<float,3> > ; 
    
    template class ParaSurface<float,2> ;
    template class ParaSurface<float,3> ;
--- 26,32 ----
    template class InterPoint<float,3> ;
   
  
! 
    
    template class ParaSurface<float,2> ;
    template class ParaSurface<float,3> ;
***************
*** 40,42 ****
--- 38,43 ----
  #endif 
  
  }
+ 
+ template class BasicList<PLib::InterPoint<float,2> > ; 
+ template class BasicList<PLib::InterPoint<float,3> > ; 
diff -crB nurbs++-3.0.11_Patch1//nurbs/nurbs.cpp nurbs++-3.0.11/nurbs/nurbs.cpp
*** nurbs++-3.0.11_Patch1//nurbs/nurbs.cpp	2011-08-31 13:05:50.131279702 +0200
--- nurbs++-3.0.11/nurbs/nurbs.cpp	2011-08-31 11:52:17.431406345 +0200
***************
*** 40,46 ****
    \date 24 January 1997
  */
  template <class T, int N>
! NurbsCurve<T,N>::NurbsCurve(): P(1),U(1),deg_(0)
  {
  }
  
--- 40,46 ----
    \date 24 January 1997
  */
  template <class T, int N>
! NurbsCurve<T,N>::NurbsCurve(): P(1),U(1),deg_(0),Inverse_setted(0)
  {
  }
  
***************
*** 56,61 ****
--- 56,62 ----
  NurbsCurve<T,N>::NurbsCurve(const NurbsCurve<T,N>& nurb): 
    ParaCurve<T,N>(), P(nurb.P),U(nurb.U),deg_(nurb.deg_)
  {
+   Inverse_setted = 0;
  }
  
  /*!
***************
*** 74,79 ****
--- 75,81 ----
    int nSize = P1.n() ;
    int mSize = U1.n() ;
    deg_ = Degree ;
+   Inverse_setted = 0;
    if(nSize != mSize-deg_-1){
  #ifdef USE_EXCEPTION
      throw NurbsSizeError(P1.n(),U1.n(),Degree) ;
***************
*** 106,112 ****
  template <class T, int N>
  NurbsCurve<T,N>::NurbsCurve(const Vector< HPoint_nD<T,N> >& P1, const Vector<T> &U1, int Degree): P(P1), U(U1), deg_(Degree) 
  {
! 
    if(P.n() != U.n()-deg_-1){
  #ifdef USE_EXCEPTION
      throw NurbsSizeError(P.n(),U.n(),deg_) ;
--- 108,114 ----
  template <class T, int N>
  NurbsCurve<T,N>::NurbsCurve(const Vector< HPoint_nD<T,N> >& P1, const Vector<T> &U1, int Degree): P(P1), U(U1), deg_(Degree) 
  {
!  Inverse_setted=0;
    if(P.n() != U.n()-deg_-1){
  #ifdef USE_EXCEPTION
      throw NurbsSizeError(P.n(),U.n(),deg_) ;
***************
*** 138,143 ****
--- 140,146 ----
  {
    int nSize = P1.n() ;
    int mSize = U1.n() ;
+   Inverse_setted=0;
  
    if(nSize != mSize-deg_-1){
  #ifdef USE_EXCEPTION
***************
*** 385,391 ****
    \author Philippe Lavoie 
    \date 25 July 1997
  */
! template<> template <class T, int N>
  NurbsSurface<T,3> NurbsCurve<T,N>::drawAaImg(Image_Color& Img, const Color& color, const NurbsCurve<T,3>& profile, const NurbsCurve<T,3>& scaling, int precision, int alpha){
    Matrix<T> addMatrix ;
    Matrix_INT nMatrix ;
--- 388,395 ----
    \author Philippe Lavoie 
    \date 25 July 1997
  */
! template<>
! template <class T, int N>
  NurbsSurface<T,3> NurbsCurve<T,N>::drawAaImg(Image_Color& Img, const Color& color, const NurbsCurve<T,3>& profile, const NurbsCurve<T,3>& scaling, int precision, int alpha){
    Matrix<T> addMatrix ;
    Matrix_INT nMatrix ;
***************
*** 471,477 ****
    \author Philippe Lavoie 
    \date 22 August 1997
  */
! template<> template <class T, int N>
  void NurbsCurve<T,N>::transform(const MatrixRT<T>& A){
    for(int i=P.n()-1;i>=0;--i)
      P[i] = A*P[i] ;
--- 475,482 ----
    \author Philippe Lavoie 
    \date 22 August 1997
  */
! template<>
! template <class T, int N>
  void NurbsCurve<T,N>::transform(const MatrixRT<T>& A){
    for(int i=P.n()-1;i>=0;--i)
      P[i] = A*P[i] ;
***************
*** 502,508 ****
    \author Philippe Lavoie 
    \date 24 January, 1997
  */
! template<> template <class T, int N>
  HPoint_nD<T,N> NurbsCurve<T,N>::operator()(T u) const{
    static Vector<T> Nb ;
    int span = findSpan(u) ;
--- 507,514 ----
    \author Philippe Lavoie 
    \date 24 January, 1997
  */
! template<>
! template <class T, int N>
  HPoint_nD<T,N> NurbsCurve<T,N>::operator()(T u) const{
    static Vector<T> Nb ;
    int span = findSpan(u) ;
***************
*** 541,547 ****
    \author Philippe Lavoie    
    \date 24 January, 1997
  */
! template<> template <class T, int N>
  HPoint_nD<T,N> NurbsCurve<T,N>::hpointAt(T u, int span) const{
    static Vector<T> Nb ;
  
--- 547,554 ----
    \author Philippe Lavoie    
    \date 24 January, 1997
  */
! template<>
! template <class T, int N>
  HPoint_nD<T,N> NurbsCurve<T,N>::hpointAt(T u, int span) const{
    static Vector<T> Nb ;
  
***************
*** 594,600 ****
    \author  Philippe Lavoie
    \date 24 January, 1997
  */
! template<> template <class T, int N>
  HPoint_nD<T,N> NurbsCurve<T,N>::derive(T u, int d) const {
    Vector< HPoint_nD<T,N> > ders ;
    deriveAtH(u,d,ders) ;
--- 601,608 ----
    \author  Philippe Lavoie
    \date 24 January, 1997
  */
! template<>
! template <class T, int N>
  HPoint_nD<T,N> NurbsCurve<T,N>::derive(T u, int d) const {
    Vector< HPoint_nD<T,N> > ders ;
    deriveAtH(u,d,ders) ;
***************
*** 617,623 ****
    \author  Philippe Lavoie
    \date 24 January, 1997
  */
! template<> template <class T, int N>
  void NurbsCurve<T,N>::deriveAtH(T u,int d, Vector< HPoint_nD<T,N> >& ders) const{
    int du = minimum(d,deg_) ;
    int span ;
--- 625,632 ----
    \author  Philippe Lavoie
    \date 24 January, 1997
  */
! template<>
! template <class T, int N>
  void NurbsCurve<T,N>::deriveAtH(T u,int d, Vector< HPoint_nD<T,N> >& ders) const{
    int du = minimum(d,deg_) ;
    int span ;
***************
*** 2858,2864 ****
  
  
    resize(Q.n(),d) ;
!   Matrix_DOUBLE A(Q.n(),Q.n()) ;
  
    knotAveraging(ub,d,U) ;
  
--- 2867,2873 ----
  
  
    resize(Q.n(),d) ;
!     Matrix<T> A(Q.n(), Q.n());
  
    knotAveraging(ub,d,U) ;
  
***************
*** 2875,2888 ****
    A(Q.n()-1,Q.n()-1) = 1.0 ;
  
    // Init matrix for LSE
!   Matrix_DOUBLE qq(Q.n(),D) ;
!   Matrix_DOUBLE xx(Q.n(),D) ;
    for(i=0;i<Q.n();i++){
      const Point_nD<T,D>& qp = Q[i] ; // this makes the SGI compiler happy
      for(j=0; j<D;j++)
        qq(i,j) = (double)qp.data[j] ;
    }
  
    solve(A,qq,xx) ;
  
    // Store the data
--- 2884,2898 ----
    A(Q.n()-1,Q.n()-1) = 1.0 ;
  
    // Init matrix for LSE
!     Matrix<T> qq(Q.n(), D);
!     Matrix<T> xx(Q.n(), D);
    for(i=0;i<Q.n();i++){
      const Point_nD<T,D>& qp = Q[i] ; // this makes the SGI compiler happy
      for(j=0; j<D;j++)
        qq(i,j) = (double)qp.data[j] ;
    }
  
+   //TODO: add same routine as in the globalInterpH-case
    solve(A,qq,xx) ;
  
    // Store the data
***************
*** 3101,3106 ****
--- 3111,3204 ----
  }
  
  /*!
+   \brief  computes the Inverse for the compution of the control-points
+ 
+   \param v  kind of "span"-vector
+   \param V  a valid knot-vector
+   \param p  the degree of the curve
+   
+   \warning v and V have to be valid 
+   \author Philippe Lavoie 
+   \date 3 September, 1997
+ */
+ template <class T, int D>
+ Matrix<T> NurbsCurve<T,D>::computeInverse(const Vector<T> &v, const Vector<T> &V, const int p){  //changed 
+ 
+   int i,j;
+   int iN = V.n()-p-1;
+ 
+   resize(iN,p); //so findSpan works ... V has to be a valid knot-vector!!!!
+ 
+   U = V;
+ 
+   Matrix<T> A(iN,iN);
+ 
+  
+   // Initialize the basis matrix A
+   Vector<T> N(p+1) ;
+ 
+   for(i=1;i<iN-1;i++){
+     int span = findSpan(v[i]);
+     basisFuns(v[i],span,N) ;
+     for(j=0;j<=p;j++) 
+ 	A(i,span-p+j) = (double)N[j] ;
+   }
+   A(0,0)  = 1.0 ;
+   A(iN-1,iN-1) = 1.0 ;
+ 
+   Inverse = inverse(A);
+   
+ //  LUMatrix<T> lu(A);
+ //  Inverse = lu.inverse();
+   Inverse_setted=1;
+   return Inverse;
+ 
+ }
+ 
+ /*!
+   \brief  computes the Inverse for the compution of the control-points on a closed curve
+ 
+   \param v  kind of "span"-vector
+   \param V  a valid knot-vector
+   \param p  the degree of the curve
+   
+   \warning v and V have to be valid 
+   \author Philippe Lavoie 
+   \date 3 September, 1997
+ */
+ template <class T, int D>
+ Matrix<T> NurbsCurve<T,D>::computeInverseClosed(const Vector<T> &v, const Vector<T> &V, const int p){  //changed
+ 
+   int i,j ;
+   int iN = V.n() - p - 1 - p - 1;
+ 
+   resize(V.n()-p-1,p); //so findSpan works ... V has to be a valid knot-vector!!!!
+ 
+   U = V;
+ 
+   Matrix<T> A(iN+1,iN+1) ;
+ 
+ 
+   // Initialize the basis matrix A
+   Vector<T> N(p+1) ;
+ 
+   for(i=0;i<=iN;i++){
+     int span = findSpan(v[i]);
+     basisFuns(v[i],span,N) ;
+     for(j=span-p;j<=span;j++) 
+       A(i,j%(iN+1)) = (double)N[j-span+p] ;
+   }
+ 
+   Inverse = inverse(A);
+ 
+ //  LUMatrix<T> lu(A);
+ //  Inverse = lu.inverse();
+   Inverse_setted=1;
+   return Inverse;
+ }
+ 
+ 
+ /*!
    \brief global curve interpolation with points in 4D
  
    Global curve interpolation with points in 4D
***************
*** 3119,3125 ****
    int i,j ;
  
    resize(Q.n(),d) ;
!   Matrix_DOUBLE A(Q.n(),Q.n()) ;
    Vector<T> ub(Q.n()) ;
  
    chordLengthParamH(Q,ub) ;
--- 3217,3223 ----
    int i,j ;
  
    resize(Q.n(),d) ;
! //    Matrix<T> A(Q.n(), Q.n());
    Vector<T> ub(Q.n()) ;
  
    chordLengthParamH(Q,ub) ;
***************
*** 3136,3169 ****
      U[j+deg_] = t/(T)deg_ ;
    }
    
!   // Initialize the basis matrix A
!   Vector<T> N(deg_+1) ;
! 
!   for(i=1;i<Q.n()-1;i++){
!     int span = findSpan(ub[i]);
!     basisFuns(ub[i],span,N) ;
!     for(j=0;j<=deg_;j++) 
! 	A(i,span-deg_+j) = (double)N[j] ;
!   }
!   A(0,0)  = 1.0 ;
!   A(Q.n()-1,Q.n()-1) = 1.0 ;
! 
!   // Init matrix for LSE
!   Matrix_DOUBLE qq(Q.n(),D+1) ;
!   Matrix_DOUBLE xx(Q.n(),D+1) ;
!   for(i=0;i<Q.n();i++)
!     for(j=0; j<D+1;j++)
!       qq(i,j) = (double)Q[i].data[j] ;
! 
!   solve(A,qq,xx) ;
  
!   // Store the data
!   for(i=0;i<xx.rows();i++){
!     for(j=0;j<D+1;j++)
!       P[i].data[j] = (T)xx(i,j) ;
    }
  
- }
  
  /*!
    \brief global curve interpolation with 4D points and a knot vector defined.
--- 3234,3269 ----
      U[j+deg_] = t/(T)deg_ ;
    }
    
!     globalInterpH(Q,ub,U,d);
  
! //    // Initialize the basis matrix A
! //    Vector < T > N(deg_ + 1);
! //
! //    for (i = 1; i < Q.n() - 1; i++) {
! //      int span = findSpan(ub[i]);
! //      basisFuns(ub[i], span, N);
! //      for (j = 0; j <= deg_; j++)
! //        A(i, span - deg_ + j) = (double) N[j];
! //    }
! //    A(0, 0) = 1.0;
! //    A(Q.n() - 1, Q.n() - 1) = 1.0;
! //
! //    // Init matrix for LSE
! //    Matrix<T> qq(Q.n(), D + 1);
! //    Matrix<T> xx(Q.n(), D + 1);
! //    for (i = 0; i < Q.n(); i++)
! //      for (j = 0; j < D + 1; j++)
! //        qq(i, j) = (double) Q[i].data[j];
! //
! //    SVDMatrix<double> svd(A);
! //    svd.solve(qq, xx);
! //
! //    // Store the data
! //    for (i = 0; i < xx.rows(); i++) {
! //      for (j = 0; j < D + 1; j++)
! //        P[i].data[j] = (T) xx(i, j);
    }
  
  
  /*!
    \brief global curve interpolation with 4D points and a knot vector defined.
***************
*** 3186,3192 ****
    int i,j ;
  
    resize(Q.n(),d) ;
!   Matrix_DOUBLE A(Q.n(),Q.n()) ;
    Vector<T> ub(Q.n()) ;
  
    if(Uc.n() != U.n()){
--- 3286,3292 ----
    int i,j ;
  
    resize(Q.n(),d) ;
!     Matrix<T> A(Q.n(), Q.n());
    Vector<T> ub(Q.n()) ;
  
    if(Uc.n() != U.n()){
***************
*** 3202,3235 ****
    U = Uc ;
    chordLengthParamH(Q,ub) ;
    
!   // Initialize the basis matrix A
!   Vector<T> N(deg_+1) ;
  
!   for(i=1;i<Q.n()-1;i++){
!     int span = findSpan(ub[i]);
!     basisFuns(ub[i],span,N) ;
!     for(j=0;j<=deg_;j++) 
! 	A(i,span-deg_+j) = (double)N[j] ;
    }
-   A(0,0)  = 1.0 ;
-   A(Q.n()-1,Q.n()-1) = 1.0 ;
  
-   // Init matrix for LSE
-   Matrix_DOUBLE qq(Q.n(),D+1) ;
-   Matrix_DOUBLE xx(Q.n(),D+1) ;
-   for(i=0;i<Q.n();i++)
-     for(j=0; j<D+1;j++)
-       qq(i,j) = (double)Q[i].data[j] ;
- 
-   solve(A,qq,xx) ;
- 
-   // Store the data
-   for(i=0;i<xx.rows();i++){
-     for(j=0;j<D+1;j++)
-       P[i].data[j] = (T)xx(i,j) ;
-   }
- 
- }
  
  /*!
    \brief global curve interpolation with 4D points, 
--- 3302,3337 ----
    U = Uc ;
    chordLengthParamH(Q,ub) ;
    
!     globalInterpH(Q,ub,Uc,d);
  
! //    // Initialize the basis matrix A
! //    Vector < T > N(deg_ + 1);
! //
! //    for (i = 1; i < Q.n() - 1; i++) {
! //      int span = findSpan(ub[i]);
! //      basisFuns(ub[i], span, N);
! //      for (j = 0; j <= deg_; j++)
! //        A(i, span - deg_ + j) = (double) N[j];
! //    }
! //    A(0, 0) = 1.0;
! //    A(Q.n() - 1, Q.n() - 1) = 1.0;
! //
! //    // Init matrix for LSE
! //    Matrix<T> qq(Q.n(), D + 1);
! //    Matrix<T> xx(Q.n(), D + 1);
! //    for (i = 0; i < Q.n(); i++)
! //      for (j = 0; j < D + 1; j++)
! //        qq(i, j) = (double) Q[i].data[j];
! //
! //    SVDMatrix<double> svd(A);
! //    svd.solve(qq, xx);
! //
! //    // Store the data
! //    for (i = 0; i < xx.rows(); i++) {
! //      for (j = 0; j < D + 1; j++)
! //        P[i].data[j] = (T) xx(i, j);
    }
  
  
  /*!
    \brief global curve interpolation with 4D points, 
***************
*** 3256,3262 ****
    int i,j ;
  
    resize(Q.n(),d) ;
-   Matrix_DOUBLE A(Q.n(),Q.n()) ;
  
    if(Uc.n() != U.n()){
  #ifdef USE_EXCEPTION
--- 3358,3363 ----
***************
*** 3269,3295 ****
  #endif
    }
    U = Uc ;
-   
-   // Initialize the basis matrix A
-   Vector<T> N(deg_+1) ;
  
!   for(i=1;i<Q.n()-1;i++){
!     int span = findSpan(ub[i]);
!     basisFuns(ub[i],span,N) ;
!     for(j=0;j<=deg_;j++) 
! 	A(i,span-deg_+j) = (double)N[j] ;
!   }
!   A(0,0)  = 1.0 ;
!   A(Q.n()-1,Q.n()-1) = 1.0 ;
! 
!   // Init matrix for LSE
!   Matrix_DOUBLE qq(Q.n(),D+1) ;
!   Matrix_DOUBLE xx(Q.n(),D+1) ;
    for(i=0;i<Q.n();i++)
      for(j=0; j<D+1;j++)
        qq(i,j) = (double)Q[i].data[j] ;
  
!   solve(A,qq,xx) ;
  
    // Store the data
    for(i=0;i<xx.rows();i++){
--- 3370,3387 ----
  #endif
    }
    U = Uc ;
  
!    // Init matrix for LSE
!   Matrix<T> qq(Q.n(),D+1) ;
!   Matrix<T> xx(Q.n(),D+1) ;
    for(i=0;i<Q.n();i++)
      for(j=0; j<D+1;j++)
        qq(i,j) = (double)Q[i].data[j] ;
  
!   if (Inverse_setted != 1) //changed
!     computeInverse(ub, Uc, d);
! 
!   xx = Inverse * qq;
  
    // Store the data
    for(i=0;i<xx.rows();i++){
***************
*** 3958,3971 ****
  
  
  /*!
!   \brief Decompose the curve into Bézier segments
  
!   This function decomposes the curve into an array of 4D Bézier 
    segments.
  
!   \param c  an array of Bézier segments
  
!   \warning The end Bézier segments will not be valid if the NURBS curve 
             is not clamped.
  
    \author Philippe Lavoie
--- 4051,4064 ----
  
  
  /*!
!   \brief Decompose the curve into Bï¿½zier segments
  
!   This function decomposes the curve into an array of 4D Bï¿½zier 
    segments.
  
!   \param c  an array of Bï¿½zier segments
  
!   \warning The end Bï¿½zier segments will not be valid if the NURBS curve 
             is not clamped.
  
    \author Philippe Lavoie
***************
*** 5300,5306 ****
    }
    else{
      for(int i=0;i<ca.n();++i){
!       list2 = ca[i].tesselate(tolerance,uk) ;
  
        // remove the last point from the list to elliminate
        list.erase((BasicNode<Point_nD<T,N> >*)list.last()) ;
--- 5393,5399 ----
    }
    else{
      for(int i=0;i<ca.n();++i){
!       list2 = ca[i].tesselate(tolerance,uk);
  
        // remove the last point from the list to elliminate
        list.erase((BasicNode<Point_nD<T,N> >*)list.last()) ;
***************
*** 6606,6617 ****
  template <class T, int D>
  void NurbsCurve<T,D>::globalInterpClosed(const Vector< Point_nD<T,D> >& Qw,
  			const Vector<T>& ub, const Vector<T>& Uc, int d){
    int i,j ;
  
    resize(Qw.n(),d) ;
  
    int iN = Qw.n() - d - 1;
!   Matrix_DOUBLE A(iN+1,iN+1) ;
    
    if(Uc.n() != U.n()){
  #ifdef USE_EXCEPTION
--- 6699,6713 ----
  template <class T, int D>
  void NurbsCurve<T,D>::globalInterpClosed(const Vector< Point_nD<T,D> >& Qw,
  			const Vector<T>& ub, const Vector<T>& Uc, int d){
+ 			
+ 			cout << "WARNING: globalInterpClosed() doesn't work reliable. Use globalInterpClosedH() instead or better: try to find the cause of the problem!" << endl;
+ 			
    int i,j ;
  
    resize(Qw.n(),d) ;
  
    int iN = Qw.n() - d - 1;
!     Matrix<T> A(iN + 1, iN + 1);
    
    if(Uc.n() != U.n()){
  #ifdef USE_EXCEPTION
***************
*** 6636,6643 ****
    }
  
    // Init matrix for LSE
!   Matrix_DOUBLE qq(iN+1,D) ;
!   Matrix_DOUBLE xx(iN+1,D) ;
    for(i=0;i<=iN ;i++)
      for(j=0; j<D;j++)
        qq(i,j) = (double)Qw[i].data[j] ;
--- 6732,6739 ----
    }
  
    // Init matrix for LSE
!     Matrix<T> qq(iN + 1, D);
!     Matrix<T> xx(iN + 1, D);
    for(i=0;i<=iN ;i++)
      for(j=0; j<D;j++)
        qq(i,j) = (double)Qw[i].data[j] ;
***************
*** 6646,6653 ****
    // using the SVD routine which works better when the system of
    // equations is very large (more than 50 points). Probably since in
    // this cases the system matrix A is very sparse.
!   SVDMatrix<double> svd(A) ;
!   svd.solve(qq,xx) ;
  
    // Store the data
    for(i=0;i<xx.rows();i++){
--- 6742,6752 ----
    // using the SVD routine which works better when the system of
    // equations is very large (more than 50 points). Probably since in
    // this cases the system matrix A is very sparse.
! 
!   if (Inverse_setted != 1)
!     Inverse = computeInverseClosed(ub, Uc, d);
! 
!   xx = Inverse * qq;
  
    // Store the data
    for(i=0;i<xx.rows();i++){
***************
*** 6689,6695 ****
    resize(Qw.n(),d) ;
  
    int iN = Qw.n() - d - 1;
-   Matrix_DOUBLE A(iN+1,iN+1) ;
    
    if(Uc.n() != U.n()){
  #ifdef USE_EXCEPTION
--- 6788,6793 ----
***************
*** 6703,6721 ****
    }
    U = Uc ;
  
-   // Initialize the basis matrix A
-   Vector<T> N(d+1) ;
- 
-   for(i=0;i<=iN;i++){
-     int span = findSpan(ub[i]);
-     basisFuns(ub[i],span,N) ;
-     for(j=span-d;j<=span;j++) 
-       A(i,j%(iN+1)) = (double)N[j-span+d] ;
-   }
- 
    // Init matrix for LSE
!   Matrix_DOUBLE qq(iN+1,D+1) ;
!   Matrix_DOUBLE xx(iN+1,D+1) ;
    for(i=0;i<=iN ;i++)
      for(j=0; j<D+1;j++)
        qq(i,j) = (double)Qw[i].data[j] ;
--- 6801,6809 ----
    }
    U = Uc ;
  
    // Init matrix for LSE
!   Matrix<T> qq(iN+1,D+1) ;
!   Matrix<T> xx(iN+1,D+1) ;
    for(i=0;i<=iN ;i++)
      for(j=0; j<D+1;j++)
        qq(i,j) = (double)Qw[i].data[j] ;
***************
*** 6724,6731 ****
    // using the SVD routine which works better when the system of
    // equations is very large (more than 50 points). Probably since in
    // this cases the system matrix A is very sparse.
!   SVDMatrix<double> svd(A) ;
!   svd.solve(qq,xx) ;
  
    // Store the data
    for(i=0;i<xx.rows();i++){
--- 6812,6822 ----
    // using the SVD routine which works better when the system of
    // equations is very large (more than 50 points). Probably since in
    // this cases the system matrix A is very sparse.
! 
!   if (Inverse_setted != 1)
!     Inverse = computeInverseClosed(ub, Uc, d);
! 
!   xx = Inverse * qq;
  
    // Store the data
    for(i=0;i<xx.rows();i++){
***************
*** 6741,6752 ****
  }
  
  /*!
!    \brief decompose the closed curve into Bézier segments
     
!    This function decomposes a closed curve into an array of Bézier 
     segments.
  
!    \param c an array of Bézier segments
  
     \author Alejandro Frangi
     \date 30 July 1998
--- 6832,6843 ----
  }
  
  /*!
!    \brief decompose the closed curve into Bï¿½zier segments
     
!    This function decomposes a closed curve into an array of Bï¿½zier 
     segments.
  
!    \param c an array of Bï¿½zier segments
  
     \author Alejandro Frangi
     \date 30 July 1998
diff -crB nurbs++-3.0.11_Patch1//nurbs/nurbs.h nurbs++-3.0.11/nurbs/nurbs.h
*** nurbs++-3.0.11_Patch1//nurbs/nurbs.h	2002-05-13 23:07:46.000000000 +0200
--- nurbs++-3.0.11/nurbs/nurbs.h	2011-07-05 10:18:02.358414837 +0200
***************
*** 58,63 ****
--- 58,64 ----
      class NurbsCurve : public ParaCurve<T,N>{
      public:
        NurbsCurve() ;
+       NurbsCurve(Matrix<T> inverse){Inverse = inverse; Inverse_setted=1;} //changed
        NurbsCurve(const NurbsCurve<T,N>& nurb) ;
        NurbsCurve(const Vector< HPoint_nD<T,N> >& P1, const Vector<T> &U1, int deg=3) ;
        NurbsCurve(const Vector< Point_nD<T,N> >& P1, const Vector<T> &W, const Vector<T> &U1, int deg=3) ;
***************
*** 105,112 ****
        
        // Basis functions
        T basisFun(T u, int i, int p=-1) const ;
!       void basisFuns(T u, int span, Vector<T>& N) const ;
!       void dersBasisFuns(int n,T u, int span, Matrix<T>& N) const;
        
        // Knot functions
        T minKnot() const //! the minimal value for the knot vector
--- 106,113 ----
        
        // Basis functions
        T basisFun(T u, int i, int p=-1) const ;
!       void basisFuns(T u, int span, Vector<T>& M) const ;
!       void dersBasisFuns(int n,T u, int span, Matrix<T>& M) const;
        
        // Knot functions
        T minKnot() const //! the minimal value for the knot vector
***************
*** 153,159 ****
        void globalInterpH(const Vector< HPoint_nD<T,N> >& Q, int d);
        void globalInterpH(const Vector< HPoint_nD<T,N> >& Q, const Vector<T>& U, int d);
        void globalInterpH(const Vector< HPoint_nD<T,N> >& Q, const Vector<T>& ub, const Vector<T>& U, int d);
-       
        void globalInterpClosed(const Vector< Point_nD<T,N> >& Qw, int d);
        void globalInterpClosed(const Vector< Point_nD<T,N> >& Qw, const Vector<T>& ub, int d);
        void globalInterpClosedH(const Vector< HPoint_nD<T,N> >& Qw, int d);
--- 154,159 ----
***************
*** 162,168 ****
        void globalInterpClosed(const Vector< Point_nD<T,N> >& Qw, const Vector<T>& ub, const Vector<T>& Uc, int d);
        
        void globalInterpD(const Vector< Point_nD<T,N> >& Q, const Vector< Point_nD<T,N> >& D, int d, int unitD, T a=1.0);
!       
        void projectTo(const Point_nD<T,N>& p, T guess, T& u, Point_nD<T,N>& r, T e1=0.001, T e2=0.001,int maxTry=100) const;
        
        
--- 162,171 ----
        void globalInterpClosed(const Vector< Point_nD<T,N> >& Qw, const Vector<T>& ub, const Vector<T>& Uc, int d);
        
        void globalInterpD(const Vector< Point_nD<T,N> >& Q, const Vector< Point_nD<T,N> >& D, int d, int unitD, T a=1.0);
!      
!       Matrix<T> computeInverse(const Vector<T> &v, const Vector<T> &V, const int p);
!       Matrix<T> computeInverseClosed(const Vector<T> &v, const Vector<T> &V, const int p);
! 
        void projectTo(const Point_nD<T,N>& p, T guess, T& u, Point_nD<T,N>& r, T e1=0.001, T e2=0.001,int maxTry=100) const;
        
        
***************
*** 237,242 ****
--- 240,248 ----
        Vector< HPoint_nD<T,N> > P; // the vector of control points
        Vector<T> U ;  // the knot vector
        int deg_ ;  // the degree of the NURBS curve
+ 
+       Matrix<T> Inverse; //changed
+       int Inverse_setted; //changed
      };
    
    typedef NurbsCurve<float,3> NurbsCurvef ;
diff -crB nurbs++-3.0.11_Patch1//nurbs/nurbsS.cpp nurbs++-3.0.11/nurbs/nurbsS.cpp
*** nurbs++-3.0.11_Patch1//nurbs/nurbsS.cpp	2011-08-31 13:05:50.136280385 +0200
--- nurbs++-3.0.11/nurbs/nurbsS.cpp	2011-08-31 11:55:55.004406370 +0200
***************
*** 741,748 ****
      else {
        d = 0.0 ;
        for(k=1;k<n;k++){
! 	d += cds[k] ;
! 	uk[k] += d/total ;
        }
      }
    }
--- 741,748 ----
      else {
        d = 0.0 ;
        for(k=1;k<n;k++){
!     	d += cds[k] ;
!         uk[k] += d/total ;
        }
      }
    }
***************
*** 3417,3429 ****
  }
  
  /*!
!   \brief Decompose the surface into Bézier patches
  
!   This function decomposes the curve into an array of homogenous Bézier 
    patches.
  
!   \param S  an array of Bézier segments
!   \return The number of Bézier strips in the u direction.
  
    \author Philippe Lavoie
    \date 8 October, 1997
--- 3420,3432 ----
  }
  
  /*!
!   \brief Decompose the surface into Bï¿½zier patches
  
!   This function decomposes the curve into an array of homogenous Bï¿½zier 
    patches.
  
!   \param S  an array of Bï¿½zier segments
!   \return The number of Bï¿½zier strips in the u direction.
  
    \author Philippe Lavoie
    \date 8 October, 1997
***************
*** 3999,4005 ****
    \date 8 October, 1997
  */
  template <class T, int N>
! int NurbsSurface<T,N>::writeRIB(const char* filename, const Color& col, const Point_nD<T,N>& view) const {
    ofstream fout(filename) ;
    if(!fout)
      return 0;
--- 4002,4008 ----
    \date 8 October, 1997
  */
  template <class T, int N>
! int NurbsSurface<T,N>::writeRIB(char* filename, const Color& col, const Point_nD<T,N>& view) const {
    ofstream fout(filename) ;
    if(!fout)
      return 0;
***************
*** 4554,4559 ****
--- 4557,4633 ----
  
  }
  
+ /*!
+   \brief Generates a surface using global interpolation.
+ 
+   Generates a NURBS surface using global interpolation. In the u direction
+   the curve will be closed and with C(pU-1) continuity. Each column in Q
+   indicates the points for a closed curve in the u
+   direction. First and last point have to be equal.
+ 
+   \param  Q  a matrix of 3D points (wrapped in u dir. -rows)
+   \param Uk  a valid U-vector
+   \param Vk  a valid V-vector
+   \param uk  a valid u-vector
+   \param vk  a valid v-vector
+   \param pU  the degree of interpolation in the U direction
+   \param pV  the degree of interpolation in the V direction
+ 
+   \author Kilian Grundl
+   \date 19 July, 2011
+ */
+ template <class T, int N>
+ void NurbsSurface<T,N>::globalInterpClosedU(const Matrix< Point_nD<T,N> >& Q,const Vector<T> &Uk, const Vector<T> &Vk, const Vector<T> &uk, const Vector<T> &vk, int pU, int pV){
+   //Vector<T> vk,uk ;
+ 
+ 
+   if(degU != pU || degV != pV || U != Uk || V != Vk)
+    {
+       NurbsCurve<T,N> C1;
+       InverseV = C1.computeInverse(vk,Vk,pV);
+       NurbsCurve<T,N> C2;
+       InverseU = C2.computeInverseClosed(uk,Uk,pU);
+    }
+ 
+   resize(Q.rows(),Q.cols(),pU,pV) ;
+ 
+   //surfMeshParamsClosedU(Q,uk,vk,pU) ;
+   //knotAveragingClosed(uk,pU,U) ;
+   //knotAveraging(vk,pV,V) ;
+ 
+   U = Uk;
+   V = Vk;
+   //degU = pU;
+   //degV = pV;
+ 
+   Vector< HPoint_nD<T,N> > Pts(Q.cols()) ;
+ 
+   NurbsCurve<T,N> CV(InverseV);
+   
+   int i,j ;
+   for(i=0;i<Q.rows();i++){
+     for(j=0;j<Q.cols();j++)
+       Pts[j] = Q(i,j) ;
+     CV.globalInterpH(Pts,vk,V,degV) ;
+     for(j=0;j<Q.cols();j++)
+       P(i,j) = CV.ctrlPnts(j) ;
+   }
+ 
+   NurbsCurve<T,N> CU(InverseU);
+ 
+   Pts.resize(Q.rows()) ;
+   for(j=0;j<Q.cols();j++){
+     for(i=0;i<Q.rows();i++)
+       Pts[i] = P(i,j) ;
+     
+     CU.globalInterpClosedH(Pts,uk,U,degU);
+     for(i=0;i<Q.rows();i++)
+       P(i,j) = CU.ctrlPnts(i) ;
+   }
+ 
+ }
+ 
+ 
  /*! 
    \brief Generates a surface using global interpolation. 
  
***************
*** 4602,4607 ****
--- 4676,4752 ----
    }
  }
  
+ /*!
+   \brief Generates a surface using global interpolation.
+ 
+   Generates a NURBS surface using global interpolation. In the u direction
+   the curve will be closed and with C(pU-1) continuity. Each column in Q
+   indicates the points for a closed curve in the u
+   direction. First and last point have to be equal.
+ 
+   \param  Q  a matrix of 3D points (wrapped in u dir. -rows)
+   \param Uk  a valid U-vector
+   \param Vk  a valid V-vector
+   \param uk  a valid u-vector
+   \param vk  a valid v-vector
+   \param pU  the degree of interpolation in the U direction
+   \param pV  the degree of interpolation in the V direction
+ 
+   \author Kilian Grundl
+   \date 19 July, 2011
+ */
+ template <class T, int N>
+ void NurbsSurface<T,N>::globalInterpClosedUH(const Matrix< HPoint_nD<T,N> >& Q,const Vector<T> &Uk, const Vector<T> &Vk, const Vector<T> &uk, const Vector<T> &vk, int pU, int pV){
+   //Vector<T> vk,uk ;
+ 
+ 
+   if(degU != pU || degV != pV || U != Uk || V != Vk)
+    {
+       NurbsCurve<T,N> C1;
+       InverseV = C1.computeInverse(vk,Vk,pV);
+       NurbsCurve<T,N> C2;
+       InverseU = C2.computeInverseClosed(uk,Uk,pU);
+    }
+ 
+   resize(Q.rows(),Q.cols(),pU,pV) ;
+ 
+   //surfMeshParamsClosedU(Q,uk,vk,pU) ;
+   //knotAveragingClosed(uk,pU,U) ;
+   //knotAveraging(vk,pV,V) ;
+ 
+   U = Uk;
+   V = Vk;
+ 
+   //degU = pU;
+   //degV = pV;
+ 
+   Vector< HPoint_nD<T,N> > Pts(Q.cols()) ;
+ 
+   NurbsCurve<T,N> CV(InverseV);
+ 
+   int i,j ;
+   for(i=0;i<Q.rows();i++){
+     for(j=0;j<Q.cols();j++)
+       Pts[j] = Q(i,j) ;
+     CV.globalInterpH(Pts,vk,V,degV) ;
+     for(j=0;j<Q.cols();j++)
+       P(i,j) = CV.ctrlPnts(j) ;
+   }
+ 
+   NurbsCurve<T,N> CU(InverseU);
+ 
+   Pts.resize(Q.rows()) ;
+   for(j=0;j<Q.cols();j++){
+     for(i=0;i<Q.rows();i++)
+       Pts[i] = P(i,j) ;
+ 
+     CU.globalInterpClosedH(Pts,uk,U,degU);
+     for(i=0;i<Q.rows();i++)
+       P(i,j) = CU.ctrlPnts(i) ;
+   }
+ 
+ }
+ 
  
  /*! 
    \brief Generates a closed surface using global least squares approximation. 
diff -crB nurbs++-3.0.11_Patch1//nurbs/nurbsS.h nurbs++-3.0.11/nurbs/nurbsS.h
*** nurbs++-3.0.11_Patch1//nurbs/nurbsS.h	2002-05-13 23:07:46.000000000 +0200
--- nurbs++-3.0.11/nurbs/nurbsS.h	2011-07-19 15:28:43.885405130 +0200
***************
*** 99,106 ****
    virtual HPoint_nD<T,N> operator()(T u, T v) const ;
  
    void basisFuns(T u, T v, int spanU, int spanV, Vector<T>& Nu, Vector<T>& Nv) const ;
!   void basisFunsU(T u, int span, Vector<T>& N) const ;
!   void basisFunsV(T u, int span, Vector<T>& N) const ;
    void dersBasisFuns(T u, T v, int dU, int dV,int uspan, int vspan,Matrix<T> & Niku, Matrix<T>& Njkv ) const ; 
  
    // Derivative functions
--- 99,106 ----
    virtual HPoint_nD<T,N> operator()(T u, T v) const ;
  
    void basisFuns(T u, T v, int spanU, int spanV, Vector<T>& Nu, Vector<T>& Nv) const ;
!   void basisFunsU(T u, int span, Vector<T>& M) const ;
!   void basisFunsV(T u, int span, Vector<T>& M) const ;
    void dersBasisFuns(T u, T v, int dU, int dV,int uspan, int vspan,Matrix<T> & Niku, Matrix<T>& Njkv ) const ; 
  
    // Derivative functions
***************
*** 114,120 ****
--- 114,122 ----
    void globalInterp(const Matrix< Point_nD<T,N> >& Q, int pU, int pV);
    void globalInterpH(const Matrix< HPoint_nD<T,N> >& Q, int pU, int pV);
    void globalInterpClosedU(const Matrix< Point_nD<T,N> >& Q, int pU, int pV);
+   void globalInterpClosedU(const Matrix< Point_nD<T,N> >& Q,const Vector<T> &Uk, const Vector<T> &Vk, const Vector<T> &uk, const Vector<T> &vk, int pU, int pV);//testing
    void globalInterpClosedUH(const Matrix< HPoint_nD<T,N> >& Q, int pU, int pV);
+   void globalInterpClosedUH(const Matrix< HPoint_nD<T,N> >& Q,const Vector<T> &Uk, const Vector<T> &Vk, const Vector<T> &uk, const Vector<T> &vk, int pU, int pV);//testing
    void leastSquares(const Matrix< Point_nD<T,N> >& Q, int pU, int pV, int nU, int nV) ;
    void leastSquaresClosedU(const Matrix< Point_nD<T,N> >& Q, int pU, int pV, int nU, int nV) ;
  
***************
*** 135,142 ****
    int skinU(NurbsCurveArray<T,N>& ca, int degU);
    void sweep(const NurbsCurve<T,N>& t, const NurbsCurve<T,N>& C, const NurbsCurve<T,N>& Sv, int K,int useAy=0, int invAz=0) ;
    void sweep(const NurbsCurve<T,N>& t, const NurbsCurve<T,N>& C, int K,int useAy=0, int invAz=0) ;
!   void makeFromRevolution(const NurbsCurve<T,N>& profile, const Point_nD<T,N>& S, const Point_nD<T,N>& T, double theta) ;
!   void makeFromRevolution(const NurbsCurve<T,N>& profile, const Point_nD<T,N>& S, const Point_nD<T,N>& T) ;
    void makeFromRevolution(const NurbsCurve<T,N>& profile) ;
  
    void makeSphere(const Point_nD<T,N>& O, T r) ; 
--- 137,144 ----
    int skinU(NurbsCurveArray<T,N>& ca, int degU);
    void sweep(const NurbsCurve<T,N>& t, const NurbsCurve<T,N>& C, const NurbsCurve<T,N>& Sv, int K,int useAy=0, int invAz=0) ;
    void sweep(const NurbsCurve<T,N>& t, const NurbsCurve<T,N>& C, int K,int useAy=0, int invAz=0) ;
!   void makeFromRevolution(const NurbsCurve<T,N>& profile, const Point_nD<T,N>& S, const Point_nD<T,N>& Z, double theta) ;
!   void makeFromRevolution(const NurbsCurve<T,N>& profile, const Point_nD<T,N>& S, const Point_nD<T,N>& Z) ;
    void makeFromRevolution(const NurbsCurve<T,N>& profile) ;
  
    void makeSphere(const Point_nD<T,N>& O, T r) ; 
***************
*** 202,208 ****
    int writePOVRAY(T tolerance, const char *filename, const Color& color, const Point_nD<T,N>& view, const Point_nD<T,N>& up, int smooth=0, T ambient=0.2, T diffuse=0.6) const ;
  
    int writeRIB(ostream& rib) const ;
!   int writeRIB(const char* filename, const Color& color, const Point_nD<T,N>& view) const ;
   
    // tesselate is deprecated...
    void tesselate(T tolerance, BasicList<Point_nD<T,N> > &points, BasicList<int> &connect, BasicList<Point_nD<T,N> > *normal=0) const ;
--- 203,209 ----
    int writePOVRAY(T tolerance, const char *filename, const Color& color, const Point_nD<T,N>& view, const Point_nD<T,N>& up, int smooth=0, T ambient=0.2, T diffuse=0.6) const ;
  
    int writeRIB(ostream& rib) const ;
!   int writeRIB(char* filename, const Color& color, const Point_nD<T,N>& view) const ;
   
    // tesselate is deprecated...
    void tesselate(T tolerance, BasicList<Point_nD<T,N> > &points, BasicList<int> &connect, BasicList<Point_nD<T,N> > *normal=0) const ;
***************
*** 244,249 ****
--- 245,254 ----
    Matrix< HPoint_nD<T,N> > P ; //!< The matrix of control points
    int degU ; //!< the degree of the surface in U
    int degV ; //!< the degree of the surface in V
+   
+   //changed 
+   Matrix<T> InverseU; //!< The matrix for the compution of the control points in U-direction
+   Matrix<T> InverseV; //!< The matrix for the compution of the control points in V-direction
  
  };
  
