diff -ur nurbs++-3.0.11_P1/image/color.h nurbs++-3.0.11_P2//image/color.h
--- nurbs++-3.0.11_P1/image/color.h	2002-05-13 23:07:45.000000000 +0200
+++ nurbs++-3.0.11_P2//image/color.h	2011-09-09 20:46:01.478708001 +0200
@@ -28,6 +28,8 @@
 #include "matrix_global.h"
 #include "matrixTool.h"
 
+#include <limits>
+
 /*!
  */
 namespace PLib {
@@ -253,7 +255,7 @@
     \date 14 May 1999
    */
   inline void Color::fromHSV(double h, double s, double v){
-    if(s==0.0){
+    if(abs(s)<std::numeric_limits<double>::epsilon()){
       r=g=b=0;
       return;
     }
diff -ur nurbs++-3.0.11_P1/numerical/matrixMat.cpp nurbs++-3.0.11_P2//numerical/matrixMat.cpp
--- nurbs++-3.0.11_P1/numerical/matrixMat.cpp	2011-09-09 20:56:57.058708001 +0200
+++ nurbs++-3.0.11_P2//numerical/matrixMat.cpp	2011-09-09 21:04:56.178708002 +0200
@@ -250,6 +250,9 @@
 template <class T>
 void LUMatrix<T>::inverseIn(Matrix<T>& inv) 
 {
+  if(Matrix<T>::rows() > 14)
+    cout << "WARNING in LUMatrix<T>::inverseIn: There are errors in this routine (or class) that should be solved!\n They have been discovered when using a closed interpolation of a nurbs curve with more than 14 interpolated points.\n Solve them or use the SVD-Solver as it seems to work more reliable." << endl;
+
   T ten;
   int i, j, k, l, kb, kp1, nm1, n, coln;
 
@@ -1025,8 +1028,8 @@
 
   Solves the linear system \a A \a X = \a B. Given \a A and B it
   finds the value of \a X. The routine uses LU decomposition
-  if the A matrix is square and it uses SVD decomposition
-  otherwise.
+  if the A matrix is square and its dimension is less than 14.
+  It uses SVD decomposition otherwise.
 
   \param   A  the \a A matrix
   \param B  the right hand side of the equation
@@ -1041,7 +1044,8 @@
 int solve(const Matrix<T>& A, 
 	   const Matrix<T>& B, 
 	   Matrix<T>& X){
-  if(A.rows()==A.cols()){ 
+  if(A.rows()==A.cols() and A.rows() < 14){
+    // lu.inverse() seems not be relieable for more than about 14 interpolation points (just try an example for a (closed) circle with 14 points) and you will see ...
     // use LU decomposition to solve the problem
     LUMatrix<T> lu(A) ;
     X = lu.inverse()*B ;
@@ -1057,7 +1061,8 @@
   \brief finds the inverse of a matrix
 
   Finds the inverse of a matrix. It uses LU decomposition if
-  the matrix is square and it uses SVD decomposition otherwise.
+  the matrix is square and the dimension of A is < 14.
+  It uses SVD decomposition otherwise.
 
   \param A  the matrix to inverse
 
@@ -1072,7 +1077,8 @@
 template <class T>
 Matrix<T> inverse(const Matrix<T>&A){
   Matrix<T> inv ;
-  if(A.rows()==A.cols()){
+  if(A.rows()==A.cols()  and A.rows() < 14){
+    // lu.inverse() seems not be relieable for more than about 14 interpolation points (just try an example for a (closed) circle with 14 points) and you will see ...
     LUMatrix<T> lu(A) ;
     lu.inverseIn(inv) ;
   }
diff -ur nurbs++-3.0.11_P1/nurbs/d_surface.cpp nurbs++-3.0.11_P2//nurbs/d_surface.cpp
--- nurbs++-3.0.11_P1/nurbs/d_surface.cpp	2011-09-09 20:56:57.068708001 +0200
+++ nurbs++-3.0.11_P2//nurbs/d_surface.cpp	2011-09-09 20:46:01.478708001 +0200
@@ -25,9 +25,7 @@
   template class InterPoint<double,2> ;
   template class InterPoint<double,3> ;
   
-  //TODO: External patcher's comment: BasicList not in PLib namespace?
-  //template class BasicList<InterPoint<double,2> > ; 
-  //template class BasicList<InterPoint<double,3> > ; 
+
   
   template class ParaSurface<double,2> ;
   template class ParaSurface<double,3> ;
@@ -38,3 +36,6 @@
 #endif 
 
 }
+
+template class BasicList<PLib::InterPoint<double,2> > ; 
+template class BasicList<PLib::InterPoint<double,3> > ; 
diff -ur nurbs++-3.0.11_P1/nurbs/f_surface.cpp nurbs++-3.0.11_P2//nurbs/f_surface.cpp
--- nurbs++-3.0.11_P1/nurbs/f_surface.cpp	2011-09-09 20:56:57.068708001 +0200
+++ nurbs++-3.0.11_P2//nurbs/f_surface.cpp	2011-09-09 20:46:01.478708001 +0200
@@ -26,9 +26,7 @@
   template class InterPoint<float,3> ;
  
 
-//This breaks the "NO_IMPLICIT_TEMPLATES" thingy. Does BasicList not belong to PLib? 
-//  template class BasicList<InterPoint<float,2> > ; 
-//  template class BasicList<InterPoint<float,3> > ; 
+
   
   template class ParaSurface<float,2> ;
   template class ParaSurface<float,3> ;
@@ -40,3 +38,6 @@
 #endif 
 
 }
+
+template class BasicList<PLib::InterPoint<float,2> > ; 
+template class BasicList<PLib::InterPoint<float,3> > ; 
diff -ur nurbs++-3.0.11_P1/nurbs/nurbs.cpp nurbs++-3.0.11_P2//nurbs/nurbs.cpp
--- nurbs++-3.0.11_P1/nurbs/nurbs.cpp	2011-09-09 20:56:57.068708001 +0200
+++ nurbs++-3.0.11_P2//nurbs/nurbs.cpp	2011-09-09 21:13:38.468708002 +0200
@@ -40,7 +40,7 @@
   \date 24 January 1997
 */
 template <class T, int N>
-NurbsCurve<T,N>::NurbsCurve(): P(1),U(1),deg_(0)
+NurbsCurve<T,N>::NurbsCurve(): P(1),U(1),deg_(0),Inverse_setted(0)
 {
 }
 
@@ -54,8 +54,8 @@
 */
 template <class T, int N>
 NurbsCurve<T,N>::NurbsCurve(const NurbsCurve<T,N>& nurb): 
-  ParaCurve<T,N>(), P(nurb.P),U(nurb.U),deg_(nurb.deg_)
-{
+  ParaCurve<T,N>(), P(nurb.P),U(nurb.U),deg_(nurb.deg_) {
+  Inverse_setted = 0;
 }
 
 /*!
@@ -74,6 +74,7 @@
   int nSize = P1.n() ;
   int mSize = U1.n() ;
   deg_ = Degree ;
+  Inverse_setted = 0;
   if(nSize != mSize-deg_-1){
 #ifdef USE_EXCEPTION
     throw NurbsSizeError(P1.n(),U1.n(),Degree) ;
@@ -106,7 +107,7 @@
 template <class T, int N>
 NurbsCurve<T,N>::NurbsCurve(const Vector< HPoint_nD<T,N> >& P1, const Vector<T> &U1, int Degree): P(P1), U(U1), deg_(Degree) 
 {
-
+ Inverse_setted=0;
   if(P.n() != U.n()-deg_-1){
 #ifdef USE_EXCEPTION
     throw NurbsSizeError(P.n(),U.n(),deg_) ;
@@ -138,6 +139,7 @@
 {
   int nSize = P1.n() ;
   int mSize = U1.n() ;
+  Inverse_setted=0;
 
   if(nSize != mSize-deg_-1){
 #ifdef USE_EXCEPTION
@@ -385,7 +387,8 @@
   \author Philippe Lavoie 
   \date 25 July 1997
 */
-template<> template <class T, int N>
+template<>
+template <class T, int N>
 NurbsSurface<T,3> NurbsCurve<T,N>::drawAaImg(Image_Color& Img, const Color& color, const NurbsCurve<T,3>& profile, const NurbsCurve<T,3>& scaling, int precision, int alpha){
   Matrix<T> addMatrix ;
   Matrix_INT nMatrix ;
@@ -471,7 +474,8 @@
   \author Philippe Lavoie 
   \date 22 August 1997
 */
-template<> template <class T, int N>
+template<>
+template <class T, int N>
 void NurbsCurve<T,N>::transform(const MatrixRT<T>& A){
   for(int i=P.n()-1;i>=0;--i)
     P[i] = A*P[i] ;
@@ -502,7 +506,8 @@
   \author Philippe Lavoie 
   \date 24 January, 1997
 */
-template<> template <class T, int N>
+template<>
+template <class T, int N>
 HPoint_nD<T,N> NurbsCurve<T,N>::operator()(T u) const{
   static Vector<T> Nb ;
   int span = findSpan(u) ;
@@ -541,7 +546,8 @@
   \author Philippe Lavoie    
   \date 24 January, 1997
 */
-template<> template <class T, int N>
+template<>
+template <class T, int N>
 HPoint_nD<T,N> NurbsCurve<T,N>::hpointAt(T u, int span) const{
   static Vector<T> Nb ;
 
@@ -594,7 +600,8 @@
   \author  Philippe Lavoie
   \date 24 January, 1997
 */
-template<> template <class T, int N>
+template<>
+template <class T, int N>
 HPoint_nD<T,N> NurbsCurve<T,N>::derive(T u, int d) const {
   Vector< HPoint_nD<T,N> > ders ;
   deriveAtH(u,d,ders) ;
@@ -617,7 +624,8 @@
   \author  Philippe Lavoie
   \date 24 January, 1997
 */
-template<> template <class T, int N>
+template<>
+template <class T, int N>
 void NurbsCurve<T,N>::deriveAtH(T u,int d, Vector< HPoint_nD<T,N> >& ders) const{
   int du = minimum(d,deg_) ;
   int span ;
@@ -2858,7 +2866,7 @@
 
 
   resize(Q.n(),d) ;
-  Matrix_DOUBLE A(Q.n(),Q.n()) ;
+  Matrix<T> A(Q.n(), Q.n());
 
   knotAveraging(ub,d,U) ;
 
@@ -2875,14 +2883,15 @@
   A(Q.n()-1,Q.n()-1) = 1.0 ;
 
   // Init matrix for LSE
-  Matrix_DOUBLE qq(Q.n(),D) ;
-  Matrix_DOUBLE xx(Q.n(),D) ;
+  Matrix<T> qq(Q.n(), D);
+  Matrix<T> xx(Q.n(), D);
   for(i=0;i<Q.n();i++){
     const Point_nD<T,D>& qp = Q[i] ; // this makes the SGI compiler happy
     for(j=0; j<D;j++)
       qq(i,j) = (double)qp.data[j] ;
   }
 
+  //TODO: add same routine as in the globalInterpH-case
   solve(A,qq,xx) ;
 
   // Store the data
@@ -3101,6 +3110,94 @@
 }
 
 /*!
+  \brief  computes the Inverse for the compution of the control-points
+
+  \param v  kind of "span"-vector
+  \param V  a valid knot-vector
+  \param p  the degree of the curve
+  
+  \warning v and V have to be valid 
+  \author Philippe Lavoie 
+  \date 3 September, 1997
+*/
+template <class T, int D>
+Matrix<T> NurbsCurve<T,D>::computeInverse(const Vector<T> &v, const Vector<T> &V, const int p){  //changed 
+
+  int i,j;
+  int iN = V.n()-p-1;
+
+  resize(iN,p); //so findSpan works ... V has to be a valid knot-vector!!!!
+
+  U = V;
+
+  Matrix<T> A(iN,iN);
+
+ 
+  // Initialize the basis matrix A
+  Vector<T> N(p+1) ;
+
+  for(i=1;i<iN-1;i++){
+    int span = findSpan(v[i]);
+    basisFuns(v[i],span,N) ;
+    for(j=0;j<=p;j++) 
+	A(i,span-p+j) = (double)N[j] ;
+  }
+  A(0,0)  = 1.0 ;
+  A(iN-1,iN-1) = 1.0 ;
+
+  Inverse = inverse(A);
+  
+//  LUMatrix<T> lu(A);
+//  Inverse = lu.inverse();
+  Inverse_setted=1;
+  return Inverse;
+
+}
+
+/*!
+  \brief  computes the Inverse for the compution of the control-points on a closed curve
+
+  \param v  kind of "span"-vector
+  \param V  a valid knot-vector
+  \param p  the degree of the curve
+  
+  \warning v and V have to be valid 
+  \author Philippe Lavoie 
+  \date 3 September, 1997
+*/
+template <class T, int D>
+Matrix<T> NurbsCurve<T,D>::computeInverseClosed(const Vector<T> &v, const Vector<T> &V, const int p){  //changed
+
+  int i,j ;
+  int iN = V.n() - p - 1 - p - 1;
+
+  resize(V.n()-p-1,p); //so findSpan works ... V has to be a valid knot-vector!!!!
+
+  U = V;
+
+  Matrix<T> A(iN+1,iN+1) ;
+
+
+  // Initialize the basis matrix A
+  Vector<T> N(p+1) ;
+
+  for(i=0;i<=iN;i++){
+    int span = findSpan(v[i]);
+    basisFuns(v[i],span,N) ;
+    for(j=span-p;j<=span;j++) 
+      A(i,j%(iN+1)) = (double)N[j-span+p] ;
+  }
+
+  Inverse = inverse(A);
+
+//  LUMatrix<T> lu(A);
+//  Inverse = lu.inverse();
+  Inverse_setted=1;
+  return Inverse;
+}
+
+
+/*!
   \brief global curve interpolation with points in 4D
 
   Global curve interpolation with points in 4D
@@ -3119,7 +3216,7 @@
   int i,j ;
 
   resize(Q.n(),d) ;
-  Matrix_DOUBLE A(Q.n(),Q.n()) ;
+//  Matrix<T> A(Q.n(), Q.n());
   Vector<T> ub(Q.n()) ;
 
   chordLengthParamH(Q,ub) ;
@@ -3136,34 +3233,36 @@
     U[j+deg_] = t/(T)deg_ ;
   }
   
-  // Initialize the basis matrix A
-  Vector<T> N(deg_+1) ;
+  globalInterpH(Q,ub,U,d);
 
-  for(i=1;i<Q.n()-1;i++){
-    int span = findSpan(ub[i]);
-    basisFuns(ub[i],span,N) ;
-    for(j=0;j<=deg_;j++) 
-	A(i,span-deg_+j) = (double)N[j] ;
+//  // Initialize the basis matrix A
+//  Vector < T > N(deg_ + 1);
+//
+//  for (i = 1; i < Q.n() - 1; i++) {
+//    int span = findSpan(ub[i]);
+//    basisFuns(ub[i], span, N);
+//    for (j = 0; j <= deg_; j++)
+//      A(i, span - deg_ + j) = (double) N[j];
+//  }
+//  A(0, 0) = 1.0;
+//  A(Q.n() - 1, Q.n() - 1) = 1.0;
+//
+//  // Init matrix for LSE
+//  Matrix<T> qq(Q.n(), D + 1);
+//  Matrix<T> xx(Q.n(), D + 1);
+//  for (i = 0; i < Q.n(); i++)
+//    for (j = 0; j < D + 1; j++)
+//      qq(i, j) = (double) Q[i].data[j];
+//
+//  SVDMatrix<double> svd(A);
+//  svd.solve(qq, xx);
+//
+//  // Store the data
+//  for (i = 0; i < xx.rows(); i++) {
+//    for (j = 0; j < D + 1; j++)
+//      P[i].data[j] = (T) xx(i, j);
   }
-  A(0,0)  = 1.0 ;
-  A(Q.n()-1,Q.n()-1) = 1.0 ;
 
-  // Init matrix for LSE
-  Matrix_DOUBLE qq(Q.n(),D+1) ;
-  Matrix_DOUBLE xx(Q.n(),D+1) ;
-  for(i=0;i<Q.n();i++)
-    for(j=0; j<D+1;j++)
-      qq(i,j) = (double)Q[i].data[j] ;
-
-  solve(A,qq,xx) ;
-
-  // Store the data
-  for(i=0;i<xx.rows();i++){
-    for(j=0;j<D+1;j++)
-      P[i].data[j] = (T)xx(i,j) ;
-  }
-
-}
 
 /*!
   \brief global curve interpolation with 4D points and a knot vector defined.
@@ -3186,7 +3285,7 @@
   int i,j ;
 
   resize(Q.n(),d) ;
-  Matrix_DOUBLE A(Q.n(),Q.n()) ;
+  Matrix<T> A(Q.n(), Q.n());
   Vector<T> ub(Q.n()) ;
 
   if(Uc.n() != U.n()){
@@ -3202,34 +3301,36 @@
   U = Uc ;
   chordLengthParamH(Q,ub) ;
   
-  // Initialize the basis matrix A
-  Vector<T> N(deg_+1) ;
-
-  for(i=1;i<Q.n()-1;i++){
-    int span = findSpan(ub[i]);
-    basisFuns(ub[i],span,N) ;
-    for(j=0;j<=deg_;j++) 
-	A(i,span-deg_+j) = (double)N[j] ;
-  }
-  A(0,0)  = 1.0 ;
-  A(Q.n()-1,Q.n()-1) = 1.0 ;
-
-  // Init matrix for LSE
-  Matrix_DOUBLE qq(Q.n(),D+1) ;
-  Matrix_DOUBLE xx(Q.n(),D+1) ;
-  for(i=0;i<Q.n();i++)
-    for(j=0; j<D+1;j++)
-      qq(i,j) = (double)Q[i].data[j] ;
-
-  solve(A,qq,xx) ;
+  globalInterpH(Q,ub,Uc,d);
 
-  // Store the data
-  for(i=0;i<xx.rows();i++){
-    for(j=0;j<D+1;j++)
-      P[i].data[j] = (T)xx(i,j) ;
+//  // Initialize the basis matrix A
+//  Vector < T > N(deg_ + 1);
+//
+//  for (i = 1; i < Q.n() - 1; i++) {
+//    int span = findSpan(ub[i]);
+//    basisFuns(ub[i], span, N);
+//    for (j = 0; j <= deg_; j++)
+//      A(i, span - deg_ + j) = (double) N[j];
+//  }
+//  A(0, 0) = 1.0;
+//  A(Q.n() - 1, Q.n() - 1) = 1.0;
+//
+//  // Init matrix for LSE
+//  Matrix<T> qq(Q.n(), D + 1);
+//  Matrix<T> xx(Q.n(), D + 1);
+//  for (i = 0; i < Q.n(); i++)
+//    for (j = 0; j < D + 1; j++)
+//      qq(i, j) = (double) Q[i].data[j];
+//
+//  SVDMatrix<double> svd(A);
+//  svd.solve(qq, xx);
+//
+//  // Store the data
+//  for (i = 0; i < xx.rows(); i++) {
+//    for (j = 0; j < D + 1; j++)
+//      P[i].data[j] = (T) xx(i, j);
   }
 
-}
 
 /*!
   \brief global curve interpolation with 4D points, 
@@ -3256,7 +3357,6 @@
   int i,j ;
 
   resize(Q.n(),d) ;
-  Matrix_DOUBLE A(Q.n(),Q.n()) ;
 
   if(Uc.n() != U.n()){
 #ifdef USE_EXCEPTION
@@ -3269,27 +3369,18 @@
 #endif
   }
   U = Uc ;
-  
-  // Initialize the basis matrix A
-  Vector<T> N(deg_+1) ;
-
-  for(i=1;i<Q.n()-1;i++){
-    int span = findSpan(ub[i]);
-    basisFuns(ub[i],span,N) ;
-    for(j=0;j<=deg_;j++) 
-	A(i,span-deg_+j) = (double)N[j] ;
-  }
-  A(0,0)  = 1.0 ;
-  A(Q.n()-1,Q.n()-1) = 1.0 ;
 
   // Init matrix for LSE
-  Matrix_DOUBLE qq(Q.n(),D+1) ;
-  Matrix_DOUBLE xx(Q.n(),D+1) ;
+  Matrix<T> qq(Q.n(),D+1) ;
+  Matrix<T> xx(Q.n(),D+1) ;
   for(i=0;i<Q.n();i++)
     for(j=0; j<D+1;j++)
       qq(i,j) = (double)Q[i].data[j] ;
 
-  solve(A,qq,xx) ;
+  if (Inverse_setted != 1) //changed
+    computeInverse(ub, Uc, d);
+
+  xx = Inverse * qq;
 
   // Store the data
   for(i=0;i<xx.rows();i++){
@@ -3958,14 +4049,14 @@
 
 
 /*!
-  \brief Decompose the curve into Bézier segments
+  \brief Decompose the curve into BÃ©zier segments
 
-  This function decomposes the curve into an array of 4D Bézier 
+  This function decomposes the curve into an array of 4D BÃ©zier 
   segments.
 
-  \param c  an array of Bézier segments
+  \param c  an array of BÃ©zier segments
 
-  \warning The end Bézier segments will not be valid if the NURBS curve 
+  \warning The end BÃ©zier segments will not be valid if the NURBS curve 
            is not clamped.
 
   \author Philippe Lavoie
@@ -5300,7 +5391,7 @@
   }
   else{
     for(int i=0;i<ca.n();++i){
-      list2 = ca[i].tesselate(tolerance,uk) ;
+      list2 = ca[i].tesselate(tolerance,uk);
 
       // remove the last point from the list to elliminate
       list.erase((BasicNode<Point_nD<T,N> >*)list.last()) ;
@@ -6606,12 +6697,15 @@
 template <class T, int D>
 void NurbsCurve<T,D>::globalInterpClosed(const Vector< Point_nD<T,D> >& Qw,
 			const Vector<T>& ub, const Vector<T>& Uc, int d){
+			
+			cout << "WARNING: globalInterpClosed() doesn't work reliable. Use globalInterpClosedH() instead or better: try to find the cause of the problem!" << endl;
+			
   int i,j ;
 
   resize(Qw.n(),d) ;
 
   int iN = Qw.n() - d - 1;
-  Matrix_DOUBLE A(iN+1,iN+1) ;
+  Matrix<T> A(iN + 1, iN + 1);
   
   if(Uc.n() != U.n()){
 #ifdef USE_EXCEPTION
@@ -6636,8 +6730,8 @@
   }
 
   // Init matrix for LSE
-  Matrix_DOUBLE qq(iN+1,D) ;
-  Matrix_DOUBLE xx(iN+1,D) ;
+  Matrix<T> qq(iN + 1, D);
+  Matrix<T> xx(iN + 1, D);
   for(i=0;i<=iN ;i++)
     for(j=0; j<D;j++)
       qq(i,j) = (double)Qw[i].data[j] ;
@@ -6646,8 +6740,11 @@
   // using the SVD routine which works better when the system of
   // equations is very large (more than 50 points). Probably since in
   // this cases the system matrix A is very sparse.
-  SVDMatrix<double> svd(A) ;
-  svd.solve(qq,xx) ;
+
+  if (Inverse_setted != 1)
+    Inverse = computeInverseClosed(ub, Uc, d);
+
+  xx = Inverse * qq;
 
   // Store the data
   for(i=0;i<xx.rows();i++){
@@ -6689,7 +6786,6 @@
   resize(Qw.n(),d) ;
 
   int iN = Qw.n() - d - 1;
-  Matrix_DOUBLE A(iN+1,iN+1) ;
   
   if(Uc.n() != U.n()){
 #ifdef USE_EXCEPTION
@@ -6703,19 +6799,9 @@
   }
   U = Uc ;
 
-  // Initialize the basis matrix A
-  Vector<T> N(d+1) ;
-
-  for(i=0;i<=iN;i++){
-    int span = findSpan(ub[i]);
-    basisFuns(ub[i],span,N) ;
-    for(j=span-d;j<=span;j++) 
-      A(i,j%(iN+1)) = (double)N[j-span+d] ;
-  }
-
   // Init matrix for LSE
-  Matrix_DOUBLE qq(iN+1,D+1) ;
-  Matrix_DOUBLE xx(iN+1,D+1) ;
+  Matrix<T> qq(iN+1,D+1) ;
+  Matrix<T> xx(iN+1,D+1) ;
   for(i=0;i<=iN ;i++)
     for(j=0; j<D+1;j++)
       qq(i,j) = (double)Qw[i].data[j] ;
@@ -6724,8 +6810,11 @@
   // using the SVD routine which works better when the system of
   // equations is very large (more than 50 points). Probably since in
   // this cases the system matrix A is very sparse.
-  SVDMatrix<double> svd(A) ;
-  svd.solve(qq,xx) ;
+
+  if (Inverse_setted != 1)
+    Inverse = computeInverseClosed(ub, Uc, d);
+
+  xx = Inverse * qq;
 
   // Store the data
   for(i=0;i<xx.rows();i++){
@@ -6741,12 +6830,12 @@
 }
 
 /*!
-   \brief decompose the closed curve into Bézier segments
+   \brief decompose the closed curve into BÃ©zier segments
    
-   This function decomposes a closed curve into an array of Bézier 
+   This function decomposes a closed curve into an array of BÃ©zier 
    segments.
 
-   \param c an array of Bézier segments
+   \param c an array of BÃ©zier segments
 
    \author Alejandro Frangi
    \date 30 July 1998
diff -ur nurbs++-3.0.11_P1/nurbs/nurbs.h nurbs++-3.0.11_P2//nurbs/nurbs.h
--- nurbs++-3.0.11_P1/nurbs/nurbs.h	2002-05-13 23:07:46.000000000 +0200
+++ nurbs++-3.0.11_P2//nurbs/nurbs.h	2011-09-09 20:46:01.488708001 +0200
@@ -58,6 +58,7 @@
     class NurbsCurve : public ParaCurve<T,N>{
     public:
       NurbsCurve() ;
+      NurbsCurve(Matrix<T> inverse){Inverse = inverse; Inverse_setted=1;} //changed
       NurbsCurve(const NurbsCurve<T,N>& nurb) ;
       NurbsCurve(const Vector< HPoint_nD<T,N> >& P1, const Vector<T> &U1, int deg=3) ;
       NurbsCurve(const Vector< Point_nD<T,N> >& P1, const Vector<T> &W, const Vector<T> &U1, int deg=3) ;
@@ -105,8 +106,8 @@
       
       // Basis functions
       T basisFun(T u, int i, int p=-1) const ;
-      void basisFuns(T u, int span, Vector<T>& N) const ;
-      void dersBasisFuns(int n,T u, int span, Matrix<T>& N) const;
+      void basisFuns(T u, int span, Vector<T>& M) const ;
+      void dersBasisFuns(int n,T u, int span, Matrix<T>& M) const;
       
       // Knot functions
       T minKnot() const //! the minimal value for the knot vector
@@ -153,7 +154,6 @@
       void globalInterpH(const Vector< HPoint_nD<T,N> >& Q, int d);
       void globalInterpH(const Vector< HPoint_nD<T,N> >& Q, const Vector<T>& U, int d);
       void globalInterpH(const Vector< HPoint_nD<T,N> >& Q, const Vector<T>& ub, const Vector<T>& U, int d);
-      
       void globalInterpClosed(const Vector< Point_nD<T,N> >& Qw, int d);
       void globalInterpClosed(const Vector< Point_nD<T,N> >& Qw, const Vector<T>& ub, int d);
       void globalInterpClosedH(const Vector< HPoint_nD<T,N> >& Qw, int d);
@@ -162,7 +162,10 @@
       void globalInterpClosed(const Vector< Point_nD<T,N> >& Qw, const Vector<T>& ub, const Vector<T>& Uc, int d);
       
       void globalInterpD(const Vector< Point_nD<T,N> >& Q, const Vector< Point_nD<T,N> >& D, int d, int unitD, T a=1.0);
-      
+     
+      Matrix<T> computeInverse(const Vector<T> &v, const Vector<T> &V, const int p);
+      Matrix<T> computeInverseClosed(const Vector<T> &v, const Vector<T> &V, const int p);
+
       void projectTo(const Point_nD<T,N>& p, T guess, T& u, Point_nD<T,N>& r, T e1=0.001, T e2=0.001,int maxTry=100) const;
       
       
@@ -237,6 +240,9 @@
       Vector< HPoint_nD<T,N> > P; // the vector of control points
       Vector<T> U ;  // the knot vector
       int deg_ ;  // the degree of the NURBS curve
+
+      Matrix<T> Inverse; //changed
+      int Inverse_setted; //changed
     };
   
   typedef NurbsCurve<float,3> NurbsCurvef ;
diff -ur nurbs++-3.0.11_P1/nurbs/nurbsS.cpp nurbs++-3.0.11_P2//nurbs/nurbsS.cpp
--- nurbs++-3.0.11_P1/nurbs/nurbsS.cpp	2011-09-09 20:56:57.078708001 +0200
+++ nurbs++-3.0.11_P2//nurbs/nurbsS.cpp	2011-09-09 21:16:08.568708002 +0200
@@ -29,9 +29,7 @@
 #include <nurbsS.h>
 #include "integrate.h"
 
-#ifdef USING_VCC
 #include <malloc.h>
-#endif
 
 /*!
  */
@@ -741,8 +739,8 @@
     else {
       d = 0.0 ;
       for(k=1;k<n;k++){
-	d += cds[k] ;
-	uk[k] += d/total ;
+    	d += cds[k] ;
+        uk[k] += d/total ;
       }
     }
   }
@@ -3417,13 +3415,13 @@
 }
 
 /*!
-  \brief Decompose the surface into Bézier patches
+  \brief Decompose the surface into BÃ©zier patches
 
-  This function decomposes the curve into an array of homogenous Bézier 
+  This function decomposes the curve into an array of homogenous BÃ©zier 
   patches.
 
-  \param S  an array of Bézier segments
-  \return The number of Bézier strips in the u direction.
+  \param S  an array of BÃ©zier segments
+  \return The number of BÃ©zier strips in the u direction.
 
   \author Philippe Lavoie
   \date 8 October, 1997
@@ -3999,7 +3997,7 @@
   \date 8 October, 1997
 */
 template <class T, int N>
-int NurbsSurface<T,N>::writeRIB(const char* filename, const Color& col, const Point_nD<T,N>& view) const {
+int NurbsSurface<T,N>::writeRIB(char* filename, const Color& col, const Point_nD<T,N>& view) const {
   ofstream fout(filename) ;
   if(!fout)
     return 0;
@@ -4554,6 +4552,77 @@
 
 }
 
+/*!
+  \brief Generates a surface using global interpolation.
+
+  Generates a NURBS surface using global interpolation. In the u direction
+  the curve will be closed and with C(pU-1) continuity. Each column in Q
+  indicates the points for a closed curve in the u
+  direction. First and last point have to be equal.
+
+  \param  Q  a matrix of 3D points (wrapped in u dir. -rows)
+  \param Uk  a valid U-vector
+  \param Vk  a valid V-vector
+  \param uk  a valid u-vector
+  \param vk  a valid v-vector
+  \param pU  the degree of interpolation in the U direction
+  \param pV  the degree of interpolation in the V direction
+
+  \author Kilian Grundl
+  \date 19 July, 2011
+*/
+template <class T, int N>
+void NurbsSurface<T,N>::globalInterpClosedU(const Matrix< Point_nD<T,N> >& Q,const Vector<T> &Uk, const Vector<T> &Vk, const Vector<T> &uk, const Vector<T> &vk, int pU, int pV){
+  //Vector<T> vk,uk ;
+
+
+  if(degU != pU || degV != pV || U != Uk || V != Vk)
+   {
+      NurbsCurve<T,N> C1;
+      InverseV = C1.computeInverse(vk,Vk,pV);
+      NurbsCurve<T,N> C2;
+      InverseU = C2.computeInverseClosed(uk,Uk,pU);
+   }
+
+  resize(Q.rows(),Q.cols(),pU,pV) ;
+
+  //surfMeshParamsClosedU(Q,uk,vk,pU) ;
+  //knotAveragingClosed(uk,pU,U) ;
+  //knotAveraging(vk,pV,V) ;
+
+  U = Uk;
+  V = Vk;
+  //degU = pU;
+  //degV = pV;
+
+  Vector< HPoint_nD<T,N> > Pts(Q.cols()) ;
+
+  NurbsCurve<T,N> CV(InverseV);
+  
+  int i,j ;
+  for(i=0;i<Q.rows();i++){
+    for(j=0;j<Q.cols();j++)
+      Pts[j] = Q(i,j) ;
+    CV.globalInterpH(Pts,vk,V,degV) ;
+    for(j=0;j<Q.cols();j++)
+      P(i,j) = CV.ctrlPnts(j) ;
+  }
+
+  NurbsCurve<T,N> CU(InverseU);
+
+  Pts.resize(Q.rows()) ;
+  for(j=0;j<Q.cols();j++){
+    for(i=0;i<Q.rows();i++)
+      Pts[i] = P(i,j) ;
+    
+    CU.globalInterpClosedH(Pts,uk,U,degU);
+    for(i=0;i<Q.rows();i++)
+      P(i,j) = CU.ctrlPnts(i) ;
+  }
+
+}
+
+
 /*! 
   \brief Generates a surface using global interpolation. 
 
@@ -4602,6 +4671,77 @@
   }
 }
 
+/*!
+  \brief Generates a surface using global interpolation.
+
+  Generates a NURBS surface using global interpolation. In the u direction
+  the curve will be closed and with C(pU-1) continuity. Each column in Q
+  indicates the points for a closed curve in the u
+  direction. First and last point have to be equal.
+
+  \param  Q  a matrix of 3D points (wrapped in u dir. -rows)
+  \param Uk  a valid U-vector
+  \param Vk  a valid V-vector
+  \param uk  a valid u-vector
+  \param vk  a valid v-vector
+  \param pU  the degree of interpolation in the U direction
+  \param pV  the degree of interpolation in the V direction
+
+  \author Kilian Grundl
+  \date 19 July, 2011
+*/
+template <class T, int N>
+void NurbsSurface<T,N>::globalInterpClosedUH(const Matrix< HPoint_nD<T,N> >& Q,const Vector<T> &Uk, const Vector<T> &Vk, const Vector<T> &uk, const Vector<T> &vk, int pU, int pV){
+  //Vector<T> vk,uk ;
+
+
+  if(degU != pU || degV != pV || U != Uk || V != Vk)
+   {
+      NurbsCurve<T,N> C1;
+      InverseV = C1.computeInverse(vk,Vk,pV);
+      NurbsCurve<T,N> C2;
+      InverseU = C2.computeInverseClosed(uk,Uk,pU);
+   }
+
+  resize(Q.rows(),Q.cols(),pU,pV) ;
+
+  //surfMeshParamsClosedU(Q,uk,vk,pU) ;
+  //knotAveragingClosed(uk,pU,U) ;
+  //knotAveraging(vk,pV,V) ;
+
+  U = Uk;
+  V = Vk;
+
+  //degU = pU;
+  //degV = pV;
+
+  Vector< HPoint_nD<T,N> > Pts(Q.cols()) ;
+
+  NurbsCurve<T,N> CV(InverseV);
+
+  int i,j ;
+  for(i=0;i<Q.rows();i++){
+    for(j=0;j<Q.cols();j++)
+      Pts[j] = Q(i,j) ;
+    CV.globalInterpH(Pts,vk,V,degV) ;
+    for(j=0;j<Q.cols();j++)
+      P(i,j) = CV.ctrlPnts(j) ;
+  }
+
+  NurbsCurve<T,N> CU(InverseU);
+
+  Pts.resize(Q.rows()) ;
+  for(j=0;j<Q.cols();j++){
+    for(i=0;i<Q.rows();i++)
+      Pts[i] = P(i,j) ;
+
+    CU.globalInterpClosedH(Pts,uk,U,degU);
+    for(i=0;i<Q.rows();i++)
+      P(i,j) = CU.ctrlPnts(i) ;
+  }
+
+}
+
 
 /*! 
   \brief Generates a closed surface using global least squares approximation. 
diff -ur nurbs++-3.0.11_P1/nurbs/nurbsS.h nurbs++-3.0.11_P2//nurbs/nurbsS.h
--- nurbs++-3.0.11_P1/nurbs/nurbsS.h	2002-05-13 23:07:46.000000000 +0200
+++ nurbs++-3.0.11_P2//nurbs/nurbsS.h	2011-09-09 20:46:01.488708001 +0200
@@ -99,8 +99,8 @@
   virtual HPoint_nD<T,N> operator()(T u, T v) const ;
 
   void basisFuns(T u, T v, int spanU, int spanV, Vector<T>& Nu, Vector<T>& Nv) const ;
-  void basisFunsU(T u, int span, Vector<T>& N) const ;
-  void basisFunsV(T u, int span, Vector<T>& N) const ;
+  void basisFunsU(T u, int span, Vector<T>& M) const ;
+  void basisFunsV(T u, int span, Vector<T>& M) const ;
   void dersBasisFuns(T u, T v, int dU, int dV,int uspan, int vspan,Matrix<T> & Niku, Matrix<T>& Njkv ) const ; 
 
   // Derivative functions
@@ -114,7 +114,9 @@
   void globalInterp(const Matrix< Point_nD<T,N> >& Q, int pU, int pV);
   void globalInterpH(const Matrix< HPoint_nD<T,N> >& Q, int pU, int pV);
   void globalInterpClosedU(const Matrix< Point_nD<T,N> >& Q, int pU, int pV);
+  void globalInterpClosedU(const Matrix< Point_nD<T,N> >& Q,const Vector<T> &Uk, const Vector<T> &Vk, const Vector<T> &uk, const Vector<T> &vk, int pU, int pV);//testing
   void globalInterpClosedUH(const Matrix< HPoint_nD<T,N> >& Q, int pU, int pV);
+  void globalInterpClosedUH(const Matrix< HPoint_nD<T,N> >& Q,const Vector<T> &Uk, const Vector<T> &Vk, const Vector<T> &uk, const Vector<T> &vk, int pU, int pV);//testing
   void leastSquares(const Matrix< Point_nD<T,N> >& Q, int pU, int pV, int nU, int nV) ;
   void leastSquaresClosedU(const Matrix< Point_nD<T,N> >& Q, int pU, int pV, int nU, int nV) ;
 
@@ -135,8 +137,8 @@
   int skinU(NurbsCurveArray<T,N>& ca, int degU);
   void sweep(const NurbsCurve<T,N>& t, const NurbsCurve<T,N>& C, const NurbsCurve<T,N>& Sv, int K,int useAy=0, int invAz=0) ;
   void sweep(const NurbsCurve<T,N>& t, const NurbsCurve<T,N>& C, int K,int useAy=0, int invAz=0) ;
-  void makeFromRevolution(const NurbsCurve<T,N>& profile, const Point_nD<T,N>& S, const Point_nD<T,N>& T, double theta) ;
-  void makeFromRevolution(const NurbsCurve<T,N>& profile, const Point_nD<T,N>& S, const Point_nD<T,N>& T) ;
+  void makeFromRevolution(const NurbsCurve<T,N>& profile, const Point_nD<T,N>& S, const Point_nD<T,N>& Z, double theta) ;
+  void makeFromRevolution(const NurbsCurve<T,N>& profile, const Point_nD<T,N>& S, const Point_nD<T,N>& Z) ;
   void makeFromRevolution(const NurbsCurve<T,N>& profile) ;
 
   void makeSphere(const Point_nD<T,N>& O, T r) ; 
@@ -202,7 +204,7 @@
   int writePOVRAY(T tolerance, const char *filename, const Color& color, const Point_nD<T,N>& view, const Point_nD<T,N>& up, int smooth=0, T ambient=0.2, T diffuse=0.6) const ;
 
   int writeRIB(ostream& rib) const ;
-  int writeRIB(const char* filename, const Color& color, const Point_nD<T,N>& view) const ;
+  int writeRIB(char* filename, const Color& color, const Point_nD<T,N>& view) const ;
  
   // tesselate is deprecated...
   void tesselate(T tolerance, BasicList<Point_nD<T,N> > &points, BasicList<int> &connect, BasicList<Point_nD<T,N> > *normal=0) const ;
@@ -244,6 +246,10 @@
   Matrix< HPoint_nD<T,N> > P ; //!< The matrix of control points
   int degU ; //!< the degree of the surface in U
   int degV ; //!< the degree of the surface in V
+  
+  //changed 
+  Matrix<T> InverseU; //!< The matrix for the compution of the control points in U-direction
+  Matrix<T> InverseV; //!< The matrix for the compution of the control points in V-direction
 
 };
 
